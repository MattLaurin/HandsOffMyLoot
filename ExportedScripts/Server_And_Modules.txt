--- ServerScriptService.Main (Script) ---
--[[
	Main Server Script
	
	Description: The entry point for all server-side game logic.
	It initializes the Bootstrap module which loads, initializes,
	and starts all other controller scripts.
	
	Location: ServerScriptService
--]]
--!strict

local ServerScriptService = game:GetService("ServerScriptService")
local Bootstrap = require(ServerScriptService.Modules.Bootstrap)

-- Run the bootstrap process and tell it to look for controllers
-- inside the "Controllers" folder.
Bootstrap(ServerScriptService.Controllers)

---

--- ServerScriptService.Modules.Utils (ModuleScript) ---
--!strict
local Utils = {}

function Utils.ToggleRagdoll(character: Model, enabled: boolean)
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		if enabled then
			humanoid:ChangeState(Enum.HumanoidStateType.Physics)
		else
			humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
		end
	end
end

return Utils
---

--- ServerScriptService.Modules.DataAccessor (ModuleScript) ---
--[[
    SCRIPT: DataAccessor (MODULE SCRIPT) - SIMPLIFIED
    
    Location: ServerScriptService/Modules/DataAccessor
    
    Description: Optional wrapper for profile data access.
    Optimized: Strict typing, added key get/set for convenience.
--]]
--!strict

local ServerScriptService = game:GetService("ServerScriptService")

local PlayerController = require(ServerScriptService.Controllers.PlayerController)

local DataAccessor = {}

function DataAccessor:GetData(player: Player): table?
	local profile = PlayerController:GetProfile(player)
	return profile and profile.Data
end

function DataAccessor:SaveData(player: Player)
	local profile = PlayerController:GetProfile(player)
	if profile then
		profile:Save()
	end
end

function DataAccessor:GetKey(player: Player, key: string): any?
	local data = self:GetData(player)
	return data and data[key]
end

function DataAccessor:SetKey(player: Player, key: string, value: any)
	local data = self:GetData(player)
	if data then
		data[key] = value
	end
end

return DataAccessor
---

--- ServerScriptService.Modules.ProfileService (ModuleScript) ---
--[[
MAD STUDIO (by loleris)

-[ProfileStore]---------------------------------------

	Periodic DataStore saving solution with session locking
	
	WARNINGS FOR "Profile.Data" VALUES:
	 	! Do not create numeric tables with gaps - attempting to store such tables will result in an error.
		! Do not create mixed tables (some values indexed by number and others by a string key)
			- only numerically indexed  data will be stored.
		! Do not index tables by anything other than numbers and strings.
		! Do not reference Roblox Instances
		! Do not reference userdata (Vector3, Color3, CFrame...) - Serialize userdata before referencing
		! Do not reference functions
		
	Members:
	
		ProfileStore.IsClosing          [bool]
			-- Set to true after a game:BindToClose() trigger
			
		ProfileStore.IsCriticalState    [bool]
			-- Set to true when ProfileStore experiences too many consecutive errors
		
		ProfileStore.OnError            [Signal] (message, store_name, profile_key)
			-- Most ProfileStore errors will be caught and passed to this signal
			
		ProfileStore.OnOverwrite        [Signal] (store_name, profile_key)
			-- Triggered when a DataStore key was likely used to store data that wasn't
			a ProfileStore profile or the ProfileStore structure was invalidly manually
			altered for that DataStore key
			
		ProfileStore.OnCriticalToggle   [Signal] (is_critical)
			-- Triggered when ProfileStore experiences too many consecutive errors
		
		ProfileStore.DataStoreState     [string] ("NotReady", "NoInternet", "NoAccess", "Access")
			-- This value resembles ProfileStore's access to the DataStore; The value starts
			as "NotReady" and will eventually change to one of the other 3 possible values.
	
	Functions:
	
		ProfileStore.New(store_name, template?) --> [ProfileStore]
			store_name   [string] -- DataStore name
			template     [table] or nil -- Profiles will default to given table (hard-copy) when no data was saved previously
			
		ProfileStore.SetConstant(name, value)
			name    [string]
			value   [number]
				
	Members [ProfileStore]:
	
		ProfileStore.Mock   [ProfileStore]
			-- Reflection of ProfileStore methods, but the methods will now query a mock
			DataStore with no relation to the real DataStore
			
		ProfileStore.Name   [string]
		
	Methods [ProfileStore]:
	
		ProfileStore:StartSessionAsync(profile_key, params?) --> [Profile] or nil
			profile_key [string] -- DataStore key
			params      nil or [table]: -- Custom params; E.g. {Steal = true}
				{
					Steal = true, -- Pass this to disregard an existing session lock
					Cancel = fn() -> (boolean), -- Pass this to create a request cancel condition.
						-- If the cancel function returns true, ProfileStore will stop trying to
						-- start the session and return nil
				}
			
		ProfileStore:MessageAsync(profile_key, message) --> is_success [bool]
			profile_key [string] -- DataStore key
			message     [table] -- Data to be messaged to the profile
			
		ProfileStore:GetAsync(profile_key, version?) --> [Profile] or nil
			-- Reads a profile without starting a session - will not autosave
			profile_key   [string] -- DataStore key
			version       nil or [string] -- DataStore key version

		ProfileStore:VersionQuery(profile_key, sort_direction?, min_date?, max_date?) --> [VersionQuery]
			profile_key      [string]
			sort_direction   nil or [Enum.SortDirection]
			min_date         nil or [DateTime]
			max_date         nil or [DateTime]
			
		ProfileStore:RemoveAsync(profile_key) --> is_success [bool]
			-- Completely removes profile data from the DataStore / mock DataStore with no way to recover it.

	Methods [VersionQuery]:

		VersionQuery:NextAsync() --> [Profile] or nil -- (Yields)
			-- Returned profile is similar to profiles returned by ProfileStore:GetAsync()
		
	Members [Profile]:
	
		Profile.Data               [table]
			-- When the profile is active changes to this table are guaranteed to be saved
		Profile.LastSavedData      [table] (Read-only)
			-- Last snapshot of "Profile.Data" that has been successfully saved to the DataStore;
			Useful for proper developer product purchase receipt handling
		
		Profile.FirstSessionTime   [number] (Read-only)
			-- os.time() timestamp of the first profile session
			
		Profile.SessionLoadCount   [number] (Read-only) -- Amount of times a session was started for this profile
			
		Profile.Session            [table] (Read-only) {PlaceId = number, JobId = string} / nil
			-- Set to a table if this profile is in use by a server; nil if released

		Profile.RobloxMetaData     [table] -- Writable table that gets saved automatically and once the profile is released
		Profile.UserIds            [table] -- (Read-only) -- {user_id [number], ...} -- User ids associated with this profile

		Profile.KeyInfo            [DataStoreKeyInfo] -- Changes before OnAfterSave signal
		
		Profile.OnSave             [Signal] ()
			-- Triggered right before changes to Profile.Data are saved to the DataStore
			
		Profile.OnLastSave         [Signal] (reason [string]: "Manual", "External", "Shutdown")
			-- Triggered right before changes to Profile.Data are saved to the DataStore
			for the last time; A reason is provided for the last save:
				- "Manual"   - Profile:EndSession() was called
				- "Shutdown" - The server that has ownership of this profile is shutting down
				- "External" - Another server has started a session for this profile
			Note that this event will not trigger for when a profile session is ended by
			another server trying to take ownership of the session - this is impossible to
			do without compromising on ProfileStore's speed.
			
		Profile.OnSessionEnd       [Signal] ()
			-- Triggered when the profile session is terminated on this server
		
		Profile.OnAfterSave        [Signal] (last_saved_data)
			-- Triggered after a successful save
			last_saved_data [table] -- Profile.LastSavedData
			
		Profile.ProfileStore       [ProfileStore] -- ProfileStore object this profile belongs to
		Profile.Key                [string] -- DataStore key
		
	Methods [Profile]:
	
		Profile:IsActive() --> [bool] -- If "true" is returned, changes to Profile.Data are guaranteed to save;
			This guarantee is only valid until code yields (e.g. task.wait() is used).
			
		Profile:Reconcile() -- Fills in missing (nil) [string_key] = [value] pairs to the Profile.Data structure
			from the "template" argument that was passed to "ProfileStore.New()"
			
		Profile:EndSession() -- Call after the server has finished working with this profile
			e.g., after the player leaves (Profile object will become inactive)

		Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)
			user_id   [number]

		Profile:RemoveUserId(user_id) -- Removes user_id association with profile (safe function)
			user_id   [number]
			
		Profile:MessageHandler(fn) -- Sets a message handler for this profile
			fn [function] (message [table], processed [function]())
			-- The handler function receives a message table and a callback function;
			The callback function is to be called when a message has been processed
			- this will discard the message from the profile message cache; If the
			callback function is not called, other message handlers will also be triggered
			with unprocessed message data.
			
		Profile:Save() -- If the profile session is still active makes an UpdateAsync call
			to the DataStore to immediately save profile data

		Profile:SetAsync() -- Forcefully saves changes to the profile; Only for profiles
			loaded with ProfileStore:GetAsync() or ProfileStore:VersionQuery()
		
--]]

local AUTO_SAVE_PERIOD = 300 -- (Seconds) Time between when changes to a profile are saved to the DataStore
local LOAD_REPEAT_PERIOD = 10 -- (Seconds) Time between successive profile reads when handling a session conflict
local FIRST_LOAD_REPEAT = 5 -- (Seconds) Time between first and second profile read when handling a session conflict
local SESSION_STEAL = 40 -- (Seconds) Time until a session conflict is resolved with the waiting server stealing the session
local ASSUME_DEAD = 630 -- (Seconds) If a profile hasn't had updates for this long, quickly assume an active session belongs to a crashed server
local START_SESSION_TIMEOUT = 120 -- (Seconds) If a session can't be started for a profile for this long, stop repeating calls to the DataStore

local CRITICAL_STATE_ERROR_COUNT = 5 -- Assume critical state if this many issues happen in a short amount of time
local CRITICAL_STATE_ERROR_EXPIRE = 120 -- (Seconds) Individual issue expiration
local CRITICAL_STATE_EXPIRE = 120 -- (Seconds) Critical state expiration

local MAX_MESSAGE_QUEUE = 1000 -- Max messages saved in a profile that were sent using "ProfileStore:MessageAsync()"

----- Dependencies -----

-- local Util = require(game.ReplicatedStorage.Shared.Util)
-- local Signal = Util.Signal

local Signal do

	local FreeRunnerThread

	--[[
		Yield-safe coroutine reusing by stravant;
		Sources:
		https://devforum.roblox.com/t/lua-signal-class-comparison-optimal-goodsignal-class/1387063
		https://gist.github.com/stravant/b75a322e0919d60dde8a0316d1f09d2f
	--]]

	local function AcquireRunnerThreadAndCallEventHandler(fn, ...)
		local acquired_runner_thread = FreeRunnerThread
		FreeRunnerThread = nil
		fn(...)
		-- The handler finished running, this runner thread is free again.
		FreeRunnerThread = acquired_runner_thread
	end

	local function RunEventHandlerInFreeThread(...)
		AcquireRunnerThreadAndCallEventHandler(...)
		while true do
			AcquireRunnerThreadAndCallEventHandler(coroutine.yield())
		end
	end

	local Connection = {}
	Connection.__index = Connection

	local SignalClass = {}
	SignalClass.__index = SignalClass

	function Connection:Disconnect()

		if self.is_connected == false then
			return
		end

		local signal = self.signal
		self.is_connected = false
		signal.listener_count -= 1

		if signal.head == self then
			signal.head = self.next
		else
			local prev = signal.head
			while prev ~= nil and prev.next ~= self do
				prev = prev.next
			end
			if prev ~= nil then
				prev.next = self.next
			end
		end

	end

	function SignalClass.New()

		local self = {
			head = nil,
			listener_count = 0,
		}
		setmetatable(self, SignalClass)

		return self

	end

	function SignalClass:Connect(listener: (...any) -> ())

		if type(listener) ~= "function" then
			error(`[{script.Name}]: \"listener\" must be a function; Received {typeof(listener)}`)
		end

		local connection = {
			listener = listener,
			signal = self,
			next = self.head,
			is_connected = true,
		}
		setmetatable(connection, Connection)

		self.head = connection
		self.listener_count += 1

		return connection

	end

	function SignalClass:GetListenerCount(): number
		return self.listener_count
	end

	function SignalClass:Fire(...)
		local item = self.head
		while item ~= nil do
			if item.is_connected == true then
				if not FreeRunnerThread then
					FreeRunnerThread = coroutine.create(RunEventHandlerInFreeThread)
				end
				task.spawn(FreeRunnerThread, item.listener, ...)
			end
			item = item.next
		end
	end

	function SignalClass:Wait()
		local co = coroutine.running()
		local connection
		connection = self:Connect(function(...)
			connection:Disconnect()
			task.spawn(co, ...)
		end)
		return coroutine.yield()
	end

	Signal = table.freeze({
		New = SignalClass.New,
	})

end

----- Private -----

local ActiveSessionCheck = {} -- {[session_token] = profile, ...}
local AutoSaveList = {} -- {profile, ...} -- Loaded profile table which will be circularly auto-saved
local IssueQueue = {} -- {issue_time, ...}

local DataStoreService = game:GetService("DataStoreService")
local MessagingService = game:GetService("MessagingService")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

local PlaceId = game.PlaceId
local JobId = game.JobId

local AutoSaveIndex = 1 -- Next profile to auto save
local LastAutoSave = os.clock()

local LoadIndex = 0

local ActiveProfileLoadJobs = 0 -- Number of active threads that are loading in profiles
local ActiveProfileSaveJobs = 0 -- Number of active threads that are saving profiles

local CriticalStateStart = 0 -- os.clock()

local IsStudio = RunService:IsStudio()
local DataStoreState: "NotReady" | "NoInternet" | "NoAccess" | "Access" = "NotReady"

local MockStore = {}
local UserMockStore = {}
local MockFlag = false

local OnError = Signal.New() -- (message, store_name, profile_key)
local OnOverwrite = Signal.New() -- (store_name, profile_key)

local UpdateQueue = { -- For stability sake, we won't do UpdateAsync calls for the same key until all previous calls finish
	--[[
		[session_token] = {
			coroutine, ...
		},
		...
	--]]
}

local function WaitInUpdateQueue(session_token) --> next_in_queue()

	local is_first = false

	if UpdateQueue[session_token] == nil then
		is_first = true
		UpdateQueue[session_token] = {}
	end

	local queue = UpdateQueue[session_token]

	if is_first == false then
		table.insert(queue, coroutine.running())
		coroutine.yield()
	end

	return function()
		local next_co = table.remove(queue, 1)
		if next_co ~= nil then
			coroutine.resume(next_co)
		else
			UpdateQueue[session_token] = nil
		end
	end

end

local function SessionToken(store_name, profile_key, is_mock)

	local session_token = "L_" -- Live

	if is_mock == true then
		session_token = "U_" -- User mock
	elseif DataStoreState ~= "Access" then
		session_token = "M_" -- Mock, cause no DataStore access
	end

	session_token ..= store_name .. "\0" .. profile_key

	return session_token

end

local function DeepCopyTable(t)
	local copy = {}
	for key, value in pairs(t) do
		if type(value) == "table" then
			copy[key] = DeepCopyTable(value)
		else
			copy[key] = value
		end
	end
	return copy
end

local function ReconcileTable(target, template)
	for k, v in pairs(template) do
		if type(k) == "string" then -- Only string keys will be reconciled
			if target[k] == nil then
				if type(v) == "table" then
					target[k] = DeepCopyTable(v)
				else
					target[k] = v
				end
			elseif type(target[k]) == "table" and type(v) == "table" then
				ReconcileTable(target[k], v)
			end
		end
	end
end

local function RegisterError(error_message, store_name, profile_key) -- Called when a DataStore API call errors
	warn(`[{script.Name}]: DataStore API error (STORE:{store_name}; KEY:{profile_key}) - {tostring(error_message)}`)
	table.insert(IssueQueue, os.clock()) -- Adding issue time to queue
	OnError:Fire(tostring(error_message), store_name, profile_key)
end

local function RegisterOverwrite(store_name, profile_key) -- Called when a corrupted profile is loaded
	warn(`[{script.Name}]: Invalid profile was overwritten (STORE:{store_name}; KEY:{profile_key})`)
	OnOverwrite:Fire(store_name, profile_key)
end

local function NewMockDataStoreKeyInfo(params)

	local version_id_string = tostring(params.VersionId or 0)
	local meta_data = params.MetaData or {}
	local user_ids = params.UserIds or {}

	return {
		CreatedTime = params.CreatedTime,
		UpdatedTime = params.UpdatedTime,
		Version = string.rep("0", 16) .. "."
			.. string.rep("0", 10 - string.len(version_id_string)) .. version_id_string
			.. "." .. string.rep("0", 16) .. "." .. "01",

		GetMetadata = function()
			return DeepCopyTable(meta_data)
		end,

		GetUserIds = function()
			return DeepCopyTable(user_ids)
		end,
	}

end

local function MockUpdateAsync(mock_data_store, profile_store_name, key, transform_function, is_get_call) --> loaded_data, key_info

	local profile_store = mock_data_store[profile_store_name]

	if profile_store == nil then
		profile_store = {}
		mock_data_store[profile_store_name] = profile_store
	end

	local epoch_time = math.floor(os.time() * 1000)
	local mock_entry = profile_store[key]
	local mock_entry_was_nil = false

	if mock_entry == nil then
		mock_entry_was_nil = true
		if is_get_call ~= true then
			mock_entry = {
				Data = nil,
				CreatedTime = epoch_time,
				UpdatedTime = epoch_time,
				VersionId = 0,
				UserIds = {},
				MetaData = {},
			}
			profile_store[key] = mock_entry
		end
	end

	local mock_key_info = mock_entry_was_nil == false and NewMockDataStoreKeyInfo(mock_entry) or nil

	local transform, user_ids, roblox_meta_data = transform_function(mock_entry and mock_entry.Data, mock_key_info)

	if transform == nil then
		return nil
	else
		if mock_entry ~= nil and is_get_call ~= true then
			mock_entry.Data = DeepCopyTable(transform)
			mock_entry.UserIds = DeepCopyTable(user_ids or {})
			mock_entry.MetaData = DeepCopyTable(roblox_meta_data or {})
			mock_entry.VersionId += 1
			mock_entry.UpdatedTime = epoch_time
		end

		return DeepCopyTable(transform), mock_entry ~= nil and NewMockDataStoreKeyInfo(mock_entry) or nil
	end

end

local function UpdateAsync(profile_store, profile_key, transform_params, is_user_mock, is_get_call, version) --> loaded_data, key_info
	--transform_params = {
	--	ExistingProfileHandle = function(latest_data),
	--	MissingProfileHandle = function(latest_data),
	--	EditProfile = function(latest_data),
	--}

	local loaded_data, key_info

	local next_in_queue = WaitInUpdateQueue(SessionToken(profile_store.Name, profile_key, is_user_mock))

	local success = true

	local success, error_message = pcall(function()
		local transform_function = function(latest_data)

			local missing_profile = false
			local overwritten = false
			local global_updates = {0, {}}

			if latest_data == nil then

				missing_profile = true

			elseif type(latest_data) ~= "table" then

				missing_profile = true
				overwritten = true

			else

				if type(latest_data.Data) == "table" and type(latest_data.MetaData) == "table" and type(latest_data.GlobalUpdates) == "table" then

					-- Regular profile structure detected:

					latest_data.WasOverwritten = false -- Must be set to false if set previously
					global_updates = latest_data.GlobalUpdates

					if transform_params.ExistingProfileHandle ~= nil then
						transform_params.ExistingProfileHandle(latest_data)
					end

				elseif latest_data.Data == nil and latest_data.MetaData == nil and type(latest_data.GlobalUpdates) == "table" then

					-- Regular structure not detected, but GlobalUpdate data exists:

					latest_data.WasOverwritten = false -- Must be set to false if set previously
					global_updates = latest_data.GlobalUpdates or global_updates
					missing_profile = true

				else

					missing_profile = true
					overwritten = true

				end

			end

			-- Profile was not created or corrupted and no GlobalUpdate data exists:
			if missing_profile == true then
				latest_data = {
					-- Data = nil,
					-- MetaData = nil,
					GlobalUpdates = global_updates,
				}
				if transform_params.MissingProfileHandle ~= nil then
					transform_params.MissingProfileHandle(latest_data)
				end
			end

			-- Editing profile:
			if transform_params.EditProfile ~= nil then
				transform_params.EditProfile(latest_data)
			end

			-- Invalid data handling (Silently override with empty profile)
			if overwritten == true then
				latest_data.WasOverwritten = true -- Temporary tag that will be removed on first save
			end

			return latest_data, latest_data.UserIds, latest_data.RobloxMetaData
		end

		if is_user_mock == true then -- Used when the profile is accessed through ProfileStore.Mock

			loaded_data, key_info = MockUpdateAsync(UserMockStore, profile_store.Name, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield

		elseif DataStoreState ~= "Access" then -- Used when API access is disabled

			loaded_data, key_info = MockUpdateAsync(MockStore, profile_store.Name, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield

		else

			if is_get_call == true then

				if version ~= nil then

					local success, error_message = pcall(function()
						loaded_data, key_info = profile_store.data_store:GetVersionAsync(profile_key, version)
					end)

					if success == false and type(error_message) == "string" and string.find(error_message, "not valid") ~= nil then
						warn(`[{script.Name}]: Passed version argument is not valid; Traceback:\n` .. debug.traceback())
					end

				else

					loaded_data, key_info = profile_store.data_store:GetAsync(profile_key)

				end

				loaded_data = transform_function(loaded_data)

			else

				loaded_data, key_info = profile_store.data_store:UpdateAsync(profile_key, transform_function)

			end

		end

	end)

	next_in_queue()

	if success == true and type(loaded_data) == "table" then
		-- Invalid data handling:
		if loaded_data.WasOverwritten == true and is_get_call ~= true then
			RegisterOverwrite(
				profile_store.Name,
				profile_key
			)
		end
		-- Return loaded_data:
		return loaded_data, key_info
	else
		-- Error handling:
		RegisterError(
			error_message or "Undefined error",
			profile_store.Name,
			profile_key
		)
		-- Return nothing:
		return nil
	end

end

local function IsThisSession(session_tag)
	return session_tag[1] == PlaceId and session_tag[2] == JobId
end

local function ReadMockFlag(): boolean
	local is_mock = MockFlag
	MockFlag = false
	return is_mock
end

local function WaitForStoreReady(profile_store)
	while profile_store.is_ready == false do
		task.wait()
	end
end

local function AddProfileToAutoSave(profile)

	ActiveSessionCheck[profile.session_token] = profile

	-- Add at AutoSaveIndex and move AutoSaveIndex right:

	table.insert(AutoSaveList, AutoSaveIndex, profile)

	if #AutoSaveList > 1 then
		AutoSaveIndex = AutoSaveIndex + 1
	elseif #AutoSaveList == 1 then
		-- First profile created - make sure it doesn't get immediately auto saved:
		LastAutoSave = os.clock()
	end

end

local function RemoveProfileFromAutoSave(profile)

	ActiveSessionCheck[profile.session_token] = nil

	local auto_save_index = table.find(AutoSaveList, profile)

	if auto_save_index ~= nil then
		table.remove(AutoSaveList, auto_save_index)
		if auto_save_index < AutoSaveIndex then
			AutoSaveIndex = AutoSaveIndex - 1 -- Table contents were moved left before AutoSaveIndex so move AutoSaveIndex left as well
		end
		if AutoSaveList[AutoSaveIndex] == nil then -- AutoSaveIndex was at the end of the AutoSaveList - reset to 1
			AutoSaveIndex = 1
		end
	end

end

local function SaveProfileAsync(profile, is_ending_session, is_overwriting, last_save_reason)

	if type(profile.Data) ~= "table" then
		error(`[{script.Name}]: Developer code likely set "Profile.Data" to a non-table value! (STORE:{profile.ProfileStore.Name}; KEY:{profile.Key})`)
	end

	profile.OnSave:Fire()
	if is_ending_session == true then
		profile.OnLastSave:Fire(last_save_reason or "Manual")
	end

	if is_ending_session == true and is_overwriting ~= true then
		if profile.roblox_message_subscription ~= nil then
			profile.roblox_message_subscription:Disconnect()
		end
		RemoveProfileFromAutoSave(profile)
		profile.OnSessionEnd:Fire()
	end

	ActiveProfileSaveJobs = ActiveProfileSaveJobs + 1

	-- Compare "SessionLoadCount" when writing to profile to prevent a rare case of repeat last save when the profile is loaded on the same server again

	local repeat_save_flag = true -- Released Profile save calls have to repeat until they succeed
	local exp_backoff = 1

	while repeat_save_flag == true do

		if is_ending_session ~= true then
			repeat_save_flag = false
		end

		local loaded_data, key_info = UpdateAsync(
			profile.ProfileStore,
			profile.Key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)

					-- Check if this session still owns the profile:

					local session_owns_profile = false

					if is_overwriting ~= true then

						local active_session = latest_data.MetaData.ActiveSession
						local session_load_count = latest_data.MetaData.SessionLoadCount

						if type(active_session) == "table" then
							session_owns_profile = IsThisSession(active_session) and session_load_count == profile.load_index
						end

					else
						session_owns_profile = true
					end

					-- We may only edit the profile if this server has ownership of the profile:

					if session_owns_profile == true then

						-- Clear processed updates (messages):

						local locked_updates = profile.locked_global_updates -- [index] = true, ...
						local active_updates = latest_data.GlobalUpdates[2]
						-- ProfileService module format: {{update_id, version_id, update_locked, update_data}, ...}
						-- ProfileStore module format: {{update_id, update_data}, ...}

						if next(locked_updates) ~= nil then
							local i = 1
							while i <= #active_updates do
								local update = active_updates[i]
								if locked_updates[update[1]] == true then
									table.remove(active_updates, i)
								else
									i += 1
								end
							end
						end

						-- Save profile data:

						latest_data.Data = profile.Data
						latest_data.RobloxMetaData = profile.RobloxMetaData
						latest_data.UserIds = profile.UserIds

						if is_overwriting ~= true then

							latest_data.MetaData.LastUpdate = os.time()

							if is_ending_session == true then
								latest_data.MetaData.ActiveSession = nil
							end

						else

							latest_data.MetaData.ActiveSession = nil
							latest_data.MetaData.ForceLoadSession = nil

						end

					end

				end,
			},
			profile.is_mock
		)

		if loaded_data ~= nil and key_info ~= nil then

			if is_overwriting == true then
				break
			end

			repeat_save_flag = false

			local active_session = loaded_data.MetaData.ActiveSession
			local session_load_count = loaded_data.MetaData.SessionLoadCount
			local session_owns_profile = false

			if type(active_session) == "table" then
				session_owns_profile = IsThisSession(active_session) and session_load_count == profile.load_index
			end

			local force_load_session = loaded_data.MetaData.ForceLoadSession
			local force_load_pending = false
			if type(force_load_session) == "table" then
				force_load_pending = not IsThisSession(force_load_session)
			end

			local is_active = profile:IsActive()

			-- If another server is trying to start a session for this profile - end the session:

			if force_load_pending == true and session_owns_profile == true then
				if is_active == true then
					SaveProfileAsync(profile, true, false, "External")
				end
				break
			end

			-- Clearing processed update list / Detecting new updates:

			local locked_updates = profile.locked_global_updates -- [index] = true, ...
			local received_updates = profile.received_global_updates -- [index] = true, ...
			local active_updates = loaded_data.GlobalUpdates[2]

			local new_updates = {} -- {}, ...
			local still_pending = {} -- [index] = true, ...

			for _, update in ipairs(active_updates) do
				if locked_updates[update[1]] == true then
					still_pending[update[1]] = true
				elseif received_updates[update[1]] ~= true then
					received_updates[update[1]] = true
					table.insert(new_updates, update)
				end
			end

			for index in pairs(locked_updates) do
				if still_pending[index] ~= true then
					locked_updates[index] = nil
				end
			end

			-- Updating profile values:

			profile.KeyInfo = key_info
			profile.LastSavedData = loaded_data.Data
			profile.global_updates = loaded_data.GlobalUpdates and loaded_data.GlobalUpdates[2] or {}

			if session_owns_profile == true then
				if is_active == true and is_ending_session ~= true then

					-- Processing new global updates (messages):

					for _, update in ipairs(new_updates) do

						local index = update[1]
						local update_data = update[#update] -- Backwards compatibility with ProfileService

						for _, handler in ipairs(profile.message_handlers) do

							local is_processed = false
							local processed_callback = function()
								is_processed = true
								locked_updates[index] = true
							end

							local send_update_data = DeepCopyTable(update_data)

							task.spawn(handler, send_update_data, processed_callback)

							if is_processed == true then
								break
							end

						end

					end

				end
			else

				if profile.roblox_message_subscription ~= nil then
					profile.roblox_message_subscription:Disconnect()
				end

				if is_active == true then
					RemoveProfileFromAutoSave(profile)
					profile.OnSessionEnd:Fire()
				end

			end

			profile.OnAfterSave:Fire(profile.LastSavedData)

		elseif repeat_save_flag == true then

			-- DataStore call likely resulted in an error; Repeat the DataStore call shortly
			task.wait(exp_backoff)
			exp_backoff = math.min(if last_save_reason == "Shutdown" then 8 else 20, exp_backoff * 2)

		end

	end

	ActiveProfileSaveJobs = ActiveProfileSaveJobs - 1

end

----- Public -----

--[[
	Saved profile structure:
	
	{
		Data = {},
		
		MetaData = {
			ProfileCreateTime = 0,
			SessionLoadCount = 0,
			ActiveSession = {place_id, game_job_id, unique_session_id} / nil,
			ForceLoadSession = {place_id, game_job_id} / nil,
			LastUpdate = 0, -- os.time()
			MetaTags = {}, -- Backwards compatibility with ProfileService
		},
		
		RobloxMetaData = {},
		UserIds = {},
		
		GlobalUpdates = {
			update_index,
			{
				{update_index, data}, ...
			},
		},
	}

--]]

export type JSONAcceptable = { JSONAcceptable } | { [string]: JSONAcceptable } | number | string | boolean | buffer

export type Profile<T> = {
	Data: T & JSONAcceptable,
	LastSavedData: T & JSONAcceptable,
	FirstSessionTime: number,
	SessionLoadCount: number,
	Session: {PlaceId: number, JobId: string}?,
	RobloxMetaData: JSONAcceptable,
	UserIds: {number},
	KeyInfo: DataStoreKeyInfo,
	OnSave: {Connect: (self: any, listener: () -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnLastSave: {Connect: (self: any, listener: (reason: "Manual" | "External" | "Shutdown") -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnSessionEnd: {Connect: (self: any, listener: () -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnAfterSave: {Connect: (self: any, listener: (last_saved_data: T & JSONAcceptable) -> ()) -> ({Disconnect: (self: any) -> ()})},
	ProfileStore: JSONAcceptable,
	Key: string,

	IsActive: (self: any) -> (boolean),
	Reconcile: (self: any) -> (),
	EndSession: (self: any) -> (),
	AddUserId: (self: any, user_id: number) -> (),
	RemoveUserId: (self: any, user_id: number) -> (),
	MessageHandler: (self: any, fn: (message: JSONAcceptable, processed: () -> ()) -> ()) -> (),
	Save: (self: any) -> (),
	SetAsync: (self: any) -> (),
}

export type VersionQuery<T> = {
	NextAsync: (self: any) -> (Profile<T>?),
}

type ProfileStoreStandard<T> = {
	Name: string,
	StartSessionAsync: (self: any, profile_key: string, params: {Steal: boolean?}) -> (Profile<T>?),
	MessageAsync: (self: any, profile_key: string, message: JSONAcceptable) -> (boolean),
	GetAsync: (self: any, profile_key: string, version: string?) -> (Profile<T>?),
	VersionQuery: (self: any, profile_key: string, sort_direction: Enum.SortDirection?, min_date: DateTime | number | nil, max_date: DateTime | number | nil) -> (VersionQuery<T>),
	RemoveAsync: (self: any, profile_key: string) -> (boolean),
}

export type ProfileStore<T> = {
	Mock: ProfileStoreStandard<T>,
} & ProfileStoreStandard<T>

type ConstantName = "AUTO_SAVE_PERIOD" | "LOAD_REPEAT_PERIOD" | "FIRST_LOAD_REPEAT" | "SESSION_STEAL"
| "ASSUME_DEAD" | "START_SESSION_TIMEOUT" | "CRITICAL_STATE_ERROR_COUNT" | "CRITICAL_STATE_ERROR_EXPIRE"
| "CRITICAL_STATE_EXPIRE" | "MAX_MESSAGE_QUEUE"

export type ProfileStoreModule = {
	IsClosing: boolean,
	IsCriticalState: boolean,
	OnError: {Connect: (self: any, listener: (message: string, store_name: string, profile_key: string) -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnOverwrite: {Connect: (self: any, listener: (store_name: string, profile_key: string) -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnCriticalToggle: {Connect: (self: any, listener: (is_critical: boolean) -> ()) -> ({Disconnect: (self: any) -> ()})},
	DataStoreState: "NotReady" | "NoInternet" | "NoAccess" | "Access",
	New: <T>(store_name: string, template: (T & JSONAcceptable)?) -> (ProfileStore<T>),
	SetConstant: (name: ConstantName, value: number) -> ()
}

local Profile = {}
Profile.__index = Profile

function Profile.New(raw_data, key_info, profile_store, key, is_mock, session_token)

	local data = raw_data.Data or {}
	local session = raw_data.MetaData and raw_data.MetaData.ActiveSession or nil

	local global_updates = raw_data.GlobalUpdates and raw_data.GlobalUpdates[2] or {}
	local received_global_updates = {}

	for _, update in ipairs(global_updates) do
		received_global_updates[update[1]] = true
	end

	local self = {

		Data = data,
		LastSavedData = DeepCopyTable(data),

		FirstSessionTime = raw_data.MetaData and raw_data.MetaData.ProfileCreateTime or 0,
		SessionLoadCount = raw_data.MetaData and raw_data.MetaData.SessionLoadCount or 0,
		Session = session and {PlaceId = session[1], JobId = session[2]},

		RobloxMetaData = raw_data.RobloxMetaData or {},
		UserIds = raw_data.UserIds or {},
		KeyInfo = key_info,

		OnAfterSave = Signal.New(),
		OnSave = Signal.New(),
		OnLastSave = Signal.New(),
		OnSessionEnd = Signal.New(),

		ProfileStore = profile_store,
		Key = key,

		load_timestamp = os.clock(),
		is_mock = is_mock,
		session_token = session_token or "",
		load_index = raw_data.MetaData and raw_data.MetaData.SessionLoadCount or 0,
		locked_global_updates = {},
		received_global_updates = received_global_updates,
		message_handlers = {},
		global_updates = global_updates,

	}
	setmetatable(self, Profile)

	return self

end

function Profile:IsActive()
	return ActiveSessionCheck[self.session_token] == self
end

function Profile:Reconcile()
	ReconcileTable(self.Data, self.ProfileStore.template)
end

function Profile:EndSession()
	if self:IsActive() == true then
		task.spawn(SaveProfileAsync, self, true, nil, "Manual") -- Call save function in a new thread with release_from_session = true
	end
end

function Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)

	if type(user_id) ~= "number" or user_id % 1 ~= 0 then
		warn(`[{script.Name}]: Invalid UserId argument for :AddUserId() ({tostring(user_id)}); Traceback:\n` .. debug.traceback())
		return
	end

	if user_id < 0 and self.is_mock ~= true and DataStoreState == "Access" then
		return -- Avoid giving real Roblox APIs negative UserId's
	end

	if table.find(self.UserIds, user_id) == nil then
		table.insert(self.UserIds, user_id)
	end

end

function Profile:RemoveUserId(user_id) -- Removes user_id association with profile (safe function)

	if type(user_id) ~= "number" or user_id % 1 ~= 0 then
		warn(`[{script.Name}]: Invalid UserId argument for :RemoveUserId() ({tostring(user_id)}); Traceback:\n` .. debug.traceback())
		return
	end

	local index = table.find(self.UserIds, user_id)

	if index ~= nil then
		table.remove(self.UserIds, index)
	end

end

function Profile:SetAsync() -- Saves the profile to the DataStore and removes the session lock

	if self.view_mode ~= true then
		error(`[{script.Name}]: :SetAsync() can only be used in view mode`)
	end

	SaveProfileAsync(self, nil, true)

end

function Profile:MessageHandler(fn)

	if type(fn) ~= "function" then
		error(`[{script.Name}]: fn argument is not a function`)
	end

	if self.view_mode ~= true and self:IsActive() ~= true then
		return -- Don't process messages if the profile session was ended
	end

	local locked_updates = self.locked_global_updates
	table.insert(self.message_handlers, fn)

	for _, update in ipairs(self.global_updates) do

		local index = update[1]
		local update_data = update[#update] -- Backwards compatibility with ProfileService

		if locked_updates[index] ~= true then

			local processed_callback = function()
				locked_updates[index] = true
			end

			local send_update_data = DeepCopyTable(update_data)

			task.spawn(fn, send_update_data, processed_callback)

		end

	end

end

function Profile:Save()

	if self.view_mode == true then
		error(`[{script.Name}]: Can't save profile in view mode; Should you be calling :SetAsync() instead?`)
	end

	if self:IsActive() == false then
		warn(`[{script.Name}]: Attempted saving an inactive profile (STORE:{self.ProfileStore.Name}; KEY:{self.Key});`
			.. ` Traceback:\n` .. debug.traceback())
		return
	end

	-- Move the profile right behind the auto save index to delay the next auto save for it:
	RemoveProfileFromAutoSave(self)
	AddProfileToAutoSave(self)

	-- Perform save in new thread:
	task.spawn(SaveProfileAsync, self)

end

local ProfileStore: ProfileStoreModule = {

	IsClosing = false,
	IsCriticalState = false,
	OnError = OnError, -- (message, store_name, profile_key)
	OnOverwrite = OnOverwrite, -- (store_name, profile_key)
	OnCriticalToggle = Signal.New(), -- (is_critical)
	DataStoreState = "NotReady", -- ("NotReady", "NoInternet", "NoAccess", "Access")

}
ProfileStore.__index = ProfileStore

function ProfileStore.SetConstant(name, value)

	if type(value) ~= "number" then
		error(`[{script.Name}]: Invalid value type`)
	end

	if name == "AUTO_SAVE_PERIOD" then
		AUTO_SAVE_PERIOD = value
	elseif name == "LOAD_REPEAT_PERIOD" then
		LOAD_REPEAT_PERIOD = value
	elseif name == "FIRST_LOAD_REPEAT" then
		FIRST_LOAD_REPEAT = value
	elseif name == "SESSION_STEAL" then
		SESSION_STEAL = value
	elseif name == "ASSUME_DEAD" then
		ASSUME_DEAD = value
	elseif name == "START_SESSION_TIMEOUT" then
		START_SESSION_TIMEOUT = value
	elseif name == "CRITICAL_STATE_ERROR_COUNT" then
		CRITICAL_STATE_ERROR_COUNT = value
	elseif name == "CRITICAL_STATE_ERROR_EXPIRE" then
		CRITICAL_STATE_ERROR_EXPIRE = value
	elseif name == "CRITICAL_STATE_EXPIRE" then
		CRITICAL_STATE_EXPIRE = value
	elseif name == "MAX_MESSAGE_QUEUE" then
		MAX_MESSAGE_QUEUE = value
	else
		error(`[{script.Name}]: Invalid constant name was provided`)
	end

end

function ProfileStore.Test()
	return {
		ActiveSessionCheck = ActiveSessionCheck,
		AutoSaveList = AutoSaveList,
		ActiveProfileLoadJobs = ActiveProfileLoadJobs,
		ActiveProfileSaveJobs = ActiveProfileSaveJobs,
		MockStore = MockStore,
		UserMockStore = UserMockStore,
		UpdateQueue = UpdateQueue,
	}
end

function ProfileStore.New(store_name, template)

	template = template or {}

	if type(store_name) ~= "string" then
		error(`[{script.Name}]: Invalid or missing "store_name"`)
	elseif string.len(store_name) == 0 then
		error(`[{script.Name}]: store_name cannot be an empty string`)
	elseif string.len(store_name) > 50 then
		error(`[{script.Name}]: store_name is too long`)
	end

	if type(template) ~= "table" then
		error(`[{script.Name}]: Invalid template argument`)
	end

	local self
	self = {

		Mock = {

			Name = store_name,

			StartSessionAsync = function(_, profile_key)
				MockFlag = true
				return self:StartSessionAsync(profile_key)
			end,
			MessageAsync = function(_, profile_key, message)
				MockFlag = true
				return self:MessageAsync(profile_key, message)
			end,
			GetAsync = function(_, profile_key, version)
				MockFlag = true
				return self:GetAsync(profile_key, version)
			end,
			VersionQuery = function(_, profile_key, sort_direction, min_date, max_date)
				MockFlag = true
				return self:VersionQuery(profile_key, sort_direction, min_date, max_date)
			end,
			RemoveAsync = function(_, profile_key)
				MockFlag = true
				return self:RemoveAsync(profile_key)
			end
		},

		Name = store_name,

		template = template,
		data_store = nil,
		load_jobs = {},
		mock_load_jobs = {},
		is_ready = true,

	}
	setmetatable(self, ProfileStore)

	local options = Instance.new("DataStoreOptions")
	options:SetExperimentalFeatures({v2 = true})

	if DataStoreState == "NotReady" then

		-- The module is not sure whether DataStores are accessible yet:

		self.is_ready = false

		task.spawn(function()

			repeat task.wait() until DataStoreState ~= "NotReady"

			if DataStoreState == "Access" then
				self.data_store = DataStoreService:GetDataStore(store_name, nil, options)
			end

			self.is_ready = true

		end)

	elseif DataStoreState == "Access" then

		self.data_store = DataStoreService:GetDataStore(store_name, nil, options)

	end

	return self

end

local function RobloxMessageSubscription(profile, unique_session_id)

	local last_roblox_message = 0

	local roblox_message_subscription = MessagingService:SubscribeAsync("PS_" .. unique_session_id, function(message)
		if type(message.Data) == "table" and message.Data.LoadCount == profile.SessionLoadCount then
			-- High reaction rate, based on numPlayers Ã— 10 DataStore budget as of writing
			if os.clock() - last_roblox_message > 6 then 
				last_roblox_message = os.clock()
				if profile:IsActive() == true then
					if message.Data.EndSession == true then
						SaveProfileAsync(profile, true, false, "External")
					else
						profile:Save()
					end
				end
			end
		end
	end)

	if profile:IsActive() == true then
		profile.roblox_message_subscription = roblox_message_subscription
	else
		roblox_message_subscription:Disconnect()
	end

end

function ProfileStore:StartSessionAsync(profile_key, params)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" then
		error(`[{script.Name}]: profile_key must be a string`)
	elseif string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	elseif string.len(profile_key) > 50 then
		error(`[{script.Name}]: profile_key is too long`)
	end

	if params ~= nil and type(params) ~= "table" then
		error(`[{script.Name}]: Invalid params`)
	end

	params = params or {}

	if ProfileStore.IsClosing == true then
		return nil
	end

	WaitForStoreReady(self)

	local session_token = SessionToken(self.Name, profile_key, is_mock)

	if ActiveSessionCheck[session_token] ~= nil then
		error(`[{script.Name}]: Profile (STORE:{self.Name}; KEY:{profile_key}) is already loaded in this session`)
	end

	ActiveProfileLoadJobs = ActiveProfileLoadJobs + 1

	local is_user_cancel = false

	local function cancel_condition()
		if is_user_cancel == false then
			if params.Cancel ~= nil then
				is_user_cancel = params.Cancel() == true
			end
			return is_user_cancel
		end
		return true
	end

	local user_steal = params.Steal == true

	local force_load_steps = 0 -- Session conflict handling values
	local request_force_load = true
	local steal_session = false

	local start = os.clock()
	local exp_backoff = 1

	while ProfileStore.IsClosing == false and cancel_condition() == false do

		-- Load profile:

		-- SPECIAL CASE - If StartSessionAsync is called for the same key again before another StartSessionAsync finishes,
		-- grab the DataStore return for the new call. The early call will return nil. This is supposed to retain
		-- expected and efficient behavior in cases where a player would quickly rejoin the same server.

		LoadIndex += 1
		local load_id = LoadIndex
		local profile_load_jobs = is_mock == true and self.mock_load_jobs or self.load_jobs
		local profile_load_job = profile_load_jobs[profile_key] -- {load_id, {loaded_data, key_info} or nil}

		local loaded_data, key_info
		local unique_session_id = HttpService:GenerateGUID(false)

		if profile_load_job ~= nil then

			profile_load_job[1] = load_id -- Steal load job
			while profile_load_job[2] == nil do -- Wait for job to finish
				task.wait()
			end
			if profile_load_job[1] == load_id then -- Load job hasn't been double-stolen
				loaded_data, key_info = table.unpack(profile_load_job[2])
				profile_load_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil
			end

		else

			profile_load_job = {load_id, nil}
			profile_load_jobs[profile_key] = profile_load_job

			profile_load_job[2] = table.pack(UpdateAsync(
				self,
				profile_key,
				{
					ExistingProfileHandle = function(latest_data)

						if ProfileStore.IsClosing == true or cancel_condition() == true then
							return
						end

						local active_session = latest_data.MetaData.ActiveSession
						local force_load_session = latest_data.MetaData.ForceLoadSession

						if active_session == nil then
							latest_data.MetaData.ActiveSession = {PlaceId, JobId, unique_session_id}
							latest_data.MetaData.ForceLoadSession = nil
						elseif type(active_session) == "table" then
							if IsThisSession(active_session) == false then
								local last_update = latest_data.MetaData.LastUpdate
								if last_update ~= nil then
									if os.time() - last_update > ASSUME_DEAD then
										latest_data.MetaData.ActiveSession = {PlaceId, JobId, unique_session_id}
										latest_data.MetaData.ForceLoadSession = nil
										return
									end
								end
								if steal_session == true or user_steal == true then
									local force_load_interrupted = if force_load_session ~= nil then not IsThisSession(force_load_session) else true
									if force_load_interrupted == false or user_steal == true then
										latest_data.MetaData.ActiveSession = {PlaceId, JobId, unique_session_id}
										latest_data.MetaData.ForceLoadSession = nil
									end
								elseif request_force_load == true then
									latest_data.MetaData.ForceLoadSession = {PlaceId, JobId}
								end
							else
								latest_data.MetaData.ForceLoadSession = nil
							end
						end

					end,
					MissingProfileHandle = function(latest_data)

						local is_cancel = ProfileStore.IsClosing == true or cancel_condition() == true

						latest_data.Data = DeepCopyTable(self.template)
						latest_data.MetaData = {
							ProfileCreateTime = os.time(),
							SessionLoadCount = 0,
							ActiveSession = if is_cancel == false then {PlaceId, JobId, unique_session_id} else nil,
							ForceLoadSession = nil,
							MetaTags = {}, -- Backwards compatibility with ProfileService
						}

					end,
					EditProfile = function(latest_data)

						if ProfileStore.IsClosing == true or cancel_condition() == true then
							return
						end

						local active_session = latest_data.MetaData.ActiveSession
						if active_session ~= nil and IsThisSession(active_session) == true then
							latest_data.MetaData.SessionLoadCount = latest_data.MetaData.SessionLoadCount + 1
							latest_data.MetaData.LastUpdate = os.time()
						end

					end,
				},
				is_mock
				))
			if profile_load_job[1] == load_id then -- Load job hasn't been stolen
				loaded_data, key_info = table.unpack(profile_load_job[2])
				profile_load_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- Load job stolen
			end
		end

		-- Handle load_data:

		if loaded_data ~= nil and key_info ~= nil then
			local active_session = loaded_data.MetaData.ActiveSession
			if type(active_session) == "table" then

				if IsThisSession(active_session) == true then

					-- Profile is now taken by this session:

					local profile = Profile.New(loaded_data, key_info, self, profile_key, is_mock, session_token)
					AddProfileToAutoSave(profile)

					if is_mock ~= true and DataStoreState == "Access" then

						-- Use MessagingService to quickly detect session conflicts and resolve them quickly:
						task.spawn(RobloxMessageSubscription, profile, unique_session_id) -- Blocking prevention

					end

					if ProfileStore.IsClosing == true or cancel_condition() == true then
						-- The server has initiated a shutdown by the time this profile was loaded
						SaveProfileAsync(profile, true) -- Release profile and yield until the DataStore call is finished
						profile = nil -- Don't return the profile object
					end

					ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
					return profile

				else

					if ProfileStore.IsClosing == true or cancel_condition() == true then
						ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
						return nil
					end

					-- Profile is taken by some other session:

					local force_load_session = loaded_data.MetaData.ForceLoadSession
					local force_load_interrupted = if force_load_session ~= nil then not IsThisSession(force_load_session) else true

					if force_load_interrupted == false then

						if request_force_load == false then
							force_load_steps = force_load_steps + 1
							if force_load_steps >= math.ceil(SESSION_STEAL / LOAD_REPEAT_PERIOD) then
								steal_session = true
							end
						end

						-- Request the remote server to end its session:
						if type(active_session[3]) == "string" then
							local session_load_count = loaded_data.MetaData.SessionLoadCount or 0
							task.spawn(MessagingService.PublishAsync, MessagingService, "PS_" .. active_session[3], {LoadCount = session_load_count, EndSession = true})
						end

						-- Attempt to load the profile again after a delay
						local wait_until = os.clock() + if request_force_load == true then FIRST_LOAD_REPEAT else LOAD_REPEAT_PERIOD
						repeat task.wait() until os.clock() >= wait_until or ProfileStore.IsClosing == true

					else
						-- Another session tried to load this profile:
						ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
						return nil
					end

					request_force_load = false -- Only request a force load once

				end

			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- In this scenario it is likely that this server started shutting down
			end
		else

			-- A DataStore call has likely ended in an error:

			local default_timeout = false

			if params.Cancel == nil then
				default_timeout = os.clock() - start >= START_SESSION_TIMEOUT
			end

			if default_timeout == true or ProfileStore.IsClosing == true or cancel_condition() == true then
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil
			end

			task.wait(exp_backoff)  -- Repeat the call shortly
			exp_backoff = math.min(20, exp_backoff * 2)

		end

	end

	ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
	return nil -- Game started shutting down or the request was cancelled - don't return the profile

end

function ProfileStore:MessageAsync(profile_key, message)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" then
		error(`[{script.Name}]: profile_key must be a string`)
	elseif string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	elseif string.len(profile_key) > 50 then
		error(`[{script.Name}]: profile_key is too long`)
	end

	if type(message) ~= "table" then
		error(`[{script.Name}]: message must be a table`)
	end

	if ProfileStore.IsClosing == true then
		return false
	end

	WaitForStoreReady(self)

	local exp_backoff = 1

	while ProfileStore.IsClosing == false do

		-- Updating profile:

		local loaded_data = UpdateAsync(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)

					local global_updates = latest_data.GlobalUpdates
					local update_list = global_updates[2]
					--{
					--	update_index,
					--	{
					--		{update_index, data}, ...
					--	},
					--},

					global_updates[1] += 1
					table.insert(update_list, {global_updates[1], message})

					-- Clearing queue if above limit:

					while #update_list > MAX_MESSAGE_QUEUE do
						table.remove(update_list, 1)
					end

				end,
			},
			is_mock
		)

		if loaded_data ~= nil then

			local session_token = SessionToken(self.Name, profile_key, is_mock)

			local profile = ActiveSessionCheck[session_token]

			if profile ~= nil then

				-- The message was sent to a profile that is active in this server:
				profile:Save()

			else

				local meta_data = loaded_data.MetaData or {}
				local active_session = meta_data.ActiveSession
				local session_load_count = meta_data.SessionLoadCount or 0

				if type(active_session) == "table" and type(active_session[3]) == "string" then
					-- Request the remote server to auto-save sooner and receive the message:
					task.spawn(MessagingService.PublishAsync, MessagingService, "PS_" .. active_session[3], {LoadCount = session_load_count})
				end

			end

			return true

		else

			task.wait(exp_backoff) -- A DataStore call has likely ended in an error - repeat the call shortly
			exp_backoff = math.min(20, exp_backoff * 2)

		end

	end

	return false

end

function ProfileStore:GetAsync(profile_key, version)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" then
		error(`[{script.Name}]: profile_key must be a string`)
	elseif string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	elseif string.len(profile_key) > 50 then
		error(`[{script.Name}]: profile_key is too long`)
	end

	if ProfileStore.IsClosing == true then
		return nil
	end

	WaitForStoreReady(self)

	if version ~= nil and (is_mock or DataStoreState ~= "Access") then
		return nil -- No version support in mock mode
	end

	local exp_backoff = 1

	while ProfileStore.IsClosing == false do

		-- Load profile:

		local loaded_data, key_info = UpdateAsync(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = function(latest_data)

					latest_data.Data = DeepCopyTable(self.template)
					latest_data.MetaData = {
						ProfileCreateTime = os.time(),
						SessionLoadCount = 0,
						ActiveSession = nil,
						ForceLoadSession = nil,
						MetaTags = {}, -- Backwards compatibility with ProfileService
					}

				end,
				EditProfile = nil,
			},
			is_mock,
			true, -- Use :GetAsync()
			version -- DataStore key version
		)

		-- Handle load_data:

		if loaded_data ~= nil then

			if key_info == nil then
				return nil -- Load was successful, but the key was empty - return no profile object
			end

			local profile = Profile.New(loaded_data, key_info, self, profile_key, is_mock)
			profile.view_mode = true

			return profile

		else

			task.wait(exp_backoff) -- A DataStore call has likely ended in an error - repeat the call shortly
			exp_backoff = math.min(20, exp_backoff * 2)

		end

	end

	return nil -- Game started shutting down - don't return the profile

end

function ProfileStore:RemoveAsync(profile_key)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	end

	if ProfileStore.IsClosing == true then
		return false
	end

	WaitForStoreReady(self)

	local wipe_status = false

	local next_in_queue = WaitInUpdateQueue(SessionToken(self.Name, profile_key, is_mock))

	if is_mock == true then -- Used when the profile is accessed through ProfileStore.Mock

		local mock_data_store = UserMockStore[self.Name]

		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
			if next(mock_data_store) == nil then
				UserMockStore[self.Name] = nil
			end
		end

		wipe_status = true
		task.wait() -- Simulate API call yield

	elseif DataStoreState ~= "Access" then -- Used when API access is disabled

		local mock_data_store = MockStore[self.Name]

		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
			if next(mock_data_store) == nil then
				MockStore[self.Name] = nil
			end
		end

		wipe_status = true
		task.wait() -- Simulate API call yield

	else -- Live DataStore

		wipe_status = pcall(function()
			self.data_store:RemoveAsync(profile_key)
		end)

	end

	next_in_queue()

	return wipe_status

end

local ProfileVersionQuery = {}
ProfileVersionQuery.__index = ProfileVersionQuery

function ProfileVersionQuery.New(profile_store, profile_key, sort_direction, min_date, max_date, is_mock)

	local self = {
		profile_store = profile_store,
		profile_key = profile_key,
		sort_direction = sort_direction,
		min_date = min_date,
		max_date = max_date,

		query_pages = nil,
		query_index = 0,
		query_failure = false,

		is_query_yielded = false,
		query_queue = {},

		is_mock = is_mock,
	}
	setmetatable(self, ProfileVersionQuery)

	return self

end

function MoveVersionQueryQueue(self) -- Hidden ProfileVersionQuery method
	while #self.query_queue > 0 do

		local queue_entry = table.remove(self.query_queue, 1)

		task.spawn(queue_entry)

		if self.is_query_yielded == true then
			break
		end

	end
end

local VersionQueryNextAsyncStackingFlag = false
local WarnAboutVersionQueryOnce = false

function ProfileVersionQuery:NextAsync()

	local is_stacking = VersionQueryNextAsyncStackingFlag == true
	VersionQueryNextAsyncStackingFlag = false

	WaitForStoreReady(self.profile_store)

	if ProfileStore.IsClosing == true then
		return nil -- Silently fail :NextAsync() requests
	end

	if self.is_mock == true or DataStoreState ~= "Access" then
		if IsStudio == true and WarnAboutVersionQueryOnce == false then
			WarnAboutVersionQueryOnce = true
			warn(`[{script.Name}]: :VersionQuery() is not supported in mock mode!`)
		end
		return nil -- Silently fail :NextAsync() requests
	end

	local profile
	local is_finished = false

	local function query_job()

		if self.query_failure == true then
			is_finished = true
			return
		end

		-- First "next" call loads version pages:

		if self.query_pages == nil then

			self.is_query_yielded = true

			task.spawn(function()
				VersionQueryNextAsyncStackingFlag = true
				profile = self:NextAsync()
				is_finished = true
			end)

			local list_success, error_message = pcall(function()
				self.query_pages = self.profile_store.data_store:ListVersionsAsync(
					self.profile_key,
					self.sort_direction,
					self.min_date,
					self.max_date
				)
				self.query_index = 0
			end)

			if list_success == false or self.query_pages == nil then
				warn(`[{script.Name}]: Version query fail - {tostring(error_message)}`)
				self.query_failure = true
			end

			self.is_query_yielded = false

			MoveVersionQueryQueue(self)

			return

		end

		local current_page = self.query_pages:GetCurrentPage()
		local next_item = current_page[self.query_index + 1]

		-- No more entries:

		if self.query_pages.IsFinished == true and next_item == nil then
			is_finished = true
			return
		end

		-- Load next page when this page is over:

		if next_item == nil then

			self.is_query_yielded = true
			task.spawn(function()
				VersionQueryNextAsyncStackingFlag = true
				profile = self:NextAsync()
				is_finished = true
			end)

			local success, error_message = pcall(function()
				self.query_pages:AdvanceToNextPageAsync()
				self.query_index = 0
			end)

			if success == false or #self.query_pages:GetCurrentPage() == 0 then
				self.query_failure = true
			end

			self.is_query_yielded = false
			MoveVersionQueryQueue(self)

			return

		end

		-- Next page item:

		self.query_index += 1
		profile = self.profile_store:GetAsync(self.profile_key, next_item.Version)
		is_finished = true

	end

	if self.is_query_yielded == false then
		query_job()
	else
		if is_stacking == true then
			table.insert(self.query_queue, 1, query_job)
		else
			table.insert(self.query_queue, query_job)
		end
	end

	while is_finished == false do
		task.wait()
	end

	return profile

end

function ProfileStore:VersionQuery(profile_key, sort_direction, min_date, max_date)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	end

	-- Type check:

	if sort_direction ~= nil and (typeof(sort_direction) ~= "EnumItem"
		or sort_direction.EnumType ~= Enum.SortDirection) then
		error(`[{script.Name}]: Invalid sort_direction ({tostring(sort_direction)})`)
	end

	if min_date ~= nil and typeof(min_date) ~= "DateTime" and typeof(min_date) ~= "number" then
		error(`[{script.Name}]: Invalid min_date ({tostring(min_date)})`)
	end

	if max_date ~= nil and typeof(max_date) ~= "DateTime" and typeof(max_date) ~= "number" then
		error(`[{script.Name}]: Invalid max_date ({tostring(max_date)})`)
	end

	min_date = typeof(min_date) == "DateTime" and min_date.UnixTimestampMillis or min_date
	max_date = typeof(max_date) == "DateTime" and max_date.UnixTimestampMillis or max_date

	return ProfileVersionQuery.New(self, profile_key, sort_direction, min_date, max_date, is_mock)

end

-- DataStore API access check:

if IsStudio == true then

	task.spawn(function()

		local new_state = "NoAccess"

		local status, message = pcall(function()
			-- This will error if current instance has no Studio API access:
			DataStoreService:GetDataStore("____PS"):SetAsync("____PS", os.time())
		end)

		local no_internet_access = status == false and string.find(message, "ConnectFail", 1, true) ~= nil

		if no_internet_access == true then
			warn(`[{script.Name}]: No internet access - check your network connection`)
		end

		if status == false and
			(string.find(message, "403", 1, true) ~= nil or -- Cannot write to DataStore from studio if API access is not enabled
				string.find(message, "must publish", 1, true) ~= nil or -- Game must be published to access live keys
				no_internet_access == true) then -- No internet access

			new_state = if no_internet_access == true then "NoInternet" else "NoAccess"
			print(`[{script.Name}]: Roblox API services unavailable - data will not be saved`)
		else
			new_state = "Access"
			--print(`[{script.Name}]: Roblox API services available - data will be saved`)
		end

		DataStoreState = new_state
		ProfileStore.DataStoreState = new_state

	end)

else

	DataStoreState = "Access"
	ProfileStore.DataStoreState = "Access"

end

-- Update loop:

RunService.Heartbeat:Connect(function()

	-- Auto saving:

	local auto_save_list_length = #AutoSaveList
	if auto_save_list_length > 0 then
		local auto_save_index_speed = AUTO_SAVE_PERIOD / auto_save_list_length
		local os_clock = os.clock()
		while os_clock - LastAutoSave > auto_save_index_speed do
			LastAutoSave = LastAutoSave + auto_save_index_speed
			local profile = AutoSaveList[AutoSaveIndex]
			if os_clock - profile.load_timestamp < AUTO_SAVE_PERIOD / 2 then
				-- This profile is freshly loaded - auto saving immediately is not necessary:
				profile = nil
				for _ = 1, auto_save_list_length - 1 do
					-- Move auto save index to the right:
					AutoSaveIndex = AutoSaveIndex + 1
					if AutoSaveIndex > auto_save_list_length then
						AutoSaveIndex = 1
					end
					profile = AutoSaveList[AutoSaveIndex]
					if os_clock - profile.load_timestamp >= AUTO_SAVE_PERIOD / 2 then
						break
					else
						profile = nil
					end
				end
			end
			-- Move auto save index to the right:
			AutoSaveIndex = AutoSaveIndex + 1
			if AutoSaveIndex > auto_save_list_length then
				AutoSaveIndex = 1
			end
			-- Perform save call:
			if profile ~= nil then
				task.spawn(SaveProfileAsync, profile) -- Auto save profile in new thread
			end
		end
	end

	-- Critical state handling:

	if ProfileStore.IsCriticalState == false then
		if #IssueQueue >= CRITICAL_STATE_ERROR_COUNT then
			ProfileStore.IsCriticalState = true
			ProfileStore.OnCriticalToggle:Fire(true)
			CriticalStateStart = os.clock()
			warn(`[{script.Name}]: Entered critical state`)
		end
	else
		if #IssueQueue >= CRITICAL_STATE_ERROR_COUNT then
			CriticalStateStart = os.clock()
		elseif os.clock() - CriticalStateStart > CRITICAL_STATE_EXPIRE then
			ProfileStore.IsCriticalState = false
			ProfileStore.OnCriticalToggle:Fire(false)
			warn(`[{script.Name}]: Critical state ended`)
		end
	end

	-- Issue queue:

	while true do
		local issue_time = IssueQueue[1]
		if issue_time == nil then
			break
		elseif os.clock() - issue_time > CRITICAL_STATE_ERROR_EXPIRE then
			table.remove(IssueQueue, 1)
		else
			break
		end
	end

end)

-- Release all loaded profiles when the server is shutting down:

task.spawn(function()

	while DataStoreState == "NotReady" do
		task.wait()
	end

	if DataStoreState ~= "Access" then

		game:BindToClose(function()
			ProfileStore.IsClosing = true
			task.wait() -- Mock shutdown delay
		end)

		return -- Don't wait for profiles to properly save in mock mode so studio could end the simulation faster

	end

	game:BindToClose(function()

		ProfileStore.IsClosing = true

		-- Release all active profiles:
		-- (Clone AutoSaveList to a new table because AutoSaveList changes when profiles are released)

		local on_close_save_job_count = 0
		local active_profiles = {}
		for index, profile in ipairs(AutoSaveList) do
			active_profiles[index] = profile
		end

		-- Release the profiles; Releasing profiles can trigger listeners that release other profiles, so check active state:
		for _, profile in ipairs(active_profiles) do
			if profile:IsActive() == true then
				on_close_save_job_count = on_close_save_job_count + 1
				task.spawn(function() -- Save profile on new thread
					SaveProfileAsync(profile, true, nil, "Shutdown")
					on_close_save_job_count = on_close_save_job_count - 1
				end)
			end
		end

		-- Yield until all active profile jobs are finished:
		while on_close_save_job_count > 0 or ActiveProfileLoadJobs > 0 or ActiveProfileSaveJobs > 0 do
			task.wait()
		end

		return -- We're done!

	end)

end)

return ProfileStore
---

--- ServerScriptService.Modules.Bootstrap (ModuleScript) ---
--!strict

local Extensions = require(script:WaitForChild("Extensions"))

local Bootstrap = {}

local isRunning: boolean = false
local controllers: {[string]: any} = {}

function Bootstrap(container: Instance)
	if isRunning then
		error("[Bootstrap] Already initialized!")
	end
	isRunning = true

	-- Load controllers
	for _, module: Instance in container:GetDescendants() do
		if module:IsA("ModuleScript") and module.Name:match("Controller$") then
			local controllerName: string = module.Name
			local success, requiredModule = pcall(require, module)
			if success then
				setmetatable(requiredModule, Extensions.Controller)
				requiredModule._bs_name = controllerName
				controllers[controllerName] = requiredModule
			end
		end
	end

	-- This block fixes the race condition by setting up instances first.
	local playerController = controllers.PlayerController
	if playerController and playerController.SetupSharedInstances then
		playerController:SetupSharedInstances()
	else
		warn("[Bootstrap] Could not find PlayerController to set up shared instances!")
	end

	-- Initialize controllers
	for _, controller in controllers do
		if controller.Init then
			controller:Init(controllers)
		end
	end

	-- Start controllers
	for _, controller in controllers do
		if controller.Start then
			task.spawn(function()
				pcall(controller.Start, controller, controllers)
			end)
		end
	end
end

return Bootstrap
---

--- ServerScriptService.Modules.Bootstrap.Extensions (ModuleScript) ---
--[[
    SCRIPT: Extensions (MODULE SCRIPT) - OPTIMIZED
    
    Location: ServerScriptService/Modules/Bootstrap/Extensions
    
    Description: Base metatable for controllers with shared methods.
    Clean code: Strict typing, simplified.
--]]
--!strict

local Extensions = {}

local Controller = {}
Controller.__index = Controller

function Controller:IsInitialized(): boolean
	return self._bs_initialized or false
end

Extensions.Controller = Controller

return Extensions
---

--- ReplicatedStorage.Modules.NumberFormatter (ModuleScript) ---
--!strict

local NumberFormatter = {}

local suffixes: {string} = {"", "K", "M", "B", "T", "Q"}

-- ## MODIFIED ## Changed to a more generic function that accepts an optional prefix.
function NumberFormatter.formatNumber(number: number, prefix: string?): string
	-- Use the provided prefix, or an empty string if none is given.
	local formattedString: string = prefix or ""
	local i: number = 1

	while number >= 1000 and i < #suffixes do
		number /= 1000
		i += 1
	end

	local suffix: string = suffixes[i]
	if suffix == "" then
		formattedString ..= tostring(math.floor(number))
	else
		formattedString ..= string.format("%.2f", number) .. suffix
	end

	return formattedString
end

return NumberFormatter
---

--- ReplicatedStorage.Modules.NotificationManager (ModuleScript) ---
--!strict
-- ReplicatedStorage.Modules.NotificationManager.lua (Client-only module)

local CollectionService = game:GetService("CollectionService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SoundService = game:GetService("SoundService")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting") -- ## ADDED ##

local NotificationManager = {}

local playerGui: PlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
local notificationFrame: Frame = playerGui:WaitForChild("GUI"):WaitForChild("Frames"):WaitForChild("Notifications")
local notificationTemplate: TextLabel = ReplicatedStorage:WaitForChild("Templates"):WaitForChild("NotificationTemplate")

local TWEEN_INFO_FADE: TweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
local NOTIFICATION_LIFETIME: number = 5

-- ## ADDED ## Variables for the time shift effect
local ORIGINAL_CLOCK_TIME = 14.5
local isTimeShifted = false

-- Color definitions
local successStrokeColor = Color3.fromRGB(33, 100, 0)
local successGradient = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 0)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 0))
})

local errorStrokeColor = Color3.fromRGB(145, 0, 0)
local errorGradient = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 85, 127))
})

local normalStrokeColor = Color3.fromRGB(145, 97, 0)
local normalGradient = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 170, 0)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 0))
})

-- ## ADDED ## New styles for Legendary and Mythical
local legendaryStrokeColor = Color3.fromRGB(125, 0, 0)
local legendaryGradient = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 0))
})

local mythicalStrokeColor = Color3.fromRGB(100, 33, 50)
local mythicalGradient = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 127)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 170, 127))
})


-- ## NEW FUNCTION ## Handles the entire day-to-night-to-day animation
local function triggerTimeShift()
	if isTimeShifted then return end
	isTimeShifted = true

	local tweenInfo = TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)

	-- Transition to night
	local toNightTween = TweenService:Create(Lighting, tweenInfo, {ClockTime = 0})
	toNightTween:Play()
	toNightTween.Completed:Wait()

	-- Hold for 5 seconds
	task.wait(5)

	-- Transition back to day
	local toDayTween = TweenService:Create(Lighting, tweenInfo, {ClockTime = ORIGINAL_CLOCK_TIME})
	toDayTween:Play()
	toDayTween.Completed:Wait()

	isTimeShifted = false
end


function NotificationManager.show(message: string, messageType: string?)
	local newNotification: TextLabel = notificationTemplate:Clone()
	newNotification.Text = message

	local stroke: UIStroke? = newNotification:FindFirstChild("Stroke")
	local gradient: UIGradient? = newNotification:FindFirstChild("Gradient")
	local lifetime = NOTIFICATION_LIFETIME

	if not stroke or not gradient then
		if messageType == "Success" then
			newNotification.TextColor3 = successStrokeColor -- âœ… FIX APPLIED HERE
		elseif messageType == "Error" then
			newNotification.TextColor3 = errorStrokeColor -- âœ… FIX APPLIED HERE
		end
	else
		if messageType == "Success" then
			stroke.Color = successStrokeColor
			gradient.Color = successGradient
		elseif messageType == "Error" then
			stroke.Color = errorStrokeColor
			gradient.Color = errorGradient
		elseif messageType == "Legendary" then
			stroke.Color = legendaryStrokeColor
			gradient.Color = legendaryGradient
			lifetime = 7
			task.spawn(triggerTimeShift) -- ## ADDED ##
		elseif messageType == "Mythical" then
			stroke.Color = mythicalStrokeColor
			gradient.Color = mythicalGradient
			lifetime = 10
			task.spawn(triggerTimeShift) -- ## ADDED ##
		elseif messageType == "Normal" then
			stroke.Color = normalStrokeColor
			gradient.Color = normalGradient
		else
			stroke.Color = normalStrokeColor
			gradient.Color = normalGradient
		end
	end

	newNotification.Parent = notificationFrame

	newNotification.TextTransparency = 1
	if stroke then stroke.Transparency = 1 end

	local textFadeIn: Tween = TweenService:Create(newNotification, TWEEN_INFO_FADE, {TextTransparency = 0})
	local strokeFadeIn: Tween? = stroke and TweenService:Create(stroke, TWEEN_INFO_FADE, {Transparency = 0})

	textFadeIn:Play()
	if strokeFadeIn then strokeFadeIn:Play() end

	if messageType and messageType ~= "NotNormal" then
		local sound: Sound? = Workspace.Sounds:FindFirstChild(messageType)
		if sound then
			SoundService:PlayLocalSound(sound)
		end
	end

	task.wait(lifetime)

	local textFadeOut: Tween = TweenService:Create(newNotification, TWEEN_INFO_FADE, {TextTransparency = 1})
	local strokeFadeOut: Tween? = stroke and TweenService:Create(stroke, TWEEN_INFO_FADE, {Transparency = 1})

	textFadeOut:Play()
	if strokeFadeOut then strokeFadeOut:Play() end

	textFadeOut.Completed:Wait()
	newNotification:Destroy()
end

return NotificationManager
---

--- ReplicatedStorage.Modules.FrameManager (ModuleScript) ---
--!strict

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local FrameManager = {}

-- Event system to broadcast frame state changes
local frameOpenedCallbacks = {}
local frameClosedCallbacks = {}

function FrameManager.onFrameOpened(callback: (frameName: string) -> ())
	table.insert(frameOpenedCallbacks, callback)
end

function FrameManager.onFrameClosed(callback: (frameName: string) -> ())
	table.insert(frameClosedCallbacks, callback)
end

local playerGui: PlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
local framesContainer: Folder = playerGui:WaitForChild("GUI"):WaitForChild("Frames")
local TWEEN_INFO: TweenInfo = TweenInfo.new(0.4, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)

local currentlyOpenFrame: Frame? = nil
local framePositions: {[Frame]: UDim2} = {}
local activeTweens: {[Frame]: {Animation: Tween, CleanupThread: thread?}} = {} -- ## ADDED ##

-- ## NEW FUNCTION ## Safely cancels any ongoing tween and its cleanup task for a given frame.
local function cancelActiveTween(frame: Frame)
	local activeTweenInfo = activeTweens[frame]
	if activeTweenInfo then
		activeTweenInfo.Animation:Cancel()
		if activeTweenInfo.CleanupThread then
			task.cancel(activeTweenInfo.CleanupThread)
		end
		activeTweens[frame] = nil
	end
end

function FrameManager.getOpenFrameName()
	if currentlyOpenFrame and currentlyOpenFrame.Parent then
		return currentlyOpenFrame.Name
	end
	return nil
end

local function initializeFrame(frame: Frame)
	if not framePositions[frame] then
		framePositions[frame] = frame.Position
		local hiddenPosition: UDim2 = UDim2.new(framePositions[frame].X.Scale, framePositions[frame].X.Offset, 1.5, 0)
		frame.Position = hiddenPosition
		frame.Visible = false
	end
end

function FrameManager.close(frameName: string)
	local targetFrame: Frame? = framesContainer:FindFirstChild(frameName)
	if not targetFrame then return end

	-- Do nothing if it's already invisible and not the open frame (avoids closing an already closed frame)
	if not targetFrame.Visible and currentlyOpenFrame ~= targetFrame then return end

	cancelActiveTween(targetFrame) -- Cancel any other tweens on this frame

	if currentlyOpenFrame == targetFrame then
		currentlyOpenFrame = nil
	end

	for _, callback in ipairs(frameClosedCallbacks) do
		task.spawn(callback, frameName)
	end

	initializeFrame(targetFrame)
	local hiddenPosition: UDim2 = UDim2.new(framePositions[targetFrame].X.Scale, framePositions[targetFrame].X.Offset, 1.5, 0)
	local slideOutTween: Tween = TweenService:Create(targetFrame, TWEEN_INFO, {Position = hiddenPosition})

	-- Create a cleanup thread that will run after the animation
	local cleanupThread = task.spawn(function()
		slideOutTween.Completed:Wait()
		targetFrame.Visible = false
		activeTweens[targetFrame] = nil -- Remove from active list once done
	end)

	-- Track the new animation and its cleanup thread
	activeTweens[targetFrame] = {Animation = slideOutTween, CleanupThread = cleanupThread}
	slideOutTween:Play()
end

function FrameManager.open(frameName: string)
	local targetFrame: Frame? = framesContainer:FindFirstChild(frameName)
	if not targetFrame or currentlyOpenFrame == targetFrame then return end

	cancelActiveTween(targetFrame) -- Cancel any other tweens on this frame

	initializeFrame(targetFrame)
	if currentlyOpenFrame then
		FrameManager.close(currentlyOpenFrame.Name)
	end
	targetFrame.Visible = true
	local originalPosition: UDim2 = framePositions[targetFrame]
	local slideInTween: Tween = TweenService:Create(targetFrame, TWEEN_INFO, {Position = originalPosition})

	-- Track the new animation
	activeTweens[targetFrame] = {Animation = slideInTween}
	slideInTween:Play()

	currentlyOpenFrame = targetFrame

	for _, callback in ipairs(frameOpenedCallbacks) do
		task.spawn(callback, frameName)
	end
end

function FrameManager.connect(button: TextButton | ImageButton, frameName: string, action: "Toggle" | "Open" | "Close"?)
	local targetFrame: Frame? = framesContainer:FindFirstChild(frameName)
	if not button or not targetFrame then return end
	action = action or "Toggle"
	initializeFrame(targetFrame)
	button.MouseButton1Click:Connect(function()
		if action == "Close" then
			FrameManager.close(frameName)
		elseif action == "Open" then
			FrameManager.open(frameName)
		else -- Toggle
			if currentlyOpenFrame == targetFrame then
				FrameManager.close(frameName)
			else
				FrameManager.open(frameName)
			end
		end
	end)
end

return FrameManager
---

--- ReplicatedStorage.Modules.HitboxClass (ModuleScript) ---
--!strict

-----------------------------------------------------------------------
--                         HitboxClass v1.1A                         --
-----------------------------------------------------------------------
-- License:                                                          --
--   Licensed under the MIT license.                                 --
--                                                                   --
-- Author:                                                           --
--   RedTrio (VulkanAPI) - January 12, 2024 - Created the module.    --
--                                                                   --
-- Uses Signal by sleitnick.                                         --
-----------------------------------------------------------------------

-- Let me know if you come across any bugs or errors!

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterPlayer = game:GetService("StarterPlayer")
local Players = game:GetService("Players")

local moduleSettings = script.Settings

-- Initial error checking

assert(moduleSettings:FindFirstChild("Alive Folder"), "No Alive Folder setting found in HitboxClass settings! Make an object value and name it 'Alive Folder' and parent it there!")

local aliveFolder = moduleSettings["Alive Folder"].Value

assert(moduleSettings:FindFirstChild("Projectile Folder"), "No Projectile Folder setting found in HitboxClass settings! Make an object value and name it 'Projectile Folder' and parent it there!")

local projectileFolder = moduleSettings["Projectile Folder"].Value

local velocityConstant = moduleSettings:FindFirstChild("Velocity Prediction Constant")

if not velocityConstant then
	warn("Velocity Constant Setting has been deleted! 6 will be used as a default. (HitboxClass)")
end

assert(aliveFolder ~= nil, "Set the alive characters folder in the HitboxClass settings!")
assert(projectileFolder ~= nil, "Set the projectiles folder in the HitboxClass settings!")
assert(aliveFolder:IsDescendantOf(workspace), "The alive folder must be a descendant of workspace! (HitboxClass)")
assert(projectileFolder:IsDescendantOf(workspace), "The projectile folder must be a descendant of workspace! (HitboxClass)")

-- now we initialize the class
local Types = require(script.Types)
local signal = require(script.Signal)
local Timer = require(script.Timer)

local overlapParamsHumanoid = OverlapParams.new()
overlapParamsHumanoid.FilterDescendantsInstances = {aliveFolder}
overlapParamsHumanoid.FilterType = Enum.RaycastFilterType.Include

local overlapParamsObject = OverlapParams.new()
overlapParamsObject.FilterDescendantsInstances = {projectileFolder}
overlapParamsObject.FilterType =  Enum.RaycastFilterType.Exclude

local CFrameZero = CFrame.new(Vector3.zero)

local RunService = game:GetService("RunService")

local HitboxRemote = nil

local function SetupClients()
	local newRemoteEvent = Instance.new("RemoteEvent")
	newRemoteEvent.Name = "HitboxClassRemote"
	newRemoteEvent.Parent = ReplicatedStorage
	HitboxRemote = newRemoteEvent

	local newLocalScript = script.HitboxClassLocal:Clone()
	local newSignalModule = script.Signal:Clone()
	
	local newReference = Instance.new("ObjectValue")
	newReference.Value = script
	newReference.Name = "HitboxClass Module"
	newReference.Parent = newLocalScript

	newSignalModule.Parent = newLocalScript

	newLocalScript.Parent = StarterPlayer:FindFirstChildOfClass("StarterPlayerScripts")

	task.spawn(function()
		for i, Player : Player in pairs(Players:GetChildren()) do

			local ScreenGUI = Instance.new("ScreenGui")
			ScreenGUI.Name = "HitboxClassContainer"
			ScreenGUI.ResetOnSpawn = false

			local newScriptClone = newLocalScript:Clone()
			newScriptClone.Parent = ScreenGUI
			newScriptClone.Enabled = true

			ScreenGUI.Parent = Player:WaitForChild("PlayerGui")

		end
	end)

	newLocalScript.Enabled = true

end

if RunService:IsServer() then
	SetupClients()
else
	HitboxRemote = ReplicatedStorage:FindFirstChild("HitboxClassRemote")
	if not HitboxRemote then
		warn("HitboxClass must be initialized on the server before using it on the client! Waiting for RemoteEvent!")
		HitboxRemote = ReplicatedStorage:WaitForChild("HitboxClassRemote")
	end
end

local Hitbox = {} :: Types.Hitbox

local HitboxCache = {} :: {Types.Hitbox}

local function DeepCopyTable(tableToCopy : {})
	local copy = {}	

	for key, value in pairs(tableToCopy) do	
		if type(value) == "table" then		
			copy[key] = DeepCopyTable(value)		
		else	
			copy[key] = value	
		end
	end

	return copy
end

function Hitbox.new(HitboxParams : Types.HitboxParams)
	local self = (setmetatable({}, {__index = Hitbox}) :: unknown) :: Types.Hitbox

	self.TaggedChars = {}
	self.TaggedObjects = {}
	self.SendingChars = {}
	self.SendingObjects = {}
	self.DelayThreads = {}

	if RunService:IsClient() and HitboxParams._Tick then
		self.TickVal = HitboxParams._Tick
	else
		self.TickVal = workspace:GetServerTimeNow()
	end

	if HitboxParams.ID then
		self.ID = HitboxParams.ID
	end

	self.Blacklist = HitboxParams.Blacklist

	self.HitSomeone = signal.new()
	self.HitObject = signal.new()

	self.DebugMode = HitboxParams.Debug or false
	
	self.Lifetime = HitboxParams.Debris or 0
	
	self.LookingFor = HitboxParams.LookingFor or "Humanoid"

	if HitboxParams.UseClient then

		self.Client = HitboxParams.UseClient

		-- copy the params
		local newDictionary  = DeepCopyTable(HitboxParams) :: Types.HitboxParams

		-- get rid of the UseClient parameter
		newDictionary.UseClient = nil

		-- set the tickval to be the same as the hitbox's tickval
		newDictionary._Tick = self.TickVal

		-- fire to the client and wait for a response to ensure they got their hitbox set up
		local readyToGo = false

		local tempWaitEvent : RBXScriptConnection

		tempWaitEvent = HitboxRemote.OnServerEvent:Connect(function(player, tickVal)
			if player ~= self.Client then return end
			if tickVal ~= self.TickVal then return end

			readyToGo = true

		end)

		assert(self.Client)

		local startWaitTime = workspace:GetServerTimeNow()

		HitboxRemote:FireClient(self.Client, "New", newDictionary)

		repeat task.wait() until readyToGo or workspace:GetServerTimeNow() - startWaitTime >= 1.5

		tempWaitEvent:Disconnect()

		if not readyToGo then return self, false end

	else
		self.Position = HitboxParams.InitialPosition or CFrameZero
		self.DebounceTime = HitboxParams.DebounceTime or 0
		self.VelocityPrediction = HitboxParams.VelocityPrediction

		if self.VelocityPrediction == nil then
			self.VelocityPrediction = true
		end

		self.DotProductRequirement = HitboxParams.DotProductRequirement

		self.DebugMode = HitboxParams.Debug or false

		if typeof(HitboxParams.SizeOrPart) == "Vector3" then

			self.SpatialOption = HitboxParams.SpatialOption or "InBox"

			assert(self.SpatialOption ~= "InRadius", "You can't use InRadius as the SpatialOption if a Vector3 is passed! Only InPart and InBox! (HitboxClass)")

			self.Mode =  "Part"
			self.Size = HitboxParams.SizeOrPart

			if self.SpatialOption == "InPart" then
				self:_GeneratePart()
			end

		elseif type(HitboxParams.SizeOrPart) == "number" then

			self.SpatialOption = HitboxParams.SpatialOption or "Magnitude"

			if self.SpatialOption == "InRadius" then
				self.Mode = "Part"
				self.Size = HitboxParams.SizeOrPart
			elseif self.SpatialOption == "InPart" then
				self.Mode = "Part"
				self.Size = Vector3.new(HitboxParams.SizeOrPart, HitboxParams.SizeOrPart, HitboxParams.SizeOrPart)
				self:_GeneratePart()
			elseif self.SpatialOption == "InBox" then
				self.Mode = "Part"
				self.Size = Vector3.new(HitboxParams.SizeOrPart, HitboxParams.SizeOrPart, HitboxParams.SizeOrPart)
			else
				self.Mode =  "Magnitude"
				self.Size = HitboxParams.SizeOrPart
			end

		else 
			self.Mode =  "Part"
			self.Size = HitboxParams.SizeOrPart.Size
			self.Part = HitboxParams.SizeOrPart:Clone()


			self.SpatialOption = "InPart"

			assert(self.Part, "No part provided?")

			assert(self.Part and self.Part:IsA("Part"))

			self.Part.Color = Color3.new(1,0,0)
			self.Part.Name = "Hitbox"..self.TickVal
		end	

		if self.DebugMode then
			self:SetDebug(true)
		end

	end

	table.insert(HitboxCache, self)

	return self, true

end

function Hitbox:ClearTaggedChars()
	if self.Client then
		HitboxRemote:FireClient(self.Client, "ClrTag", {_Tick = self.TickVal})
	else
		table.clear(self.TaggedChars)
	end

end

function Hitbox:Start()
	
	-- if the lifetime is greater than 0
	if self.Lifetime > 0 then
		-- check to see if there's a timer, if there is one, then start it
		if not self.Timer then
			-- make a new timer
			self.Timer = Timer.new(0.1, function()
				self.Lifetime -= 0.1
				if self.Lifetime <= 0 then
					self:Destroy()
				end
			end)
			
		else
			self.Timer:On()
		end
		
	end

	if self.Client then

		self.ClientConnection = HitboxRemote.OnServerEvent:Connect(function(player : Player, tickVal : number, HitTable)
			if HitTable == nil then return end
			if player ~= self.Client then return end
			if tickVal ~= self.TickVal then return end	
			if type(HitTable) ~= "table" then return end
			
			if self.LookingFor == "Humanoid" then
				-- remove all HitTable that isn't a model, isn't a descendant of the alive folder, or doesn't have a humanoid, or is nil entirely
				for i = #HitTable, 1, -1 do
					if (not HitTable[i]) or (typeof(HitTable[i]) ~= "Instance") or (not HitTable[i]:IsDescendantOf(aliveFolder)) or (not HitTable[i]:FindFirstChildOfClass("Humanoid")) or (not HitTable[i]:IsA("Model")) then
						table.remove(HitTable, i)
					end

					-- if everything else is valid, double check to make sure the model passed in is not in the hitbox's blacklist
					if self.Blacklist then
						if table.find(self.Blacklist, HitTable[i]) then
							table.remove(HitTable, i)
						end
					end

				end

				-- if after everything is said and done there's nothing left, don't fire the signal
				if #HitTable <= 0 then return end

				self.HitSomeone:Fire(HitTable)
			elseif self.LookingFor == "Object" then
				for i = #HitTable, 1, -1 do
					if (not HitTable[i]) or (typeof(HitTable[i]) ~= "Instance") or (not HitTable[i]:IsA("BasePart")) then
						table.remove(HitTable, i)
						continue
					end

					-- if everything else is valid, double check to make sure the model passed in is not in the hitbox's blacklist
					if self.Blacklist then
						for _, blacklisted in pairs(self.Blacklist) do
							if HitTable[i] == blacklisted or HitTable[i]:IsDescendantOf(blacklisted) then
								table.remove(HitTable, i)
							end
						end
					end

				end
				
				-- if after everything is said and done there's nothing left, don't fire the signal
				if #HitTable <= 0 then return end
				
				self.HitObject:Fire(HitTable)
			end
			
		end)

		HitboxRemote:FireClient(self.Client, "Start", {_Tick = self.TickVal})

	elseif self.Mode == "Magnitude" then

		assert(typeof(self.Size) == "number", "Magnitude hitbox wasn't given a number! Type given: "..typeof(self.Size))

		if self.Part and self.DebugMode then

			self.Part.Parent = projectileFolder
		end

		self.RunServiceConnection = RunService.Heartbeat:Connect(function(DT)

			if self.PartWeld then
				self:SetPosition(self.PartWeld.CFrame * (self.PartWeldOffset or CFrameZero))
			end

			-- go through the alive folder
			for i, Character : Instance in pairs(aliveFolder:GetChildren()) do

				-- check to see if it's a model with a primary part that also has a humanoid
				if Character:IsA("Model") and Character.PrimaryPart ~= nil and Character:FindFirstChildOfClass("Humanoid") then
					local magnitude = (self.Position.Position - Character.PrimaryPart.Position).Magnitude

					-- if they're greater than the distance of the hitbox, skip them
					if magnitude > self.Size then continue end

					-- if they're in the blacklist, skip them
					if self.Blacklist then
						if table.find(self.Blacklist, Character) then
							continue
						end
					end

					-- check the dot product if one is given
					if self.DotProductRequirement then
						local VectorToCompare = (Character.PrimaryPart.CFrame.Position - self.DotProductRequirement.PartForVector.CFrame.Position).Unit

						local VectorOfUser : Vector3

						-- changed to a long if statement block cause strict mode was throwing a hissy fit
						-- "attempting a dynamic property access on type 'CFrame' is unsafe and may cause exceptions at runtime"

						if self.DotProductRequirement.VectorType then
							if self.DotProductRequirement.VectorType == "LookVector" then
								VectorOfUser = self.DotProductRequirement.PartForVector.CFrame.LookVector
							elseif self.DotProductRequirement.VectorType == "UpVector" then
								VectorOfUser = self.DotProductRequirement.PartForVector.CFrame.UpVector
							elseif self.DotProductRequirement.VectorType == "RightVector" then
								VectorOfUser = self.DotProductRequirement.PartForVector.CFrame.RightVector
							end
						else
							VectorOfUser = self.DotProductRequirement.PartForVector.CFrame.LookVector
						end

						if self.DotProductRequirement.Negative then
							VectorOfUser *= -1
						end

						if VectorToCompare:Dot(VectorOfUser) < self.DotProductRequirement.DotProduct then
							continue
						end

					end

					-- if they've already been tagged, skip them
					if self.TaggedChars[Character] then continue end

					if magnitude <= self.Size then
						table.insert(self.SendingChars, Character)
					end

				end

			end


			self:_SiftThroughSendingCharsAndFire()

		end)	
		
	else

		if (self.SpatialOption == "InPart") or (self.Part and self.DebugMode == true) then
			self.Part.Parent = projectileFolder
		end

		self.RunServiceConnection = RunService.Heartbeat:Connect(function(DT)

			if self.PartWeld then
				self:SetPosition(self.PartWeld.CFrame * (self.PartWeldOffset or CFrameZero))
			end

			local results

			if self.SpatialOption == "InBox" then
				if self.LookingFor == "Humanoid" then
					results = workspace:GetPartBoundsInBox(self.Position, self.Size, overlapParamsHumanoid)
				else
					results = workspace:GetPartBoundsInBox(self.Position, self.Size, overlapParamsObject)
				end
			elseif self.SpatialOption == "InRadius" then
				if self.LookingFor == "Humanoid" then
					results = workspace:GetPartBoundsInRadius(self.Position.Position, self.Size, overlapParamsHumanoid)
				else
					results = workspace:GetPartBoundsInRadius(self.Position.Position, self.Size, overlapParamsObject)
				end
			else
				if self.LookingFor == "Humanoid" then
					results = workspace:GetPartsInPart(self.Part, overlapParamsHumanoid)
				else
					results = workspace:GetPartsInPart(self.Part, overlapParamsObject)
				end
			end

			for i, Part : BasePart in pairs(results) do

				if not Part.Parent then continue end
				
				if self.LookingFor == "Humanoid" then
					local Character = Part.Parent

					if not Character:IsA("Model") then continue end

					if Character.PrimaryPart == nil or not Character:FindFirstChildOfClass("Humanoid") then continue end

					if self.Blacklist then
						if table.find(self.Blacklist, Character) then
							continue
						end
					end


					if not table.find(self.SendingChars, Character) and not self.TaggedChars[Character] then	

						table.insert(self.SendingChars, Character)

					end
				else
					
					local BlacklistFound = false
					
					if self.Blacklist then
						-- go through the blacklist and flip the bool and break if the part is found
						-- in the blacklist
						for i = #self.Blacklist, 1, -1 do

							local checkingPart = self.Blacklist[i]
							
							if Part == checkingPart or Part:IsDescendantOf(checkingPart) then
								BlacklistFound = true
								break
							end
						end
					end
					

					if not table.find(self.SendingObjects, Part) and not self.TaggedObjects[Part] and not BlacklistFound then

						table.insert(self.SendingObjects, Part)

					end
				end
				
				
			end

			if self.LookingFor == "Humanoid" then
				self:_SiftThroughSendingCharsAndFire()
			elseif self.LookingFor == "Object" then
				self:_SiftThroughSendingObjectsAndFire()
			end
			

		end)
		
	end
	
end

function Hitbox:Stop()
	
	if self.Timer then
		self.Timer:Off()
	end
	
	if self.Client then
		if self.ClientConnection then
			self.ClientConnection:Disconnect()
			self.ClientConnection = nil
		end
		HitboxRemote:FireClient(self.Client, "Stop", {_Tick = self.TickVal})
	else
		if self.Part then
			self.Part:Remove()
		end

		if self.RunServiceConnection then
			self.RunServiceConnection:Disconnect()
			self.RunServiceConnection = nil
		end
	end

end

function Hitbox:SetPosition(newPosition : CFrame)

	if self.Client then
		HitboxRemote:FireClient(self.Client, "PosCh", {_Tick = self.TickVal, Position = newPosition})
	end

	local constant

	if velocityConstant then
		constant = velocityConstant.Value or 6
	else
		constant = 6
	end

	if RunService:IsServer() and self.PartWeld and self.VelocityPrediction then
		local velocityVector =  newPosition:VectorToObjectSpace(self.PartWeld.AssemblyLinearVelocity) / constant
		newPosition = newPosition * CFrame.new(velocityVector)
	end


	self.Position = newPosition

	if self.Part then
		self.Part.CFrame = newPosition
	end
end

function Hitbox:WeldTo(PartToWeldTo : BasePart, OffsetCFrame : CFrame?)

	if self.Client then
		HitboxRemote:FireClient(self.Client, "Weld", {_Tick = self.TickVal, WeldTo = PartToWeldTo, Offset = OffsetCFrame})
	end

	self.PartWeld = PartToWeldTo
	self.PartWeldOffset = OffsetCFrame

end

function Hitbox:Unweld()
	if self.Client then
		HitboxRemote:FireClient(self.Client, "Unweld", {_Tick = self.TickVal})
	end

	self.PartWeld = nil
	self.PartWeldOffset = nil

end

function Hitbox:ChangeWeldOffset(OffsetCFrame : CFrame)

	if self.Client then
		HitboxRemote:FireClient(self.Client, "WeldOfs", {_Tick = self.TickVal, Offset = OffsetCFrame})
	end

	self.PartWeldOffset = OffsetCFrame
end

function Hitbox:SetVelocityPrediction(state : boolean)
	self.VelocityPrediction = state
end

function Hitbox:SetDebug(state : boolean)
	self.DebugMode = state

	if self.Client then
		HitboxRemote:FireClient(self.Client, "Dbg", {_Tick = self.TickVal, Debug = state})
		return
	end

	if self.DebugMode then
		if not self.Part then
			self:_GeneratePart()
			assert(self.Part, "Part wasn't generated after the GeneratePart method?")
			
			if self.RunServiceConnection then
				self.Part.Parent = projectileFolder
			end

		else
			self.Part.Transparency = 0.45

			if self.SpatialOption ~= "InPart" and self.RunServiceConnection then
				self.Part.Parent = projectileFolder
			end

		end
	else
		if self.Part then

			if self.SpatialOption ~= "InPart" then
				self.Part:Remove()
			end

			self.Part.Transparency = 1
		end
	end
end

function Hitbox.ClearHitboxesWithID(ID : number | string)
	if RunService:IsClient() then return end

	-- go through the cache and destroy any hitboxes with the ID provided
	for i = #HitboxCache, 1, -1 do

		local checkingHitbox = HitboxCache[i]

		if checkingHitbox.ID and checkingHitbox.ID == ID then
			pcall(function()
				checkingHitbox:Destroy()
			end)
		end
	end

end

function Hitbox.ClearClientHitboxes(client : Player)

	if RunService:IsClient() then return end

	-- go through the cache and destroy any hitboxes associated with the client
	for i = #HitboxCache, 1, -1 do

		local checkingHitbox = HitboxCache[i]

		if checkingHitbox.Client and checkingHitbox.Client == client then
			pcall(function()
				checkingHitbox:Destroy()
			end)
		end
	end

	-- make sure everything is cleared on the client
	HitboxRemote:FireClient(client, "Clr")
end

function Hitbox.GetHitboxCache()
	return HitboxCache
end

function Hitbox:_SiftThroughSendingObjectsAndFire()
	if #self.SendingObjects <= 0 then return end

	local shallowObjectTable = {}

	for i, Object in pairs(self.SendingObjects) do
		table.insert(shallowObjectTable, Object)

		self.TaggedObjects[Object] = true

		if self.DebounceTime > 0 then
			local newThread = task.delay(self.DebounceTime, function()

				self.TaggedObjects[Object] = nil

			end)

			table.insert(self.DelayThreads, newThread)

		end

	end


	if #shallowObjectTable > 0 then
		if RunService:IsClient() then
			HitboxRemote:FireServer(self.TickVal, shallowObjectTable)
		end

		self.HitObject:Fire(shallowObjectTable)
	end

	if self.SendingObjects then
		table.clear(self.SendingObjects)
	end
end

function Hitbox:_SiftThroughSendingCharsAndFire()
	
	if #self.SendingChars <= 0 then return end
	
	local shallowObjectTable = {}
	
	for i, Object : Model in pairs(self.SendingChars) do
		table.insert(shallowObjectTable, Object)
		
		self.TaggedChars[Object] = true

		if self.DebounceTime > 0 then
			local newThread = task.delay(self.DebounceTime, function()
				
				self.TaggedChars[Object] = nil
				
			end)
			
			table.insert(self.DelayThreads, newThread)

		end

	end


	if #shallowObjectTable > 0 then
		if RunService:IsClient() then
			HitboxRemote:FireServer(self.TickVal, shallowObjectTable)
		end

		self.HitSomeone:Fire(shallowObjectTable)

	end

	if self.SendingChars then
		table.clear(self.SendingChars)
	end

end

function Hitbox:_GeneratePart()

	if self.Part then return end

	if typeof(self.Size) == "Vector3" then
		self.Mode =  "Part"
		self.Part = Instance.new("Part")


		assert(self.Part, "Part was nil!")
		assert(typeof(self.Size) == "Vector3", "self.Size wasn't a vector3 when making a part!") -- you shouldn't get here, but just in case

		self.Part.Color = Color3.new(1, 0, 0)

		if self.DebugMode then
			self.Part.Transparency = 0.45
		else
			self.Part.Transparency = 1
		end

		self.Part.Anchored = true
		self.Part.Massless = true
		self.Part.CanCollide = false

		self.Part.Size = self.Size
		self.Part.CFrame = self.Position

		self.Part.Name = "Hitbox"..self.TickVal
	elseif type(self.Size) == "number" then
		self.Part = Instance.new("Part")

		assert(self.Part and self.Part:IsA("Part"))
		assert(typeof(self.Size) == "number", "self.Size wasn't a number when making a sphere part!") -- you shouldn't get here, but just in case

		self.Part.Shape = Enum.PartType.Ball
		self.Part.Anchored = true
		self.Part.Massless = true
		self.Part.CanCollide = false
		self.Part.Size = Vector3.new(self.Size * 2, self.Size * 2, self.Size * 2)
		self.Part.Transparency = 0.45
		self.Part.Color = Color3.new(1, 0, 0)
		self.Part.CFrame = self.Position
		self.Part.Name = "Hitbox"..self.TickVal
	end
end

function Hitbox:Destroy()

	-- remove the hitbox from the cache
	table.remove(HitboxCache, table.find(HitboxCache, self))

	-- tell the client to destroy the hitbox on their end
	if self.Client then
		HitboxRemote:FireClient(self.Client, "Des", {_Tick = self.TickVal})
	end

	-- stop the hitbox
	if self.Client then
		if self.ClientConnection then
			self.ClientConnection:Disconnect()
			self.ClientConnection = nil
		end
	else
		if self.Part then
			self.Part:Remove()
		end

		if self.RunServiceConnection then
			self.RunServiceConnection:Disconnect()
			self.RunServiceConnection = nil
		end
	end

	-- disconnect all connections to the HitSomeone signal
	pcall(function()
		self.HitSomeone:Destroy()
	end)
	
	-- disconnect all connections to the HitObject signal
	pcall(function()
		self.HitObject:Destroy()
	end)
	
	-- if there's a timer, destroy it
	pcall(function()
		if self.Timer then
			self.Timer:Destroy()
		end
	end)

	-- cancel all debounce threads
	if self.DelayThreads then
		for i, thread in pairs(self.DelayThreads) do
			pcall(function()
				task.cancel(thread)
			end)
		end
	end
	
	-- if there's a part, destroy it
	if self.Part then
		self.Part:Destroy()
	end

	-- clear out all tables
	pcall(function()
		table.clear(self.TaggedChars)
	end)

	pcall(function()
		table.clear(self.SendingChars)
	end)

	pcall(function()
		table.clear(self)
	end)

end

return Hitbox
---

--- ReplicatedStorage.Modules.HitboxClass.HitboxClassLocal (LocalScript) ---
--!strict

local require = require
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local signal = require(script:WaitForChild("Signal"))
local HitboxClassRemote = ReplicatedStorage:WaitForChild("HitboxClassRemote") :: RemoteEvent
local HitboxClass = require(script["HitboxClass Module"].Value)

local currentHitboxes = {}

HitboxClassRemote.OnClientEvent:Connect(function(mode, packet)
	
	if mode == "Clr" then
		for i, Hitbox in pairs(currentHitboxes) do
			Hitbox:Destroy()
			currentHitboxes[i] = nil
		end
		return
	end
	
	if mode ~= "New" and not currentHitboxes[packet._Tick] then warn("No hitbox found on the client for tick value sent. Don't change the tick value manually, change the ID instead. (HitboxClass)") return end
	
	if mode == "New" then
		local newHitbox = HitboxClass.new(packet)
		currentHitboxes[packet._Tick] = newHitbox
		HitboxClassRemote:FireServer(packet._Tick)
	end
	
	if mode == "Start" then
		currentHitboxes[packet._Tick]:Start()
	end
	
	if mode == "Stop" then
		currentHitboxes[packet._Tick]:Stop()
	end
	
	if mode == "ClrTag" then
		currentHitboxes[packet._Tick]:ClearTaggedChars()
	end
	
	if mode == "Weld" then
		currentHitboxes[packet._Tick]:WeldTo(packet.WeldTo, packet.Offset)
	end
	
	if mode == "WeldOfs" then
		currentHitboxes[packet._Tick]:ChangeWeldOffset(packet.Offset)
	end
	
	if mode == "Unweld" then
		currentHitboxes[packet._Tick]:Unweld()
	end
	
	if mode == "PosCh" then
		currentHitboxes[packet._Tick]:SetPosition(packet.Position)
	end
	
	if mode == "Dbg" then
		currentHitboxes[packet._Tick]:SetDebug(packet.Debug)
	end
	
	if mode == "Des" then
		currentHitboxes[packet._Tick]:Destroy()
		currentHitboxes[packet._Tick] = nil
	end
	
end)
---

--- ReplicatedStorage.Modules.HitboxClass.Types (ModuleScript) ---
local Types = {}

-- temp signal to make the types
local signal = require(script.Parent.Signal)
local timer = require(script.Parent.Timer)
local newSignal = signal.new()

export type SignalType<T...> = typeof(newSignal)

export type SignalConnection = typeof(newSignal:Connect())

export type DotProductRequirement = {
	DotProduct : number,
	PartForVector : BasePart,
	VectorType : ("LookVector" | "UpVector" | "RightVector")?,
	Negative : boolean?
}

export type HitboxParams = {
	SizeOrPart : Vector3 | number | BasePart,
	SpatialOption : ("InBox" | "InRadius" | "InPart")?,
	InitialPosition : CFrame?,
	Blacklist : {Model}?,
	DebounceTime : number?,
	DotProductRequirement : DotProductRequirement?,
	UseClient : Player?,
	ID : (string | number)?,
	VelocityPrediction : boolean?,
	Debug : boolean?,
	Debris : number?,
	LookingFor : ("Humanoid" | "Object")?,
	
	-- Private fields
	_Tick : number?
}

export type Hitbox = {

	-- Fields

	Size : Vector3 | number,
	Mode : "Magnitude" | "Part",
	SpatialOption : "InBox" | "InRadius" | "InPart" | "Magnitude",
	LookingFor : "Humanoid" | "Object",
	DebounceTime : number,
	Part : BasePart?,
	Position : CFrame,
	DotProductRequirement : DotProductRequirement?,
	TaggedChars : {[Model] : boolean},
	TaggedObjects : {[BasePart] : boolean},
	ID : (string | number)?,
	TickVal : number,
	Blacklist : {}?,
	SendingChars : {Model},
	SendingObjects : {BasePart},
	DelayThreads : {thread},
	HitSomeone : signal.Signal<{Model}>,
	HitObject : signal.Signal<{BasePart}>,
	RunServiceConnection : RBXScriptConnection?,
	ClientConnection : RBXScriptConnection?,
	PartWeld : BasePart?,
	PartWeldOffset : CFrame?,
	Client : Player?,
	VelocityPrediction : boolean?,
	DebugMode : boolean,
	Lifetime : number,
	

	-- Methods

	new : (HitboxParams) -> (Hitbox, boolean),
	ClearClientHitboxes : (Client : Player) -> (),
	ClearHitboxesWithID : (ID : string | number) -> (),
	GetHitboxCache : () -> {Hitbox},
	ClearTaggedChars : (self : Hitbox) -> (),
	Start : (self : Hitbox) -> (),
	Stop : (self : Hitbox) -> (),
	SetPosition : (self : Hitbox, Position : CFrame) -> (),
	Destroy : (self : Hitbox) -> (),
	WeldTo : (self : Hitbox , PartToWeldTo : BasePart, OffsetCFrame : CFrame?) -> (),
	Unweld : (self : Hitbox) -> (),
	ChangeWeldOffset : (self : Hitbox, OffsetCFrame : CFrame) -> (),
	SetVelocityPrediction : (self : Hitbox, state : boolean) -> (),
	SetDebug : (self : Hitbox, state : boolean) -> (),

	-- Private Methods (Don't touch unless you know what you're doing!)

	_SiftThroughSendingCharsAndFire : (self : Hitbox) -> (),
	_SiftThroughSendingObjectsAndFire : (self : Hitbox) -> (),
	_GeneratePart : (self : Hitbox) -> (),
	
	-- Private Fields (Don't touch unless you know what you're doing!)
	Timer : timer.IntervalTimer?,
	
}

return Types

---

--- ReplicatedStorage.Modules.HitboxClass.Signal (ModuleScript) ---
-- -----------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- License:                                                                   --
--   Licensed under the MIT license.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--   sleitnick - August 3rd, 2021 - Modified for Knit.                        --
-- -----------------------------------------------------------------------------

-- Signal types
export type Connection = {
	Disconnect: (self: Connection) -> (),
	Destroy: (self: Connection) -> (),
	Connected: boolean,
}

export type Signal<T...> = {
	Fire: (self: Signal<T...>, T...) -> (),
	FireDeferred: (self: Signal<T...>, T...) -> (),
	Connect: (self: Signal<T...>, fn: (T...) -> ()) -> Connection,
	Once: (self: Signal<T...>, fn: (T...) -> ()) -> Connection,
	DisconnectAll: (self: Signal<T...>) -> (),
	GetConnections: (self: Signal<T...>) -> { Connection },
	Destroy: (self: Signal<T...>) -> (),
	Wait: (self: Signal<T...>) -> T...,
}

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread(...)
	acquireRunnerThreadAndCallEventHandler(...)
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

--[=[
	@within Signal
	@interface SignalConnection
	.Connected boolean
	.Disconnect (SignalConnection) -> ()

	Represents a connection to a signal.
	```lua
	local connection = signal:Connect(function() end)
	print(connection.Connected) --> true
	connection:Disconnect()
	print(connection.Connected) --> false
	```
]=]

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection:Disconnect()
	if not self.Connected then
		return
	end
	self.Connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end

Connection.Destroy = Connection.Disconnect

-- Make Connection strict
setmetatable(Connection, {
	__index = function(_tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

--[=[
	@within Signal
	@type ConnectionFn (...any) -> ()

	A function connected to a signal.
]=]

--[=[
	@class Signal

	A Signal is a data structure that allows events to be dispatched
	and observed.

	This implementation is a direct copy of the de facto standard, [GoodSignal](https://devforum.roblox.com/t/lua-signal-class-comparison-optimal-goodsignal-class/1387063),
	with some added methods and typings.

	For example:
	```lua
	local signal = Signal.new()

	-- Subscribe to a signal:
	signal:Connect(function(msg)
		print("Got message:", msg)
	end)

	-- Dispatch an event:
	signal:Fire("Hello world!")
	```
]=]
local Signal = {}
Signal.__index = Signal

--[=[
	Constructs a new Signal

	@return Signal
]=]
function Signal.new<T...>(): Signal<T...>
	local self = setmetatable({
		_handlerListHead = false,
		_proxyHandler = nil,
		_yieldedThreads = nil,
	}, Signal)

	return self
end

--[=[
	Constructs a new Signal that wraps around an RBXScriptSignal.

	@param rbxScriptSignal RBXScriptSignal -- Existing RBXScriptSignal to wrap
	@return Signal

	For example:
	```lua
	local signal = Signal.Wrap(workspace.ChildAdded)
	signal:Connect(function(part) print(part.Name .. " added") end)
	Instance.new("Part").Parent = workspace
	```
]=]
function Signal.Wrap<T...>(rbxScriptSignal: RBXScriptSignal): Signal<T...>
	assert(
		typeof(rbxScriptSignal) == "RBXScriptSignal",
		"Argument #1 to Signal.Wrap must be a RBXScriptSignal; got " .. typeof(rbxScriptSignal)
	)

	local signal = Signal.new()
	signal._proxyHandler = rbxScriptSignal:Connect(function(...)
		signal:Fire(...)
	end)

	return signal
end

--[=[
	Checks if the given object is a Signal.

	@param obj any -- Object to check
	@return boolean -- `true` if the object is a Signal.
]=]
function Signal.Is(obj: any): boolean
	return type(obj) == "table" and getmetatable(obj) == Signal
end

--[=[
	@param fn ConnectionFn
	@return SignalConnection

	Connects a function to the signal, which will be called anytime the signal is fired.
	```lua
	signal:Connect(function(msg, num)
		print(msg, num)
	end)

	signal:Fire("Hello", 25)
	```
]=]
function Signal:Connect(fn)
	local connection = setmetatable({
		Connected = true,
		_signal = self,
		_fn = fn,
		_next = false,
	}, Connection)

	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end

	return connection
end

--[=[
	@deprecated v1.3.0 -- Use `Signal:Once` instead.
	@param fn ConnectionFn
	@return SignalConnection
]=]
function Signal:ConnectOnce(fn)
	return self:Once(fn)
end

--[=[
	@param fn ConnectionFn
	@return SignalConnection

	Connects a function to the signal, which will be called the next time the signal fires. Once
	the connection is triggered, it will disconnect itself.
	```lua
	signal:Once(function(msg, num)
		print(msg, num)
	end)

	signal:Fire("Hello", 25)
	signal:Fire("This message will not go through", 10)
	```
]=]
function Signal:Once(fn)
	local connection
	local done = false

	connection = self:Connect(function(...)
		if done then
			return
		end

		done = true
		connection:Disconnect()
		fn(...)
	end)

	return connection
end

function Signal:GetConnections()
	local items = {}

	local item = self._handlerListHead
	while item do
		table.insert(items, item)
		item = item._next
	end

	return items
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
--[=[
	Disconnects all connections from the signal.
	```lua
	signal:DisconnectAll()
	```
]=]
function Signal:DisconnectAll()
	local item = self._handlerListHead
	while item do
		item.Connected = false
		item = item._next
	end
	self._handlerListHead = false

	local yieldedThreads = rawget(self, "_yieldedThreads")
	if yieldedThreads then
		for thread in yieldedThreads do
			if coroutine.status(thread) == "suspended" then
				warn(debug.traceback(thread, "signal disconnected; yielded thread cancelled", 2))
				task.cancel(thread)
			end
		end
		table.clear(self._yieldedThreads)
	end
end

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
--[=[
	@param ... any

	Fire the signal, which will call all of the connected functions with the given arguments.
	```lua
	signal:Fire("Hello")

	-- Any number of arguments can be fired:
	signal:Fire("Hello", 32, {Test = "Test"}, true)
	```
]=]
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item.Connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

--[=[
	@param ... any

	Same as `Fire`, but uses `task.defer` internally & doesn't take advantage of thread reuse.
	```lua
	signal:FireDeferred("Hello")
	```
]=]
function Signal:FireDeferred(...)
	local item = self._handlerListHead
	while item do
		local conn = item
		task.defer(function(...)
			if conn.Connected then
				conn._fn(...)
			end
		end, ...)
		item = item._next
	end
end

--[=[
	@return ... any
	@yields

	Yields the current thread until the signal is fired, and returns the arguments fired from the signal.
	Yielding the current thread is not always desirable. If the desire is to only capture the next event
	fired, using `Once` might be a better solution.
	```lua
	task.spawn(function()
		local msg, num = signal:Wait()
		print(msg, num) --> "Hello", 32
	end)
	signal:Fire("Hello", 32)
	```
]=]
function Signal:Wait()
	local yieldedThreads = rawget(self, "_yieldedThreads")
	if not yieldedThreads then
		yieldedThreads = {}
		rawset(self, "_yieldedThreads", yieldedThreads)
	end

	local thread = coroutine.running()
	yieldedThreads[thread] = true

	self:Once(function(...)
		yieldedThreads[thread] = nil
		task.spawn(thread, ...)
	end)

	return coroutine.yield()
end

--[=[
	Cleans up the signal.

	Technically, this is only necessary if the signal is created using
	`Signal.Wrap`. Connections should be properly GC'd once the signal
	is no longer referenced anywhere. However, it is still good practice
	to include ways to strictly clean up resources. Calling `Destroy`
	on a signal will also disconnect all connections immediately.
	```lua
	signal:Destroy()
	```
]=]
function Signal:Destroy()
	self:DisconnectAll()

	local proxyHandler = rawget(self, "_proxyHandler")
	if proxyHandler then
		proxyHandler:Disconnect()
	end
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(_tb, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

return table.freeze({
	new = Signal.new,
	Wrap = Signal.Wrap,
	Is = Signal.Is,
})

---

--- ReplicatedStorage.Modules.HitboxClass.Timer (ModuleScript) ---
--!strict

local RunService = game:GetService("RunService")
local Signal = require(script.Parent.Signal)

export type IntervalTimer = {
	
	-- fields
	TimeOut : number,
	TimeElapsed : number,
	Callback : (number) -> (),
	HeartbeatConnection :  RBXScriptConnection,
	Elapsed : Signal.Signal<>,
	
	-- methods
	new : (timeOut : number, callback : () -> ()) -> IntervalTimer,
	On : (self : IntervalTimer) -> (),
	Off : (self : IntervalTimer) -> (),
	Destroy : (self : IntervalTimer) -> (),
	
	-- private methods
	_Interval : (self : IntervalTimer, deltaTime : number) -> (),
}

local Timer = {}

-- this timer is only reliable on 0.1 timeout threshold or above
function Timer.new(TimeOut : number, Callback : () -> ())
	local self = (setmetatable({}, {__index = Timer}) :: unknown) :: IntervalTimer
	
	-- set up fields
	self.TimeOut = TimeOut
	self.Callback = Callback
	self.TimeElapsed = 0
	self.Elapsed = Signal.new()
	
	self.Elapsed:Connect(Callback)
	
	-- set up connection to heartbeat
	self.HeartbeatConnection = RunService.Heartbeat:Connect(function(DT)
		self:_Interval(DT)
	end)
	
	return self
end

function Timer._Interval(self : IntervalTimer, deltaTime : number)

	-- add the elapsed time to the timer
	self.TimeElapsed += deltaTime

	-- if there's something crazy going on and this hasn't been called in over 10 times the timeout threshold
	-- we want to reset the time elapsed field to prevent the timer from running the callback over 10 times in a row
	if self.TimeElapsed >= self.TimeOut * 10 then
		-- get the amount of timeouts skipped and then multiply by the timeout threshold
		-- subtract this from time elapsed
		self.TimeElapsed -= math.floor(self.TimeElapsed / self.TimeOut) * self.TimeOut

		return
	end

	-- if the elapsed time meets the threshold for the timeout
	-- then get rid of the elapsed time and run the callback
	if self.TimeElapsed >= self.TimeOut then
		self.TimeElapsed -= self.TimeOut
		self.Elapsed:Fire()
	end

end

function Timer.On(self : IntervalTimer)
	-- if connection exists and is connected, don't do anything
	if self.HeartbeatConnection and self.HeartbeatConnection.Connected then return end
	
	-- make a new connection to heartbeat
	self.HeartbeatConnection = RunService.Heartbeat:Connect(function(DT)
		self:_Interval(DT)
	end)
	
end

function Timer.Off(self : IntervalTimer)
	-- if there's not connection, don't do anything
	if not self.HeartbeatConnection then return end

	-- disconnect the connection
	self.HeartbeatConnection:Disconnect()
end

function Timer.Destroy(self : IntervalTimer)
	
	-- disconnect the connection
	self:Off()
	
	-- destroy the signal
	self.Elapsed:Destroy()
	
	-- clear self
	table.clear(self)
	
end

return Timer
---

--- ReplicatedStorage.Modules.Maid (ModuleScript) ---
--!strict
-- A class for managing the cleanup of events and other objects.

local Maid = {}
Maid.__index = Maid

function Maid.new()
	local self = setmetatable({}, Maid)
	self._tasks = {}
	return self
end

function Maid:GiveTask(task: RBXScriptConnection | Instance | (() -> ()))
	if not task then
		return
	end

	local index = #self._tasks + 1
	self._tasks[index] = task
	return index
end

function Maid:DoCleaning()
	for _, task in ipairs(self._tasks) do
		if typeof(task) == "function" then
			task()
		elseif typeof(task) == "RBXScriptConnection" then
			task:Disconnect()
		elseif typeof(task) == "Instance" then
			task:Destroy()
		end
	end
	table.clear(self._tasks)
end

function Maid:Destroy()
	self:DoCleaning()
	table.clear(self)
end

return Maid
---

--- ReplicatedStorage.Modules.ItemConfigurations (ModuleScript) ---
--[[
	ItemConfigurations Module
	
	Description: Contains all data for purchasable items in the BlocksShop,
	including their type, price, stock chance, and appearance.
	
	Location: ReplicatedStorage/Modules
]]
--!strict

local ItemConfigurations = {
	-- == BLOCKS ==
	WoodenFence = {
		DisplayName = "Wooden Fence",
		Type = "Blocks",
		Price = 50,
		ImageId = "rbxassetid://129846047182862",
		ProductID = 3433103620,
		Unlimited = false,
		Chance = 60,
		StockAmount = {Min = 1, Max = 5},
		Health = 50,
	},

	Crate = {
		DisplayName = "Crate",
		Type = "Blocks",
		Price = 250,
		ImageId = "rbxassetid://120065601385140",
		ProductID = 3433103879,
		Unlimited = false,
		Chance = 47,
		StockAmount = {Min = 1, Max = 5},
		Health = 75,
	},

	Barrel = {
		DisplayName = "Barrel",
		Type = "Blocks",
		Price = 950,
		ImageId = "rbxassetid://85433095978867",
		ProductID = 3433104247,
		Unlimited = false,
		Chance = 45,
		StockAmount = {Min = 1, Max = 5},
		Health = 120,
	},

	Sandbag = {
		DisplayName = "Sandbag",
		Type = "Blocks",
		Price = 2200,
		ImageId = "rbxassetid://95530712312968",
		ProductID = 3433104602,
		Unlimited = false,
		Chance = 36,
		StockAmount = {Min = 1, Max = 5},
		Health = 155,
	},

	SteelFence = {
		DisplayName = "Steel Fence",
		Type = "Blocks",
		Price = 4500,
		ImageId = "rbxassetid://125202399347349",
		ProductID = 3433105403,
		Unlimited = false,
		Chance = 34,
		StockAmount = {Min = 1, Max = 5},
		Health = 250,
	},

	Titanium = {
		DisplayName = "Titanium",
		Type = "Blocks",
		Price = 9000,
		ImageId = "rbxassetid://112393753455351",
		ProductID = 3433551311,
		Unlimited = false,
		Chance = 27,
		StockAmount = {Min = 1, Max = 4},
		Health = 700,
	},
	
	Cobblestone = {
		DisplayName = "Cobblestone",
		Type = "Blocks",
		Price = 1200,
		ImageId = "rbxassetid://87565106525483",
		ProductID = 3451485533,
		Unlimited = false,
		Chance = 43,
		StockAmount = {Min = 1, Max = 5},
		Health = 100,
	},
	
	Diamond = {
		DisplayName = "Diamond",
		Type = "Blocks",
		Price = 25000,
		ImageId = "rbxassetid://90412412707609",
		ProductID = 3451485298,
		Unlimited = false,
		Purchasable = false,           
		ShopHidden  = true,            
		Chance = 24,
		StockAmount = {Min = 1, Max = 3},
		Health = 1600,
	},
	
	WoodenSpike = {
		DisplayName = "WoodenSpike",
		Type = "Blocks",
		Price = 3500,
		ImageId = "rbxassetid://132026303434953",
		ProductID = 3451486230,
		Unlimited = false,
		Chance = 45,
		StockAmount = {Min = 1, Max = 5},
		Health = 80,
	},
	
	MetalSpike = {
		DisplayName = "MetalSpike",
		Type = "Blocks",
		Price = 6000,
		ImageId = "rbxassetid://125231362028631",
		ProductID = 3451485825,
		Unlimited = false,
		Chance = 38,
		StockAmount = {Min = 1, Max = 4},
		Health = 250,
	},
	
	ToxicSpike = {
		DisplayName = "ToxicSpike",
		Type = "Blocks",
		Price = 30000,
		ImageId = "rbxassetid://115198885487974",
		ProductID = 3451486014,
		Unlimited = false,
		Purchasable = false,           
		ShopHidden  = true, 
		Chance = 24,
		StockAmount = {Min = 1, Max = 3},
		Health = 550,
	},
	
	
	
	
	
	



	-- == TURRETS ==
	RevolverGuard = {
		DisplayName = "Revolver Cowboy",
		Type = "Turrets",
		Price = 200,
		ImageId = "rbxassetid://101587176998545",
		ProductID = 3433094679,
		Unlimited = false,
		Chance = 60,
		StockAmount = {Min = 2, Max = 4},
		Damage = 40,
		Range = 18,
		FireRate = 1.5, -- shots per second
		Health = 100, -- ## ADDED ##
	},

	DualRevolverGuard = {
		DisplayName = "Akimbo Cowboy",
		Type = "Turrets",
		Price = 750,
		ImageId = "rbxassetid://90537702528376",
		ProductID = 3433095524,
		Unlimited = false,
		Chance = 54,
		StockAmount = {Min = 1, Max = 3},
		Damage = 52,
		Range = 20,
		FireRate = 1.7, -- shots per second
		Health = 150, -- ## ADDED ##
	},

	SubmachineGunGuard = {
		DisplayName = "Uzi Cowboy",
		Type = "Turrets",
		Price = 3000,
		ImageId = "rbxassetid://85967954170361",
		ProductID = 3434416170,
		Unlimited = false,
		Chance = 45,
		StockAmount = {Min = 1, Max = 4},
		Damage = 23,
		Range = 24,
		FireRate = 4, -- shots per second
		Health = 150, -- ## ADDED ##
	},

	RifleGuard = {
		DisplayName = "Rifle Cowboy",
		Type = "Turrets",
		Price = 20000,
		ImageId = "rbxassetid://97972248199343",
		ProductID = 3433095916,
		Unlimited = false,
		Chance = 42,
		StockAmount = {Min = 1, Max = 3},
		Damage = 52,
		Range = 32,
		FireRate = 2.4, -- shots per second
		Health = 200, -- ## ADDED ##
	},

	ShotgunGuard = {
		DisplayName = "Shotgun Cowboy",
		Type = "Turrets",
		Price = 60000,
		ImageId = "rbxassetid://120607492947002",
		ProductID = 3433096316,
		Unlimited = false,
		Chance = 36,
		StockAmount = {Min = 1, Max = 3},
		Damage = 12,
		Range = 25,
		FireRate = 0.6, -- shots per second
		Health = 250, -- ## ADDED ##
	},


	GatlingGuard = {
		DisplayName = "Heavy Gunner",
		Type = "Turrets",
		Price = 120000,
		ImageId = "rbxassetid://100612332867121",
		ProductID = 3433096925,
		Unlimited = false,
		Chance = 30,
		StockAmount = {Min = 1, Max = 2},
		Damage = 20,
		Range = 40,
		FireRate = 5, -- shots per second
		Health = 300, -- ## ADDED ##
	},
	
	MortarGuard = {
		DisplayName = "MortarGuard",
		Type = "Turrets",
		Purchasable = false,
		ShopHidden = true,
		Price = nil,
		ProductID = nil,
		ImageId = "rbxassetid://97959863510956",

		Health = 300,
		Range = 80,
		MinRange = 18,
		Reload = 3.4,
		ProjectileSpeed = 90,
		SplashRadius = 15,
		Damage = 75,
		Spread = 1.5,
	},

}


-- Multipliers per tier (M1..M4)
local DAMAGE_MULT = { 1.10, 1.2, 1.3, 1.4 }
local HEALTH_MULT = { 1.10, 1.2, 1.3, 1.4 }

local MUTATION_IMAGES = {
	RevolverGuard = {
		[1] = "rbxassetid://132739787429109",
		[2] = "rbxassetid://128257399819685",
		[3] = "rbxassetid://72956303264604",
		[4] = "rbxassetid://97526334862988",
	},
	DualRevolverGuard = {
		[1] = "rbxassetid://85841518982837",
		[2] = "rbxassetid://119178152048750",
		[3] = "rbxassetid://76605895704232",
		[4] = "rbxassetid://110654873125512",
	},
	SubmachineGunGuard = {
		[1] = "rbxassetid://112682836269230",
		[2] = "rbxassetid://117726000125383",
		[3] = "rbxassetid://91758128710538",
		[4] = "rbxassetid://126017085127710",
	},
	RifleGuard = {
		[1] = "rbxassetid://116993191702178",
		[2] = "rbxassetid://132651447738530",
		[3] = "rbxassetid://111461787411888",
		[4] = "rbxassetid://74644215753266",
	},
	ShotgunGuard = {
		[1] = "rbxassetid://81501793595409",
		[2] = "rbxassetid://84050774573694",
		[3] = "rbxassetid://124834736686053",
		[4] = "rbxassetid://79931546514777",
	},
	GatlingGuard = {
		[1] = "rbxassetid://79150585476282",
		[2] = "rbxassetid://140395535147598",
		[3] = "rbxassetid://133302387592107",
		[4] = "rbxassetid://127328237788388",
	},
}


local function makeMutation(baseId: string, tier: number)
	local base = ItemConfigurations[baseId]
	if not base then
		warn("[ItemConfigurations] Missing base for mutation: ", baseId)
		return nil
	end

	local clone = table.clone(base)
	clone.DisplayName = (base.DisplayName or baseId)..("L%d"):format(tier)
	clone.Damage = math.floor((base.Damage or 0) * (DAMAGE_MULT[tier] or 1))
	clone.Health = math.floor((base.Health or 0) * (HEALTH_MULT[tier] or 1))
	clone.Purchasable = false   
	clone.ShopHidden  = true    
	clone.IsMutation  = true
	clone.BaseId      = baseId
	clone.Tier        = tier
	clone.ProductID   = nil     
	clone.Chance      = nil
	clone.StockAmount = nil
	clone.Unlimited   = nil

	local customImage = MUTATION_IMAGES[baseId] and MUTATION_IMAGES[baseId][tier]
	clone.ImageId = customImage or base.ImageId

	return clone
end


for _, baseId in ipairs({
	"RevolverGuard",
	"DualRevolverGuard",
	"SubmachineGunGuard",
	"RifleGuard",
	"ShotgunGuard",
	"GatlingGuard",
	}) do
	for tier = 1, 4 do
		local mid = ("%s_M%d"):format(baseId, tier)
		ItemConfigurations[mid] = makeMutation(baseId, tier)
	end
end

return ItemConfigurations

---

--- ReplicatedStorage.Modules.PlacementHandler (ModuleScript) ---
--!strict
-- Client placement handler with screen-anchored mobile HUD (âœ“ place, â†» rotate).
-- Desktop: click to place / R to rotate (unchanged).
-- Mobile: your Templates/MobileUi lives in PlayerGui and follows the ghost; we don't resize it.

--// Services
local UserInputService     = game:GetService("UserInputService")
local RunService           = game:GetService("RunService")
local ReplicatedStorage    = game:GetService("ReplicatedStorage")
local Workspace            = game:GetService("Workspace")
local CollectionService    = game:GetService("CollectionService")
local HttpService          = game:GetService("HttpService")
local ContextActionService = game:GetService("ContextActionService")
local Players              = game:GetService("Players")

local player    = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local mouse     = player:GetMouse()

--// Modules
local ItemConfigurations  = require(script.Parent:WaitForChild("ItemConfigurations"))
local NotificationManager = require(script.Parent:WaitForChild("NotificationManager"))
local FrameManager        = require(script.Parent:WaitForChild("FrameManager"))

--// Net
local EventsFolder     = ReplicatedStorage:WaitForChild("Events")
local FunctionsFolder  = ReplicatedStorage:WaitForChild("Functions")

local PlaceItemEvent        = EventsFolder:WaitForChild("PlaceItemEvent")
local RemoveItemEvent       = EventsFolder:WaitForChild("RemoveItemEvent")
local BlockInventoryUpdated = EventsFolder:WaitForChild("BlockInventoryUpdated")
local ItemPlacedFX          = EventsFolder:WaitForChild("ItemPlacedFX")
local ItemRemovedFX         = EventsFolder:WaitForChild("ItemRemovedFX")
local PlacementDenied       = EventsFolder:WaitForChild("PlacementDenied")
local GetBlockInventory     = FunctionsFolder:WaitForChild("GetBlockInventory")

--// Assets
local SoundsFolder = ReplicatedStorage:WaitForChild("Sounds")
local PlaceSound   = SoundsFolder:WaitForChild("PlaceSound")
local DeleteSound  = SoundsFolder:WaitForChild("DeleteSound")

local BLOCKS_MODELS  = ReplicatedStorage:WaitForChild("Blocks")
local TURRETS_MODELS = ReplicatedStorage:FindFirstChild("Turrets")

-- ====== CONFIG ======
local GRID_SIZE               = 4
local ROTATION_INCREMENT      = 90
local GHOST_ITEM_TRANSPARENCY = 0.7
local DELETE_HIGHLIGHT_TRANSPARENCY = 0.3
local HIDDEN_POSITION         = CFrame.new(0, -1000, 0)
local VALID_COLOR             = Color3.fromRGB(0, 255, 0)
local INVALID_COLOR           = Color3.fromRGB(255, 0, 0)
local GHOST_ITEM_TAG          = "ClientGhostItem"
local EPS                     = 0.05
local MAX_HEIGHT              = 4 -- must match server

-- Screen HUD settings (we DO NOT resize your UI)
local HUD_STUDS_OFFSET_Y = 6
local HUD_TEMPLATE_PATH = { "Templates", "MobileUi" } -- ReplicatedStorage/Templates/MobileUi

local function getTemplate(): Instance?
	local obj: Instance? = ReplicatedStorage
	for _, name in ipairs(HUD_TEMPLATE_PATH) do
		obj = obj and obj:FindFirstChild(name)
	end
	return obj
end
local HUD_TEMPLATE: Instance? = getTemplate() -- Frame with ConfirmButton & RotateButton

-- ====== State ======
local PlacementHandler = {}
local inventoryState = Instance.new("StringValue")
PlacementHandler.InventoryState = inventoryState

PlacementHandler.State = {
	isActive                      = false,
	isDeleteMode                  = false,
	ghostModel                    = nil :: Model?,
	currentItemId                 = nil :: string?,
	currentRotation               = 0,
	canPlace                      = false,
	playerPlot                    = nil :: Model?,
	highlightedItem               = nil :: { Model: Model, OriginalProperties: {[BasePart]: { Color: Color3, Transparency: number }} }?,
	currentInventory              = {} :: {[string]: number},
	originalRangePartTransparency = nil :: number?,
	selectionBox                  = nil :: SelectionBox?,
	highlightColor                = nil :: Color3?,
}

function PlacementHandler:GetInventory()
	return self.State.currentInventory
end

-- ====== Screen-anchored HUD (follows ghost)
local screenHud: ScreenGui?
local hudRoot: Frame?
local hudConns: { RBXScriptConnection } = {}
local followConn: RBXScriptConnection?

-- ====== Helpers ======
local function findMyPlot(): Model?
	for _, plot in ipairs(Workspace:WaitForChild("Plots"):GetChildren()) do
		if plot:IsA("Model") and plot:GetAttribute("OwnerId") == player.UserId then
			return plot
		end
	end
	return nil
end

local function getPlacementBox(model: Model): BasePart?
	local pb = model:FindFirstChild("PlacementBox")
	if pb and pb:IsA("BasePart") then
		return pb
	end
	return nil
end

local function isBlock(itemId: string): boolean
	local cfg = ItemConfigurations[itemId]
	return (cfg and cfg.Type == "Blocks") == true
end

local function isTurret(itemId: string): boolean
	local cfg = ItemConfigurations[itemId]
	return (cfg and cfg.Type == "Turrets") == true
end

local function unbindLegacyReload()
	for _, name in ipairs({ "Reload", "GunReload", "Gun_Reload", "ReloadAction" }) do
		ContextActionService:UnbindAction(name)
	end
end

local function isTypingInTextBox(): boolean
	return UserInputService:GetFocusedTextBox() ~= nil
end

local function applyGhostRotation(ghost: Model, deg: number)
	if not (ghost and ghost.PrimaryPart) then return end
	local pp = ghost.PrimaryPart
	local pos = pp.CFrame.Position
	local yAngle = math.rad(deg)
	local newCF = CFrame.new(pos) * CFrame.Angles(0, yAngle, 0)
	ghost:PivotTo(newCF)
end

local function getFootprintXZ(pb: BasePart, rotationDeg: number): (number, number)
	local rx = pb.Size.X
	local rz = pb.Size.Z
	local rot = ((rotationDeg % 360) + 360) % 360
	if rot == 90 or rot == 270 then
		return rz, rx
	end
	return rx, rz
end

-- ====== Screen HUD build/destroy ======
local function disconnectHud()
	for _, c in ipairs(hudConns) do
		pcall(function() c:Disconnect() end)
	end
	table.clear(hudConns)
	if followConn then
		pcall(function() followConn:Disconnect() end)
		followConn = nil
	end
end

local function destroyHud()
	disconnectHud()
	if screenHud then
		screenHud:Destroy()
		screenHud = nil
		hudRoot = nil
	end
end

local function buildScreenHud(adorneePart: BasePart)
	destroyHud()
	if not UserInputService.TouchEnabled then return end

	screenHud = Instance.new("ScreenGui")
	screenHud.Name = "PlacementScreenHUD"
	screenHud.ResetOnSpawn = false
	screenHud.IgnoreGuiInset = false
	screenHud.Parent = playerGui

	assert(HUD_TEMPLATE and HUD_TEMPLATE:IsA("Frame"), "[PlacementHandler] Templates/MobileUi not found or not a Frame")
	hudRoot = (HUD_TEMPLATE :: Frame):Clone()
	hudRoot.Name = "MobileUi"
	hudRoot.AnchorPoint = Vector2.new(0.5, 0.5) -- center
	hudRoot.Parent = screenHud

	local confirmBtn = hudRoot:FindFirstChild("ConfirmButton", true) :: GuiButton?
	local rotateBtn  = hudRoot:FindFirstChild("RotateButton",  true) :: GuiButton?

	if confirmBtn then
		table.insert(hudConns, confirmBtn.Activated:Connect(function()
			local S = PlacementHandler.State
			if S.isActive and not S.isDeleteMode then
				if S.canPlace and S.ghostModel and S.currentItemId then
					PlaceItemEvent:FireServer(S.currentItemId, S.ghostModel:GetPrimaryPartCFrame(), S.playerPlot)
				else
					NotificationManager.show("Not enough space!", "Error")
				end
			end
		end))
	end

	if rotateBtn then
		table.insert(hudConns, rotateBtn.Activated:Connect(function()
			local S = PlacementHandler.State
			if S.isActive and not S.isDeleteMode then
				S.currentRotation = (S.currentRotation + ROTATION_INCREMENT) % 360
				if S.ghostModel then
					applyGhostRotation(S.ghostModel, S.currentRotation)
					task.defer(function() PlacementHandler:_UpdatePlacementPreview() end)
				end
			end
		end))
	end

	-- Follow the ghost in screen space
	local cam = Workspace.CurrentCamera
	followConn = RunService.RenderStepped:Connect(function()
		if not (cam and hudRoot and adorneePart and adorneePart.Parent) then return end
		local worldPos = adorneePart.Position + Vector3.new(0, HUD_STUDS_OFFSET_Y, 0)
		local v3, onScreen = cam:WorldToViewportPoint(worldPos)
		hudRoot.Visible = onScreen and v3.Z > 0
		if not hudRoot.Visible then return end
		hudRoot.Position = UDim2.fromOffset(v3.X, v3.Y)
	end)
end

-- ====== Core actions ======
local function _PlaceCurrentItem()
	local S = PlacementHandler.State
	if not S.isActive or S.isDeleteMode then return end
	if not S.canPlace then
		NotificationManager.show("Not enough space!", "Error")
		return
	end

	local currentItemId = S.currentItemId
	if currentItemId then
		local ownedCount = S.currentInventory[currentItemId] or 0
		if ownedCount <= 0 then
			NotificationManager.show("Not enough stock!", "Error")
			FrameManager.open("Inventory")
			PlacementHandler:ExitAllModes()
			return
		end
	end

	if S.ghostModel and currentItemId then
		PlaceItemEvent:FireServer(currentItemId, S.ghostModel:GetPrimaryPartCFrame(), S.playerPlot)
	end
end

local function _deleteModel(model: Model?)
	if not model then return end
	RemoveItemEvent:FireServer(model)
end

local function _topPlacedModelUnderPart(part: BasePart?, plot: Model?): Model?
	if not (part and plot) then return nil end
	local a: Instance? = part
	while a and a.Parent ~= plot do
		a = a.Parent
	end
	if a and (a :: Instance):GetAttribute("IsPlacedItem") then
		return a :: Model
	end
	return nil
end

local function _deleteAtScreenPoint(pos: Vector2)
	local S = PlacementHandler.State
	if not S.playerPlot then return end
	local camera = Workspace.CurrentCamera
	if not camera then return end

	for _, gui in ipairs(playerGui:GetGuiObjectsAtPosition(pos.X, pos.Y)) do
		if gui:IsA("GuiButton") then
			return
		end
	end

	local ray = camera:ScreenPointToRay(pos.X, pos.Y)
	local rp = RaycastParams.new()
	rp.FilterType = Enum.RaycastFilterType.Whitelist
	rp.FilterDescendantsInstances = { S.playerPlot }

	local res = Workspace:Raycast(ray.Origin, ray.Direction * 1000, rp)
	if not res then return end

	local model = _topPlacedModelUnderPart(res.Instance, S.playerPlot)
	if model then
		_deleteModel(model)
	end
end

-- ====== Placement Preview (raycast, under-fill & stacking rules) ======
local function countBlocksInColumn(plot: Model, xz: Vector3, footprint: Vector3): (number, Model?, BasePart?, boolean, boolean)
	local blocksCount = 0
	local topModel: Model? = nil
	local topPB: BasePart? = nil
	local topIsBlock = false
	local topIsTurret = false
	local bestTopY = -math.huge

	for _, ch in ipairs(plot:GetChildren()) do
		if not CollectionService:HasTag(ch, "PlacedItem") then
			continue
		end
		local pb = getPlacementBox(ch)
		if not pb then
			continue
		end

		local dx = math.abs(pb.Position.X - xz.X)
		local dz = math.abs(pb.Position.Z - xz.Z)
		local fitsXZ = (dx <= math.max(pb.Size.X, footprint.X)/2 + EPS)
			and (dz <= math.max(pb.Size.Z, footprint.Z)/2 + EPS)

		if fitsXZ then
			local cfg = ItemConfigurations[ch.Name]
			if cfg and cfg.Type == "Blocks" then
				blocksCount += 1
			end
			local topY = pb.Position.Y + pb.Size.Y/2
			if topY > bestTopY then
				bestTopY = topY
				topModel = ch
				topPB = pb
				topIsBlock = (cfg and cfg.Type == "Blocks") == true
				topIsTurret = (cfg and cfg.Type == "Turrets") == true
			end
		end
	end

	return blocksCount, topModel, topPB, topIsBlock, topIsTurret
end

function PlacementHandler:_UpdatePlacementPreview()
	-- ignore when over UI buttons
	local guiObjects = playerGui:GetGuiObjectsAtPosition(mouse.X, mouse.Y)
	for _, object in ipairs(guiObjects) do
		if object:IsA("GuiButton") then
			return
		end
	end

	local S = self.State
	if not (S.ghostModel and S.ghostModel.PrimaryPart) then return end

	-- Ensure plot reference
	if not S.playerPlot then
		S.playerPlot = findMyPlot()
		if not S.playerPlot then return end
	elseif not S.playerPlot.Parent then
		S.playerPlot = nil
		return
	end

	local plotBase = S.playerPlot:FindFirstChild("Base")
	if not plotBase then return end

	local camera = Workspace.CurrentCamera
	if not camera then return end

	-- 1) Raycast to plot
	local rcParams = RaycastParams.new()
	rcParams.FilterType = Enum.RaycastFilterType.Whitelist
	rcParams.FilterDescendantsInstances = { S.playerPlot }

	local ray = camera:ScreenPointToRay(mouse.X, mouse.Y)
	local result = Workspace:Raycast(ray.Origin, ray.Direction * 1000, rcParams)

	local worldHitPos: Vector3
	if result then
		worldHitPos = result.Position
	else
		-- fallback: plane projection onto base
		local planeN = plotBase.CFrame.UpVector
		local denom = ray.Direction:Dot(planeN)
		if math.abs(denom) < 1e-4 then
			S.ghostModel:PivotTo(HIDDEN_POSITION)
			S.canPlace = false
			return
		end
		local t = (plotBase.Position - ray.Origin):Dot(planeN) / denom
		if t < 0 then
			S.ghostModel:PivotTo(HIDDEN_POSITION)
			S.canPlace = false
			return
		end
		worldHitPos = ray.Origin + ray.Direction * t
	end

	-- 2) Snap X/Z to grid (rotation-aware footprint)
	local plotLocal = plotBase.CFrame:ToObjectSpace(CFrame.new(worldHitPos))
	local halfPlotSize = plotBase.Size / 2

	local pb = getPlacementBox(S.ghostModel)
	if not pb then return end
	local boxX, boxZ = getFootprintXZ(pb, S.currentRotation)
	local boxSize = Vector3.new(boxX, pb.Size.Y, boxZ)

	local shiftedX = plotLocal.X + halfPlotSize.X
	local snappedCornerX = math.floor(shiftedX / GRID_SIZE) * GRID_SIZE
	local x = (snappedCornerX + boxSize.X / 2) - halfPlotSize.X

	local shiftedZ = plotLocal.Z + halfPlotSize.Z
	local snappedCornerZ = math.floor(shiftedZ / GRID_SIZE) * GRID_SIZE
	local z = (snappedCornerZ + boxSize.Z / 2) - halfPlotSize.Z

	-- Clamp inside plot
	local halfBoxSize = boxSize / 2
	x = math.clamp(x, -halfPlotSize.X + halfBoxSize.X, halfPlotSize.X - halfBoxSize.X)
	z = math.clamp(z, -halfPlotSize.Z + halfBoxSize.Z, halfPlotSize.Z - halfBoxSize.Z)

	-- 3) Choose support at/under aimed height (under-fill)
	local colCenterWorld = plotBase.CFrame * Vector3.new(x, 0, z)
	local aimY = worldHitPos.Y

	local chosenSupportTopY = plotBase.Position.Y + plotBase.Size.Y/2
	local chosenSupportModel: Model? = nil
	local chosenSupportIsTurret = false
	local bestTopY = -math.huge

	for _, ch in ipairs(S.playerPlot:GetChildren()) do
		if not CollectionService:HasTag(ch, "PlacedItem") then
			continue
		end
		local spb = ch:FindFirstChild("PlacementBox")
		if not (spb and spb:IsA("BasePart")) then
			continue
		end

		local dx = math.abs(spb.Position.X - colCenterWorld.X)
		local dz = math.abs(spb.Position.Z - colCenterWorld.Z)
		local fitsXZ = (dx <= math.max(spb.Size.X, boxSize.X)/2 + EPS)
			and (dz <= math.max(spb.Size.Z, boxSize.Z)/2 + EPS)
		if not fitsXZ then
			continue
		end

		local topY = spb.Position.Y + spb.Size.Y/2
		if topY <= (aimY + EPS) and topY > bestTopY then
			bestTopY = topY
			chosenSupportTopY = topY
			chosenSupportModel = ch
			local cfg = ItemConfigurations[ch.Name]
			chosenSupportIsTurret = (cfg and cfg.Type == "Turrets") == true
		end
	end

	-- 4) Set ghost on top of chosen support (base if none matched)
	local ghost = S.ghostModel
	local ghostHalfY = ghost.PrimaryPart.Size.Y/2
	local finalCF = CFrame.new(colCenterWorld.X, chosenSupportTopY + ghostHalfY, colCenterWorld.Z)
	finalCF *= CFrame.Angles(0, math.rad(S.currentRotation), 0)
	ghost:PivotTo(finalCF)

	-- 5) Client overlap probe (hint only)
	local isOverlapping = false
	local overlapParams = OverlapParams.new()
	overlapParams.FilterDescendantsInstances = { S.ghostModel }

	local parts = Workspace:GetPartsInPart(getPlacementBox(S.ghostModel) :: BasePart, overlapParams)
	for _, part in ipairs(parts) do
		local m = part:FindFirstAncestorOfClass("Model")
		if (m and m:GetAttribute("IsPlacedItem")) or part.Name == "PlotHealth" then
			isOverlapping = true
			break
		end
	end

	-- 6) Count total blocks in column for height cap
	local blocksCount = 0
	for _, ch in ipairs(S.playerPlot:GetChildren()) do
		if not CollectionService:HasTag(ch, "PlacedItem") then
			continue
		end
		local spb = ch:FindFirstChild("PlacementBox")
		if not (spb and spb:IsA("BasePart")) then
			continue
		end
		local dx = math.abs(spb.Position.X - colCenterWorld.X)
		local dz = math.abs(spb.Position.Z - colCenterWorld.Z)
		local fitsXZ = (dx <= math.max(spb.Size.X, boxSize.X)/2 + EPS)
			and (dz <= math.max(spb.Size.Z, boxSize.Z)/2 + EPS)
		if fitsXZ then
			local cfg = ItemConfigurations[ch.Name]
			if cfg and cfg.Type == "Blocks" then
				blocksCount += 1
			end
		end
	end

	-- 7) Rule checks
	local itemId = S.currentItemId or ""
	local placingBlock = isBlock(itemId)
	local placingTurret = isTurret(itemId)

	local ruleOk = true
	if placingTurret then
		ruleOk = (chosenSupportModel == nil) or not chosenSupportIsTurret
	elseif placingBlock then
		if chosenSupportIsTurret then
			ruleOk = false
		else
			ruleOk = (blocksCount + 1) <= MAX_HEIGHT
		end
	end

	S.canPlace = ruleOk and (not isOverlapping)

	-- 8) SelectionBox feedback
	if not S.selectionBox then
		S.selectionBox = Instance.new("SelectionBox")
		S.selectionBox.LineThickness = 0.2
		S.selectionBox.SurfaceColor3 = VALID_COLOR
		S.selectionBox.Color3 = VALID_COLOR
		S.selectionBox.Transparency = 0
		S.selectionBox.Adornee = pb
		S.selectionBox.Parent = pb
		S.highlightColor = VALID_COLOR
	end

	local targetColor = S.canPlace and VALID_COLOR or INVALID_COLOR
	if S.highlightColor ~= targetColor then
		S.selectionBox.Color3 = targetColor
		S.highlightColor = targetColor
	end
end

function PlacementHandler:_UpdateDeleteHighlight()
	-- Desktop hover highlight only; on mobile we delete by tap ray.
	local guiObjects = playerGui:GetGuiObjectsAtPosition(mouse.X, mouse.Y)
	for _, object in ipairs(guiObjects) do
		if object:IsA("GuiButton") then
			return
		end
	end

	local S = self.State
	local targetPart = mouse.Target
	local topLevelModel: Model? = nil

	if targetPart and S.playerPlot then
		topLevelModel = _topPlacedModelUnderPart(targetPart, S.playerPlot)
	end

	if S.highlightedItem and S.highlightedItem.Model ~= topLevelModel then
		for part, originalProperties in pairs(S.highlightedItem.OriginalProperties) do
			if part and part.Parent then
				part.Color = originalProperties.Color
				part.Transparency = originalProperties.Transparency
			end
		end
		if S.selectionBox then
			S.selectionBox:Destroy()
			S.selectionBox = nil
		end
		S.highlightedItem = nil
	end

	if topLevelModel and not S.highlightedItem then
		local originalProperties: {[BasePart]: { Color: Color3, Transparency: number }} = {}
		local placementBox = topLevelModel:FindFirstChild("PlacementBox")
		for _, part in ipairs(topLevelModel:GetDescendants()) do
			if part:IsA("BasePart") then
				originalProperties[part] = { Color = part.Color, Transparency = part.Transparency }
				part.Color = INVALID_COLOR
				if part.Name == "PlacementBox" then
					part.Transparency = 1
				else
					part.Transparency = DELETE_HIGHLIGHT_TRANSPARENCY
				end
			end
		end
		PlacementHandler.State.highlightedItem = { Model = topLevelModel, OriginalProperties = originalProperties }
		if placementBox and not S.selectionBox then
			S.selectionBox = Instance.new("SelectionBox")
			S.selectionBox.LineThickness = 0.2
			S.selectionBox.Color3 = INVALID_COLOR
			S.selectionBox.Transparency = 0
			S.selectionBox.Adornee = placementBox
			S.selectionBox.Parent = placementBox
			S.highlightColor = INVALID_COLOR
		end
	end

	if not topLevelModel and S.selectionBox then
		S.selectionBox:Destroy()
		S.selectionBox = nil
	end
end

function PlacementHandler:_Update()
	local S = self.State
	if not S.isActive then return end

	if S.playerPlot and not S.playerPlot.Parent then
		S.playerPlot = nil
	end
	if not S.playerPlot then
		S.playerPlot = findMyPlot()
		if not S.playerPlot then return end
	end

	if S.isDeleteMode then
		self:_UpdateDeleteHighlight()
	else
		self:_UpdatePlacementPreview()
	end

	-- Optional UX: dim your confirm image when invalid placement
	if hudRoot and S.isActive and not S.isDeleteMode then
		local confirm = hudRoot:FindFirstChild("ConfirmButton", true)
		if confirm and confirm:IsA("GuiButton") then
			(confirm :: GuiButton).AutoButtonColor = S.canPlace
			local confirmImage = (confirm :: GuiButton):FindFirstChild("ConfirmImage", true)
			if confirmImage and (confirmImage:IsA("ImageLabel") or confirmImage:IsA("ImageButton")) then
				(confirmImage :: any).ImageTransparency = S.canPlace and 0 or 0.4
			end
		end
	end
end

-- ====== Input (desktop); mobile uses screen HUD ======
function PlacementHandler:_HandleInput(input: InputObject, gameProcessed: boolean)
	local S = self.State

	-- PC: R to rotate (reliable)
	if not UserInputService.TouchEnabled
		and input.KeyCode == Enum.KeyCode.R
		and input.UserInputState == Enum.UserInputState.Begin
		and not isTypingInTextBox()
		and S.isActive and not S.isDeleteMode
	then
		S.currentRotation = (S.currentRotation + ROTATION_INCREMENT) % 360
		if S.ghostModel then
			applyGhostRotation(S.ghostModel, S.currentRotation)
			task.defer(function() self:_UpdatePlacementPreview() end)
		end
		return
	end

	if gameProcessed then return end

	if S.isDeleteMode then
		if input.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputState == Enum.UserInputState.Begin then
			if not UserInputService.TouchEnabled then
				if S.highlightedItem and S.highlightedItem.Model then
					_deleteModel(S.highlightedItem.Model)
				else
					local model = _topPlacedModelUnderPart(mouse.Target, S.playerPlot)
					_deleteModel(model)
				end
			end
		elseif input.KeyCode == Enum.KeyCode.Q and input.UserInputState == Enum.UserInputState.Begin then
			self:ExitAllModes()
		end
	else
		if input.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputState == Enum.UserInputState.Begin then
			if not UserInputService.TouchEnabled then
				_PlaceCurrentItem()
			end
		elseif input.KeyCode == Enum.KeyCode.Q and input.UserInputState == Enum.UserInputState.Begin then
			self:ExitAllModes()
		end
	end
end

-- ====== Touch handling (MOBILE) â€“ rely on screen HUD; keep tap-to-delete only ======
local touchTapConn: RBXScriptConnection?

local function refreshTouchTapConn()
	if touchTapConn then
		touchTapConn:Disconnect()
		touchTapConn = nil
	end
	if not UserInputService.TouchEnabled then return end
	local S = PlacementHandler.State
	touchTapConn = UserInputService.TouchTap:Connect(function(positions)
		if not S.isActive then return end
		local pt = positions[1]
		if not pt then return end

		-- Let GUI consume taps
		for _, o in ipairs(playerGui:GetGuiObjectsAtPosition(pt.X, pt.Y)) do
			if o:IsA("GuiButton") then return end
		end

		if S.isDeleteMode then
			_deleteAtScreenPoint(pt)
		else
			-- With screen HUD, do NOT place on world tap; use âœ“
		end
	end)
end

-- ====== Mode switches ======
function PlacementHandler:ExitAllModes()
	local S = self.State
	S.isActive = false
	S.isDeleteMode = false

	if S.ghostModel then
		local rangePart = S.ghostModel:FindFirstChild("RangePart")
		if rangePart and rangePart:IsA("BasePart") then
			rangePart.Transparency = S.originalRangePartTransparency or 1
		end
		S.ghostModel:Destroy()
		S.ghostModel = nil
	end

	if S.selectionBox then
		S.selectionBox:Destroy()
		S.selectionBox = nil
	end

	if S.highlightedItem then
		for part, originalProperties in pairs(S.highlightedItem.OriginalProperties) do
			if part and part.Parent then
				part.Color = originalProperties.Color
				part.Transparency = originalProperties.Transparency
			end
		end
		S.highlightedItem = nil
	end

	S.currentItemId = nil
	S.currentRotation = 0
	S.originalRangePartTransparency = nil
	S.highlightColor = nil

	-- Clean mobile HUD
	destroyHud()
	refreshTouchTapConn()
end

function PlacementHandler:EnterPlacementMode(itemId: string)
	self:ExitAllModes()

	local template = BLOCKS_MODELS:FindFirstChild(itemId) or (TURRETS_MODELS and TURRETS_MODELS:FindFirstChild(itemId))
	if not (template and template.PrimaryPart) then return end

	local ghost = template:Clone()
	CollectionService:AddTag(ghost, GHOST_ITEM_TAG)

	-- Anchor ALL parts, disable collisions, make visible (except PlacementBox).
	for _, part in ipairs(ghost:GetDescendants()) do
		if part:IsA("BasePart") then
			part.Anchored = true
			part.CanCollide = false
			if part.Name ~= "PlacementBox" then
				part.Transparency = GHOST_ITEM_TRANSPARENCY
			else
				part.Transparency = 1
			end
		end
	end

	local itemConfig = ItemConfigurations[itemId]
	if itemConfig and itemConfig.Type == "Turrets" then
		local rangePart = ghost:FindFirstChild("RangePart")
		if rangePart and rangePart:IsA("BasePart") and itemConfig.Range then
			local radius = itemConfig.Range
			local diameter = radius * 2
			self.State.originalRangePartTransparency = rangePart.Transparency
			rangePart.Size = Vector3.new(0.25, diameter, diameter)
			rangePart.Transparency = GHOST_ITEM_TRANSPARENCY
			rangePart.CanCollide = false
			rangePart.Anchored = true
		end
	end

	self.State.ghostModel = ghost
	self.State.currentItemId = itemId
	self.State.isActive = true
	self.State.isDeleteMode = false
	ghost.Parent = Workspace

	applyGhostRotation(ghost, self.State.currentRotation)

	-- Mobile: screen HUD follows the ghost
	if UserInputService.TouchEnabled then
		local adornee = ghost.PrimaryPart or ghost:FindFirstChildWhichIsA("BasePart")
		if adornee then
			buildScreenHud(adornee)
		end
	end

	refreshTouchTapConn()
end

function PlacementHandler:EnterDeleteMode()
	self:ExitAllModes()
	self.State.isActive = true
	self.State.isDeleteMode = true
	-- No HUD in delete mode
	refreshTouchTapConn()
end

-- ====== Loop / Signals ======
function PlacementHandler:Init()
	unbindLegacyReload()

	RunService.Heartbeat:Connect(function()
		self:_Update()
	end)

	UserInputService.InputBegan:Connect(function(i: InputObject, gp: boolean)
		self:_HandleInput(i, gp)
	end)

	ItemPlacedFX.OnClientEvent:Connect(function()
		PlaceSound:Play()
	end)
	ItemRemovedFX.OnClientEvent:Connect(function()
		DeleteSound:Play()
	end)

	PlacementDenied.OnClientEvent:Connect(function(msg: string)
		NotificationManager.show(msg, "Error")
	end)

	BlockInventoryUpdated.OnClientEvent:Connect(function(newInventory: {[string]: number})
		self.State.currentInventory = newInventory
		inventoryState.Value = HttpService:JSONEncode(newInventory)
		if self.State.isActive and (not self.State.isDeleteMode) and self.State.currentItemId then
			if (self.State.currentInventory[self.State.currentItemId] or 0) <= 0 then
				self:ExitAllModes()
				FrameManager.open("Inventory")
			end
		end
	end)

	local ok, initialInventory = pcall(function()
		return GetBlockInventory:InvokeServer()
	end)
	if ok and initialInventory then
		self.State.currentInventory = initialInventory
		inventoryState.Value = HttpService:JSONEncode(initialInventory)
	else
		warn("[PlacementHandler] Failed to get initial inventory:", tostring(initialInventory))
	end

	refreshTouchTapConn()
end

return PlacementHandler

---

--- ReplicatedStorage.Modules.WaveConfigurations (ModuleScript) ---
--!strict
export type Group = { Enemy: string, Count: number, DelayBetweenSpawns: number }
export type WaveConfig = {
	CashReward: number?,
	Enemies: { Group },
	IsBossWave: boolean,
	BossImageId: string?,
	HealthMultiplier: number?,
	KillCashMultiplier: number?,
	DamageMultiplier: number?,
	SpawnDelayMultiplier: number?,
}

-- ========= BASICS =========
local MAX_WAVES = 1000
local STEP = 15
local GUARANTEED_BOSS_EVERY = 15
local EXTRA_BOSS_CHANCE = 0.08

local EXTENSION = {
	baseCountMultPerSegment = 1.06,
	perWaveCountMultPerSegment = 1.01,
	perWaveHealthMultPerSegment = 1.01,
	perWaveSpawnRateMultPerSegment = 1.01,
	baseDelayMultPerSegment = 0.98,
}

-- ========= BOSSES =========
type BossDef = {
	Name: string,
	DefaultOdds: number,
	ImageId: string?,
	HealthMultiplier: number?,
	KillCashMultiplier: number?,
	DamageMultiplier: number?,
	EnemiesOverride: { Group }?,
}
local Bosses: { BossDef } = {
	{
		Name = "Drooling Zombie",
		DefaultOdds = 0.50,
		ImageId = "rbxassetid://111610396402545",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},
	
	{
		Name = "Ghost Rider",
		DefaultOdds = 0.60,
		ImageId = "rbxassetid://122442057337109",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Noob Boss",
		DefaultOdds = 0.70,
		ImageId = "rbxassetid://130140534739954",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Jandel Boss",
		DefaultOdds = 0.55,
		ImageId = "rbxassetid://135733218169449",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Shedletsky Boss",
		DefaultOdds = 0.70,
		ImageId = "rbxassetid://126735198756079",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Zombie Boss",
		DefaultOdds = 0.70,
		ImageId = "rbxassetid://116373301567241",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Void Boss",
		DefaultOdds = 0.30,
		ImageId = "rbxassetid://115344938798030",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Bacon Boss",
		DefaultOdds = 0.67,
		ImageId = "rbxassetid://94458678326774",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Pumpkin Alien",
		DefaultOdds = 0.67,
		ImageId = "rbxassetid://94458678326774",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Pumpkin Alien",
		DefaultOdds = 0.67,
		ImageId = "rbxassetid://100993286322952",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Pumpkin Reaper",
		DefaultOdds = 0.67,
		ImageId = "rbxassetid://97691854894317",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},
}

-- ========= SEGMENTS (after 15) =========
type Segment = {
	enemyWeights: { [string]: number },
	bossWeights: { [string]: number }?,
	baseCount: number?,
	perWaveCountMult: number?,
	perWaveHealthMult: number?,
	perWaveSpawnRateMult: number?,
	baseDelay: number?,
}
local Segments: { Segment } = {
	-- 16â€“30
	{
		enemyWeights = {
			["Normal Zombie"] = 0.35,
			["Ghost Zombie"]  = 0.30,
			["Ice Zombie"]    = 0.25,
			["Fire Zombie"]   = 0.10,
			["Skeleton"]   = 0.30,
			["Angry Miner"]   = 0.24,
			["Half Skeletal"]   = 0.10,
			["Explosive Boy"]   = 0.10,
			["RogueCowboy"]   = 0.15,
			["SkullHead"]   = 0.10,
		},
		baseCount = 24,
		perWaveCountMult = 1.03,
		perWaveHealthMult = 1.02,
		perWaveSpawnRateMult = 1.02,
		baseDelay = 1.2,
	},
	-- 31â€“45
	{
		enemyWeights = {
			["Normal Zombie"] = 0.30,
			["Ghost Zombie"]  = 0.20,
			["Ice Zombie"]    = 0.20,
			["Fire Zombie"]   = 0.30,
			["Skeleton"]   = 0.30,
			["Angry Miner"]   = 0.30,
			["Half Skeletal"]   = 0.20,
			["Explosive Boy"]   = 0.15,
			["RogueCowboy"]   = 0.20,
			["SkullHead"]   = 0.20,
			["Looter Caravan"] = 0.15,
			["Alien Bandit"] = 0.10,
			["Rider Villain"] = 0.15,
			["Ghost Cowboy"] = 0.15,
		},
		baseCount = 26,
		perWaveCountMult = 1.035,
		perWaveHealthMult = 1.022,
		perWaveSpawnRateMult = 1.022,
		baseDelay = 1.15,
	},
	-- 46â€“60+ (odds repeat; knobs ramp every extra segment)
	{
		enemyWeights = {
			["Normal Zombie"] = 0.30,
			["Ghost Zombie"]  = 0.25,
			["Ice Zombie"]    = 0.25,
			["Fire Zombie"]   = 0.20,
			["Skeleton"]   = 0.30,
			["Angry Miner"]   = 0.30,
			["Half Skeletal"]   = 0.25,
			["Explosive Boy"]   = 0.25,
			["RogueCowboy"]   = 0.30,
			["SkullHead"]   = 0.30,
			["Looter Caravan"] = 0.25,
			["Alien Bandit"] = 0.20,
			["Rider Villain"] = 0.20,
			["Ghost Cowboy"] = 0.20,
		},
		baseCount = 28,
		perWaveCountMult = 1.04,
		perWaveHealthMult = 1.025,
		perWaveSpawnRateMult = 1.022,
		baseDelay = 1.10,
	},
}

-- ========= HARDCODED 1â€“15 =========
local WaveConfigurations: { [number]: WaveConfig } = {
	[1]  = { CashReward=25,  IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=3, DelayBetweenSpawns=1.4}} },
	[2]  = { CashReward=40,  IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=5, DelayBetweenSpawns=1.4}} },
	[3]  = { CashReward=55,  IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=6, DelayBetweenSpawns=1.3},{Enemy="Ghost Zombie", Count=2, DelayBetweenSpawns=1.3}} },
	[4]  = { CashReward=70,  IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=8, DelayBetweenSpawns=1.3},{Enemy="Ghost Zombie", Count=2, DelayBetweenSpawns=1.3}} },
	[5]  = { CashReward=90,  IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=8, DelayBetweenSpawns=1.2},{Enemy="Ghost Zombie", Count=3, DelayBetweenSpawns=1.2},{Enemy="Ice Zombie", Count=1, DelayBetweenSpawns=1.2}} },
	[6]  = { CashReward=110, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=10,DelayBetweenSpawns=1.2},{Enemy="Ghost Zombie", Count=3, DelayBetweenSpawns=1.2},{Enemy="Ice Zombie", Count=2, DelayBetweenSpawns=1.2}} },
	[7]  = { CashReward=130, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=12,DelayBetweenSpawns=1.2},{Enemy="Ghost Zombie", Count=4, DelayBetweenSpawns=1.2},{Enemy="Ice Zombie", Count=2, DelayBetweenSpawns=1.2}} },
	[8]  = { CashReward=150, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=14,DelayBetweenSpawns=1.2},{Enemy="Ghost Zombie", Count=5, DelayBetweenSpawns=1.2},{Enemy="Ice Zombie", Count=3, DelayBetweenSpawns=1.2}} },
	[9]  = { CashReward=170, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=16,DelayBetweenSpawns=1.1},{Enemy="Ghost Zombie", Count=6, DelayBetweenSpawns=1.1},{Enemy="Ice Zombie", Count=3, DelayBetweenSpawns=1.1}} },
	[10] = { CashReward=190, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=18,DelayBetweenSpawns=1.1},{Enemy="Ghost Zombie", Count=7, DelayBetweenSpawns=1.1},{Enemy="Ice Zombie", Count=3, DelayBetweenSpawns=1.1}} },
	[11] = { CashReward=210, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=20,DelayBetweenSpawns=1.0},{Enemy="Ghost Zombie", Count=7, DelayBetweenSpawns=1.0},{Enemy="Ice Zombie", Count=4, DelayBetweenSpawns=1.0}} },
	[12] = { CashReward=230, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=20,DelayBetweenSpawns=1.0},{Enemy="Ghost Zombie", Count=8, DelayBetweenSpawns=1.0},{Enemy="Ice Zombie", Count=5, DelayBetweenSpawns=1.0}} },
	[13] = { CashReward=260, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=22,DelayBetweenSpawns=1.0},{Enemy="Ghost Zombie", Count=9, DelayBetweenSpawns=1.0},{Enemy="Ice Zombie", Count=5, DelayBetweenSpawns=1.0},{Enemy="Fire Zombie", Count=1, DelayBetweenSpawns=1.0}} },
	[14] = { CashReward=280, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=24,DelayBetweenSpawns=1.0},{Enemy="Ghost Zombie", Count=10,DelayBetweenSpawns=1.0},{Enemy="Ice Zombie", Count=6, DelayBetweenSpawns=1.0},{Enemy="Fire Zombie", Count=2, DelayBetweenSpawns=1.0}} },
	[15] = { CashReward=300, IsBossWave=true,  BossImageId="rbxassetid://121107085551812", Enemies={{Enemy="Drooling Zombie", Count=1, DelayBetweenSpawns=0}} },
}

-- ========= HELPERS =========
local function cashForWave(w: number): number
	local v = 180 + 10*w + 0.65*(w*w)
	return math.floor(v/5 + 0.5) * 5
end

local function weightsToCounts(weights: { [string]: number }, total: number): { [string]: number }
	local out, used = {}, 0
	local keys = {}
	for k in pairs(weights) do table.insert(keys, k) end
	table.sort(keys)
	for i, name in ipairs(keys) do
		if i < #keys then
			local c = math.floor(total * (weights[name] or 0))
			out[name] = c
			used += c
		else
			out[name] = math.max(0, total - used)
		end
	end
	return out
end

local function pickBoss(bossWeights: { [string]: number }?): BossDef
	local pool = {}
	if bossWeights then
		for name, weight in pairs(bossWeights) do pool[name] = weight end
	else
		for _, b in ipairs(Bosses) do pool[b.Name] = b.DefaultOdds end
	end
	local total, acc = 0, 0
	for _, v in pairs(pool) do total += v end
	local roll = math.random() * math.max(total, 1e-6)
	for name, v in pairs(pool) do
		acc += v
		if roll <= acc then
			for _, b in ipairs(Bosses) do if b.Name == name then return b end end
		end
	end
	return Bosses[1]
end

-- ========= SEGMENT LOGIC =========
local function segmentIndex(w: number): number
	return math.floor((w - 16) / STEP) + 1
end

local function getSegmentForWave(w: number): Segment
	local idx = segmentIndex(w)
	local last = #Segments
	if idx <= last then
		return Segments[idx]
	else
		local seg = Segments[last]
		local extra = idx - last
		return {
			enemyWeights = seg.enemyWeights,
			bossWeights  = seg.bossWeights,
			baseCount = math.floor((seg.baseCount or 24) * (EXTENSION.baseCountMultPerSegment ^ extra)),
			perWaveCountMult = (seg.perWaveCountMult or 1.03) * (EXTENSION.perWaveCountMultPerSegment ^ extra),
			perWaveHealthMult = (seg.perWaveHealthMult or 1.02) * (EXTENSION.perWaveHealthMultPerSegment ^ extra),
			perWaveSpawnRateMult = (seg.perWaveSpawnRateMult or 1.02) * (EXTENSION.perWaveSpawnRateMultPerSegment ^ extra),
			baseDelay = math.max(0.05, (seg.baseDelay or 1.2) * (EXTENSION.baseDelayMultPerSegment ^ extra)),
		}
	end
end

local function makeBossWave(w: number, seg: Segment): WaveConfig
	local b = pickBoss(seg.bossWeights)
	return {
		CashReward = cashForWave(w) + 250,
		IsBossWave = true,
		BossImageId = b.ImageId,
		HealthMultiplier = b.HealthMultiplier or 3.0,
		KillCashMultiplier = b.KillCashMultiplier or 2.0,
		DamageMultiplier = b.DamageMultiplier or 1.25,
		Enemies = b.EnemiesOverride or { { Enemy = b.Name, Count = 1, DelayBetweenSpawns = 0 } },
	}
end

local function makeNormalWave(w: number, seg: Segment): WaveConfig
	local idx = segmentIndex(w)
	local segStart = 16 + (idx - 1) * STEP
	local step = math.max(0, w - segStart)

	local baseCount = seg.baseCount or 24
	local cMult = seg.perWaveCountMult or 1.03
	local hpMult = seg.perWaveHealthMult or 1.02
	local rateMult = seg.perWaveSpawnRateMult or 1.02
	local delay = seg.baseDelay or 1.2

	local total = math.max(1, math.floor(baseCount * (cMult ^ step)))
	local counts = weightsToCounts(seg.enemyWeights, total)
	local enemies = {}
	for name, c in pairs(counts) do
		if c > 0 then
			table.insert(enemies, { Enemy = name, Count = c, DelayBetweenSpawns = delay })
		end
	end
	table.sort(enemies, function(a,b) return a.Enemy < b.Enemy end)

	return {
		CashReward = cashForWave(w),
		IsBossWave = false,
		Enemies = enemies,
		HealthMultiplier = hpMult ^ step,
		SpawnDelayMultiplier = 1 / math.max(0.25, rateMult ^ step),
	}
end

-- ========= BUILD ALL WAVES (NUMERIC KEYS ONLY) =========
for w = 16, MAX_WAVES do
	local seg = getSegmentForWave(w)
	if (w % GUARANTEED_BOSS_EVERY) == 0 then
		WaveConfigurations[w] = makeBossWave(w, seg)
	elseif math.random() < EXTRA_BOSS_CHANCE then
		WaveConfigurations[w] = makeBossWave(w, seg)
	else
		WaveConfigurations[w] = makeNormalWave(w, seg)
	end
end

-- expose ResolveWave without polluting pairs()
local function ResolveWave(w: number): WaveConfig
	return WaveConfigurations[w]
end

setmetatable(WaveConfigurations, {
	__index = function(_, k)
		if k == "ResolveWave" then
			return ResolveWave
		end
		return nil
	end
})

return WaveConfigurations


---

--- ReplicatedStorage.Modules.EnemyConfigurations (ModuleScript) ---
--!strict
-- This module contains data for each enemy type.

local EnemyConfigurations = {
	["Normal Zombie"] = {
		CashReward = 5,
		MaxHealth = 85,
		Damage = 10,
	},
	["Ghost Zombie"] = {
		CashReward = 10,
		MaxHealth = 100,
		Damage = 15,
	},
	["Ice Zombie"] = {
		CashReward = 15,
		MaxHealth = 150,
		Damage = 20,
	},
	["Fire Zombie"] = {
		CashReward = 20,
		MaxHealth = 190,
		Damage = 25,
	},
	["Toxic Zombie"] = {
		CashReward = 25,
		MaxHealth = 240,
		Damage = 30,
	},
	["Skeleton"] = {
		CashReward = 10,
		MaxHealth = 90,
		Damage = 15,
	},
	["Angry Miner"] = {
		CashReward = 13,
		MaxHealth = 135,
		Damage = 15,
	},
	["Half Skeletal"] = {
		CashReward = 20,
		MaxHealth = 105,
		Damage = 20,
	},
	["Explosive Boy"] = {
		CashReward = 40,
		MaxHealth = 245,
		Damage = 35,
	},
	["RogueCowboy"] = {
		CashReward = 25,
		MaxHealth = 130,
		Damage = 25,
	},
	["SkullHead"] = {
		CashReward = 20,
		MaxHealth = 135,
		Damage = 25,
	},
	["Looter Caravan"] = {
		CashReward = 30,
		MaxHealth = 300,
		Damage = 40,
	},
	["Alien Bandit"] = {
		CashReward = 30,
		MaxHealth = 250,
		Damage = 65,
	},
	["Rider Villain"] = {
		CashReward = 30,
		MaxHealth = 250,
		Damage = 65,
	},
	["Ghost Cowboy"] = {
		CashReward = 33,
		MaxHealth = 160,
		Damage = 70,
	},
	
	
	
	-- BOSS
	["Ghost Rider"] = {
		CashReward = 1100,
		MaxHealth = 1640,
		Damage = 60,
	},
	["Noob Boss"] = {
		CashReward = 950,
		MaxHealth = 1640,
		Damage = 55,
	},
	["Jandel Boss"] = {
		CashReward = 1300,
		MaxHealth = 1640,
		Damage = 65,
	},
	["Shedletsky Boss"] = {
		CashReward = 1000,
		MaxHealth = 1640,
		Damage = 60,
	},
	["Drooling Zombie"] = {
		CashReward = 1050,
		MaxHealth = 1640,
		Damage = 64,
	},
	["Zombie Boss"] = {
		CashReward = 950,
		MaxHealth = 1640,
		Damage = 60,
	},
	["Void Boss"] = {
		CashReward = 1500,
		MaxHealth = 1640,
		Damage = 63,
	},
	["Bacon Boss"] = {
		CashReward = 950,
		MaxHealth = 1640,
		Damage = 56,
	},
	["Pumpkin Alien"] = {
		CashReward = 1050,
		MaxHealth = 1640,
		Damage = 65,
	},
	["Pumpkin Reaper"] = {
		CashReward = 1050,
		MaxHealth = 1640,
		Damage = 65,
	},
}

return EnemyConfigurations
---

--- ReplicatedStorage.Modules.ModelProgression (ModuleScript) ---
--!strict
-- This module defines the progression of items the player protects.

local ModelProgression = {
	-- IMPORTANT: The tables must be in order, starting from 1.

	[1] = {
		ModelName = "1",
		PlotHealth = 10,
		WaveRequirement = 0,
		ImageId = "rbxassetid://110988601683343",
	},
	[2] = {
		ModelName = "2",
		PlotHealth = 20,
		WaveRequirement = 15,
		ImageId = "rbxassetid://71530011018392",
	},
	[3] = {
		ModelName = "3",
		PlotHealth = 30,
		WaveRequirement = 45,
		ImageId = "rbxassetid://70765293183243",
	},
	[4] = {
		ModelName = "4",
		PlotHealth = 40,
		WaveRequirement = 60,
		ImageId = "rbxassetid://127554191147986",
	},
	[5] = {
		ModelName = "5",
		PlotHealth = 50,
		WaveRequirement = 75,
		ImageId = "rbxassetid://101196843053573",
	},
	[6] = {
		ModelName = "6",
		PlotHealth = 50,
		WaveRequirement = 120,
		ImageId = "rbxassetid://109464415588878",
	},
	[7] = {
		ModelName = "7",
		PlotHealth = 50,
		WaveRequirement = 150,
		ImageId = "rbxassetid://122966550318789",
	},
	[8] = {
		ModelName = "8",
		PlotHealth = 50,
		WaveRequirement = 205,
		ImageId = "rbxassetid://111332197178362",
	},
}

return ModelProgression
---

--- ReplicatedStorage.Modules.DamageHandler (ModuleScript) ---
--!strict
-- Located in: ReplicatedStorage/Modules/DamageHandler.lua

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local HighlightZombie = ReplicatedStorage.Events:WaitForChild("HighlightZombie")

local DamageHandler = {}

function DamageHandler.dealDamage(source: Instance, target: Instance, damageAmount: number): boolean
	if not target or not target.Parent then return false end

	local humanoid = target:FindFirstChildOfClass("Humanoid")
	local healthAttribute = target:GetAttribute("Health")

	if humanoid then
		humanoid:TakeDamage(damageAmount)

		-- Only highlight if the target is still alive
		if humanoid.Health > 0 then
			HighlightZombie:FireAllClients(target)
		end

		return humanoid.Health <= 0

	elseif typeof(healthAttribute) == "number" then
		local newHealth = healthAttribute - damageAmount
		target:SetAttribute("Health", newHealth)

		if newHealth <= 0 then
			if target.Name ~= "PlotHealth" then
				target:Destroy()
			end
			return true
		end
	end

	return false
end

return DamageHandler
---

--- ReplicatedStorage.Modules.WeaponConfigurations (ModuleScript) ---
--!strict
-- This module contains data for all crates and weapons.

local WeaponConfigurations = {
	--RESTOCKS
	ShopProducts = {
		RestockBlocksShop = { ProductID = 3435398560}, -- Use your new DevProduct ID here
		RestockWeaponsShop = { ProductID = 3435398961}, -- Use your new DevProduct ID here
	},
	--CASH
	CashProducts = {
		Product1 = { ProductID = 3433108028, CashAmount = 5000 },
		Product2 = { ProductID = 3433108213, CashAmount = 25000 },
		Product3 = { ProductID = 3433108417, CashAmount = 100000 },
		Product4 = { ProductID = 3433108573, CashAmount = 300000 },
	},
	--CRATES
	Crates = {
		--ROBUX
		GoldCrate = {
			DisplayName = "Gold Crate",
			ImageId = "rbxassetid://103369512470336",
			ProductID = 3433548997,
			Loot = {
				{Item = "Electra", Weight = 25},
				{Item = "Heliocore", Weight = 15},
				{Item = "PlasmaGun", Weight = 15},
				{Item = "Riftshot", Weight = 20},
				{Item = "Toxion", Weight = 25},
			}
		},
		--SHOP
		WoodCrate = {
			DisplayName = "Wood Crate",
			Price = 600,
			ImageId = "rbxassetid://71941897708431",
			ProductID = 3433106911,
			SkipTimerProductID = 3433550556,
			Unlimited = false,
			Chance = 100,
			StockAmount = {Min = 1, Max = 5},
			UnlockTime = 60,
			Loot = {
				{Item = "KimberK65", Weight = 40},
				--{Item = "DesertEagle", Weight = 25},
				{Item = "Uzi", Weight = 5},
			}
		},
		MetalCrate = {
			DisplayName = "Metal Crate",
			Price = 4500,
			ImageId = "rbxassetid://83369732207805",
			ProductID = 3433107064,
			SkipTimerProductID = 3433550660,
			Unlimited = false,
			Chance = 60,
			StockAmount = {Min = 1, Max = 4},
			UnlockTime = 180,
			Loot = {
				{Item = "Uzi", Weight = 30},
				{Item = "Mp5", Weight = 20},
				{Item = "K3", Weight = 10},
				{Item = "Ak47", Weight = 4.5},
			}
		},
		LavaCrate = {
			DisplayName = "Mystic Crate",
			Price = 10500,
			ImageId = "rbxassetid://123400851920868",
			ProductID = 3451490544,
			SkipTimerProductID = 3451799259,
			Unlimited = false,
			Chance = 30,
			StockAmount = {Min = 1, Max = 3},
			UnlockTime = 480,
			Loot = {
				{Item = "Uzi", Weight = 40},
				{Item = "Mp5", Weight = 30},
				{Item = "Ak47", Weight = 15},
				{Item = "K3", Weight = 30},
				{Item = "Electra", Weight = 0.5},
				{Item = "Heliocore", Weight = 0.5},
				{Item = "PlasmaGun", Weight = 0.5},
				{Item = "Riftshot", Weight = 0.5},
				{Item = "Toxion", Weight = 0.5},
			}
		},
	},

	Weapons = {
		----Starter
		Heizer = { DisplayName = "Starter Pistol", ImageId = "rbxassetid://126357192361583" },
		--Wood
		KimberK65 = { DisplayName = "Revolver", ImageId = "rbxassetid://126357192361583" },
		DesertEagle = { DisplayName = "Desert Eagle", ImageId = "rbxassetid://126321981198719" },
		--Metal 
		Uzi = { DisplayName = "Uzi", ImageId = "rbxassetid://105402058861520" },
		Mp5 = { DisplayName = "MP5", ImageId = "rbxassetid://86471167567925" },
		sp5 = { DisplayName = "SP5", ImageId = "rbxassetid://126321981198719" },
		--Lava
		K3 = { DisplayName = "K3", ImageId = "rbxassetid://101148291850721" },
		M14 = { DisplayName = "M14", ImageId = "rbxassetid://126321981198719" },
		--Gold 
		Ak47 = { DisplayName = "Ak-47", ImageId = "rbxassetid://76263708523559" },
		Scout = { DisplayName = "Scout Sniper", ImageId = "rbxassetid://126321981198719" },
		Minigun = { DisplayName = "OP Minigun", ImageId = "rbxassetid://105369473183603" },
		
		Heliocore = { DisplayName = "Heliocore", ImageId = "rbxassetid://110449100260279" },
		Electra = { DisplayName = "Electra", ImageId = "rbxassetid://97942841375097" },
		Toxion = { DisplayName = "Toxion", ImageId = "rbxassetid://122765809455182" },
		Riftshot = { DisplayName = "Riftshot", ImageId = "rbxassetid://129412800119898" },
		PlasmaGun = { DisplayName = "PlasmaGun", ImageId = "rbxassetid://112273276197884" },

		
		
		
		--WoodSword = { DisplayName = "Wood Sword", ImageId = "rbxassetid://126321981198719" },
		----Wood
		--StoneSword = { DisplayName = "Stone Sword", ImageId = "rbxassetid://98850338938642" },
		--ClassicSword = { DisplayName = "Classic Sword", ImageId = "rbxassetid://137083985660048" },
		--WhiteSword = { DisplayName = "WhiteSword", ImageId = "rbxassetid://107209992307667" },
		----Metal
		--BlueSword = { DisplayName = "Blue Sword", ImageId = "rbxassetid://106268955187746" },
		--IceSword = { DisplayName = "Ice Sword", ImageId = "rbxassetid://86285408542421" },
		--AzureSword = { DisplayName = "Azure Sword", ImageId = "rbxassetid://139447042654835" },
		--PinkSword = { DisplayName = "Pink Sword", ImageId = "rbxassetid://123160254672400" },
		----Lava
		--OrangeSword = { DisplayName = "Orange Sword", ImageId = "rbxassetid://127527435191865" },
		--RedSword = { DisplayName = "Red Sword", ImageId = "rbxassetid://101443099194443" },
		--DragonSword = { DisplayName = "Dragon Sword", ImageId = "rbxassetid://101415025341980" },
		----Gold
		--GoldSword = { DisplayName = "Gold Sword", ImageId = "rbxassetid://122412629570696" },
		--GoldClassic = { DisplayName = "Gold Classic", ImageId = "rbxassetid://94902355900831" },
		--GoldIce = { DisplayName = "Gold Ice", ImageId = "rbxassetid://87139784295616" },
		--GoldAzure = { DisplayName = "Gold Azure", ImageId = "rbxassetid://74018974426561" },
	}
}

return WeaponConfigurations
---

--- ReplicatedStorage.Modules.LeaderboardConfig (ModuleScript) ---
--!strict
local LeaderboardConfig = {
	DataStores = {
		MostCash       = "LB_MostCash_v1",
		MostWaves      = "LB_MostWaves_v1",
		MostPlaytime   = "LB_MostPlaytime_v1",
		MostRobuxSpent = "LB_MostRobuxSpent_v1", 
	},

	UI = {
		CanvasSize    = Vector2.new(900, 700),
		PixelsPerStud = 45,
		Bg            = Color3.fromRGB(30,170,255),
		Stroke        = Color3.fromRGB(0,0,0),
		TitleColor    = Color3.fromRGB(255,255,255),
		TextColor     = Color3.fromRGB(240,240,240),
		TitleSize     = 42,
		RowSize       = 28,
		RowPad        = 12,
	},


	Limit        = 10,
	PullInterval = 120,


	ModelNames = {
		Cash     = "MostCash",
		Waves    = "MostWaves",
		Playtime = "MostPlaytime",
		Robux    = "MostRobuxSpent",
	},


	BoardPartName = "Board",
}
return LeaderboardConfig

---

--- ReplicatedStorage.Modules.TravellingConfigurations (ModuleScript) ---
--!strict
local TravellingConfigurations = {
	-- Window stays 5 minutes (300 s)
	WINDOW_SECONDS = 300,

	-- NEW: auto-open every N minutes (use 20 for :00, :20, :40)
	AUTO_MINUTE_INTERVAL = 20,

	ADMIN_USER_IDS = {
		[936563031] = true, -- you
		[102527104] = true,
	},

	LUCK_DURATION_SECONDS = 15 * 60,
	LUCK_DROP_MULTIPLIER  = 1.50,
	LUCK_BADGE_ICON       = "rbxassetid://74485910606028",

	OFFERS = {
		{
			Id = "LuckPotion15m",
			Title = "Luck Potion (15m)",
			Kind  = "Luck",
			Duration = 15 * 60,
			Price = 12000,
			StockTotal = 2,
			Icon = "rbxassetid://74485910606028",
		},
		{
			Id = "MortarGuard",
			Title = "Mortar Cowboy",
			Kind  = "Unit",
			Price = 65000,
			StockTotal = 2,
			Icon = "rbxassetid://97959863510956",
		},
		{
			Id = "Diamond",
			Title = "Diamond Block",
			Kind  = "Block",
			Price = 25000,
			StockTotal = 2,
			Icon = "rbxassetid://90412412707609",
		},
		{
			Id = "ToxicSpike",
			Title = "Toxic Spike",
			Kind  = "Block",
			Price = 30000,
			StockTotal = 2,
			Icon = "rbxassetid://115198885487974",
		},
	},

	ALLOW_PUBLIC_RESTOCK  = false,
	RESTOCK_DEVPRODUCT_ID = 0,
	RESTOCK_INCREMENT     = 1,
}

return TravellingConfigurations

---

--- ReplicatedStorage.Modules.UpgradePlotConfig (ModuleScript) ---
--!strict
local UpgradePlotConfig = {}

UpgradePlotConfig.MaxTier = 10

UpgradePlotConfig.TurretLimitByTier  = {10, 15, 20, 25, 30, 35, 40, 45, 50, 55}
UpgradePlotConfig.BlockLimitByTier   = {15, 30, 50, 70, 90, 100, 110, 120, 130, 140}

-- Multipliers (still applied if players already have tiers)
UpgradePlotConfig.TurretHpMultByTier = {1.00, 1.10, 1.20, 1.30, 1.40, 1.55, 1.70, 1.85, 2.05, 2.25}
UpgradePlotConfig.BlockHpMultByTier  = {1.00, 1.08, 1.16, 1.24, 1.32, 1.42, 1.52, 1.64, 1.78, 1.95}

-- Cash costs current -> next
UpgradePlotConfig.Costs_TurretLimit  = {5000, 15000, 30000, 45000, 90000, 125000, 160000, 200000}
UpgradePlotConfig.Costs_BlockLimit   = {2500, 7500, 15000, 30000, 45000, 60000, 75000, 90000, 105000, 120000}

-- ðŸ”’ Retired: disallow further HP purchases by providing no next-costs
UpgradePlotConfig.Costs_TurretHp     = {}
UpgradePlotConfig.Costs_BlockHp      = {}

function UpgradePlotConfig.GetTrackValue(track:string, tier:number): number
	local t = if track=="TurretLimitTier" then UpgradePlotConfig.TurretLimitByTier
		elseif track=="BlockLimitTier"   then UpgradePlotConfig.BlockLimitByTier
		elseif track=="TurretHpTier"     then UpgradePlotConfig.TurretHpMultByTier
		elseif track=="BlockHpTier"      then UpgradePlotConfig.BlockHpMultByTier
		else error("Unknown track "..track)
	return t[math.clamp(tier, 1, #t)]
end

function UpgradePlotConfig.GetNextCost(track:string, tier:number): number?
	if tier >= UpgradePlotConfig.MaxTier then return nil end
	local t = if track=="TurretLimitTier" then UpgradePlotConfig.Costs_TurretLimit
		elseif track=="BlockLimitTier"   then UpgradePlotConfig.Costs_BlockLimit
		elseif track=="TurretHpTier"     then UpgradePlotConfig.Costs_TurretHp
		elseif track=="BlockHpTier"      then UpgradePlotConfig.Costs_BlockHp
		else error("Unknown track "..track)
	return t[tier] -- will be nil for HP tracks -> cannot buy
end

return UpgradePlotConfig

---

--- ReplicatedStorage.Modules.TopUpModule (ModuleScript) ---
--!strict
-- TopUpModule: pick nearest cash devproduct and prompt player if short on money.
-- Non-blocking API with a callback invoked as soon as the prompt closes.
local ReplicatedStorage    = game:GetService("ReplicatedStorage")
local Players              = game:GetService("Players")
local MarketplaceService   = game:GetService("MarketplaceService")

local ModulesFolder        = ReplicatedStorage:WaitForChild("Modules")
local WeaponConfigurations = require(ModulesFolder:WaitForChild("WeaponConfigurations"))
-- << ADDED >>
local Functions = ReplicatedStorage:WaitForChild("Functions")

local TopUp = {}

type CashProduct = { ProductID: number, CashAmount: number }
type ResultCb = (purchased: boolean) -> ()

local function allCashProducts(): { CashProduct }
	local arr: { CashProduct } = {}
	for _, entry in pairs(WeaponConfigurations.CashProducts) do
		if typeof(entry.ProductID) == "number" and typeof(entry.Amount) == "number" then
			table.insert(arr, { ProductID = entry.ProductID, CashAmount = entry.CashAmount })
		end
	end
	return arr
end

-- << NEW FUNCTION >> Get the player's current cash directly from the server
local function getLocalBalance(p: Player): number
	local getCashFunc = Functions:FindFirstChild("GetPlayerCash")
	if getCashFunc and getCashFunc:IsA("RemoteFunction") then
		local ok, cash = pcall(getCashFunc.InvokeServer, getCashFunc)
		if ok and typeof(cash) == "number" then
			return cash
		end
	end
	-- Fallback to 0 if server can't be reached
	return 0
end


function TopUp.getNearestProductId(missingAmount: number): number?
	if typeof(missingAmount) ~= "number" or missingAmount <= 0 then return nil end
	local bestId: number?
		= nil
	local bestDiff = math.huge
	local bestAmt  = -math.huge
	for _, p in ipairs(allCashProducts()) do
		local diff = math.abs(p.CashAmount - missingAmount)
		if diff < bestDiff or (diff == bestDiff and p.CashAmount > bestAmt) then
			bestDiff = diff
			bestAmt  = p.CashAmount
			bestId   = p.ProductID
		end
	end
	return bestId
end

-- Opens the prompt and returns immediately.
-- Returns: promptOpened:boolean
-- onResult(purchased:boolean) is called as soon as the dialog closes.
function TopUp.PromptIfShort(costOrMissing: number, balance: number?, onResult: ResultCb?): boolean
	-- Use the server to get the current balance if not provided, since leaderstats are gone
	if balance == nil then
		balance = getLocalBalance(Players.LocalPlayer) -- Use the new local getter
	end

	local missing = (typeof(balance) == "number") and (costOrMissing - balance) or costOrMissing
	if typeof(missing) ~= "number" or missing <= 0 then
		return false
	end

	local productId = TopUp.getNearestProductId(missing)
	if typeof(productId) ~= "number" then
		if onResult then onResult(false) end
		return false
	end

	local lp = Players.LocalPlayer
	if not lp then
		if onResult then onResult(false) end
		return false
	end

	local conn: RBXScriptConnection?
		= nil
	conn = MarketplaceService.PromptProductPurchaseFinished:Connect(function(player, purchasedProductId, wasPurchased)
		if player == lp and purchasedProductId == productId then
			if conn then conn:Disconnect() end
			if onResult then
				onResult(wasPurchased == true)
			end
		end
	end)

	local ok, err = pcall(function()
		MarketplaceService:PromptProductPurchase(lp, productId)
	end)
	if not ok then
		if conn then conn:Disconnect() end
		if onResult then onResult(false) end
		return false
	end

	return true
end

return TopUp
---

--- ReplicatedStorage.Modules.BadgeConfigurations (ModuleScript) ---
--!strict
-- Central place for all badge IDs

export type BadgeKey =
	"You played!" |
"Acquired Revolver Cowboy" |
"Acquired Akimbo Cowboy" |
"Acquired Uzi Cowboy" |
"Acquired Shotgun Cowboy" |
"Acquired Heavy Gunner" |
"Acquired Rifle Cowboy" |
"Acquired Mortar Cowboy" |
"First Mutation"

local BadgeCatalog: {[BadgeKey]: number} = {
	["You played!"]                 = 3052525153404258,
	["Acquired Revolver Cowboy"]    = 591671251623280,
	["Acquired Akimbo Cowboy"]      = 3467287377539020,
	["Acquired Uzi Cowboy"]         = 583789044141476,
	["Acquired Shotgun Cowboy"]     = 84885666466521,
	["Acquired Heavy Gunner"]       = 2468150254651967,
	["Acquired Rifle Cowboy"]       = 3063311694654024,
	["Acquired Mortar Cowboy"]      = 801395319305690,
	["First Mutation"]              = 1504419190804543,
}

return BadgeCatalog

---