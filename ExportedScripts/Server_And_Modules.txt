--- ServerScriptService.Main (Script) ---
--[[
	Main Server Script
	
	Description: The entry point for all server-side game logic.
	It initializes the Bootstrap module which loads, initializes,
	and starts all other controller scripts.
	
	Location: ServerScriptService
--]]
--!strict

local ServerScriptService = game:GetService("ServerScriptService")
local Bootstrap = require(ServerScriptService.Modules.Bootstrap)

-- Run the bootstrap process and tell it to look for controllers
-- inside the "Controllers" folder.
Bootstrap(ServerScriptService.Controllers)

---

--- ServerScriptService.Modules.Bootstrap (ModuleScript) ---
--!strict

local Extensions = require(script:WaitForChild("Extensions"))

local Bootstrap = {}

local isRunning: boolean = false
local controllers: {[string]: any} = {}

function Bootstrap(container: Instance)
	if isRunning then
		error("[Bootstrap] Already initialized!")
	end
	isRunning = true

	-- Load controllers
	for _, module: Instance in container:GetDescendants() do
		if module:IsA("ModuleScript") and module.Name:match("Controller$") then
			local controllerName: string = module.Name
			local success, requiredModule = pcall(require, module)
			if success then
				setmetatable(requiredModule, Extensions.Controller)
				requiredModule._bs_name = controllerName
				controllers[controllerName] = requiredModule
			end
		end
	end

	-- This block fixes the race condition by setting up instances first.
	local playerController = controllers.PlayerController
	if playerController and playerController.SetupSharedInstances then
		playerController:SetupSharedInstances()
	else
		warn("[Bootstrap] Could not find PlayerController to set up shared instances!")
	end

	-- Initialize controllers
	for _, controller in controllers do
		if controller.Init then
			controller:Init(controllers)
		end
	end

	-- Start controllers
	for _, controller in controllers do
		if controller.Start then
			task.spawn(function()
				pcall(controller.Start, controller, controllers)
			end)
		end
	end
end

return Bootstrap
---

--- ServerScriptService.Modules.Bootstrap.Extensions (ModuleScript) ---
--[[
    SCRIPT: Extensions (MODULE SCRIPT) - OPTIMIZED
    
    Location: ServerScriptService/Modules/Bootstrap/Extensions
    
    Description: Base metatable for controllers with shared methods.
    Clean code: Strict typing, simplified.
--]]
--!strict

local Extensions = {}

local Controller = {}
Controller.__index = Controller

function Controller:IsInitialized(): boolean
	return self._bs_initialized or false
end

Extensions.Controller = Controller

return Extensions
---

--- ServerScriptService.Modules.ProfileService (ModuleScript) ---
--[[
MAD STUDIO (by loleris)

-[ProfileStore]---------------------------------------

	Periodic DataStore saving solution with session locking
	
	WARNINGS FOR "Profile.Data" VALUES:
	 	! Do not create numeric tables with gaps - attempting to store such tables will result in an error.
		! Do not create mixed tables (some values indexed by number and others by a string key)
			- only numerically indexed  data will be stored.
		! Do not index tables by anything other than numbers and strings.
		! Do not reference Roblox Instances
		! Do not reference userdata (Vector3, Color3, CFrame...) - Serialize userdata before referencing
		! Do not reference functions
		
	Members:
	
		ProfileStore.IsClosing          [bool]
			-- Set to true after a game:BindToClose() trigger
			
		ProfileStore.IsCriticalState    [bool]
			-- Set to true when ProfileStore experiences too many consecutive errors
		
		ProfileStore.OnError            [Signal] (message, store_name, profile_key)
			-- Most ProfileStore errors will be caught and passed to this signal
			
		ProfileStore.OnOverwrite        [Signal] (store_name, profile_key)
			-- Triggered when a DataStore key was likely used to store data that wasn't
			a ProfileStore profile or the ProfileStore structure was invalidly manually
			altered for that DataStore key
			
		ProfileStore.OnCriticalToggle   [Signal] (is_critical)
			-- Triggered when ProfileStore experiences too many consecutive errors
		
		ProfileStore.DataStoreState     [string] ("NotReady", "NoInternet", "NoAccess", "Access")
			-- This value resembles ProfileStore's access to the DataStore; The value starts
			as "NotReady" and will eventually change to one of the other 3 possible values.
	
	Functions:
	
		ProfileStore.New(store_name, template?) --> [ProfileStore]
			store_name   [string] -- DataStore name
			template     [table] or nil -- Profiles will default to given table (hard-copy) when no data was saved previously
			
		ProfileStore.SetConstant(name, value)
			name    [string]
			value   [number]
				
	Members [ProfileStore]:
	
		ProfileStore.Mock   [ProfileStore]
			-- Reflection of ProfileStore methods, but the methods will now query a mock
			DataStore with no relation to the real DataStore
			
		ProfileStore.Name   [string]
		
	Methods [ProfileStore]:
	
		ProfileStore:StartSessionAsync(profile_key, params?) --> [Profile] or nil
			profile_key [string] -- DataStore key
			params      nil or [table]: -- Custom params; E.g. {Steal = true}
				{
					Steal = true, -- Pass this to disregard an existing session lock
					Cancel = fn() -> (boolean), -- Pass this to create a request cancel condition.
						-- If the cancel function returns true, ProfileStore will stop trying to
						-- start the session and return nil
				}
			
		ProfileStore:MessageAsync(profile_key, message) --> is_success [bool]
			profile_key [string] -- DataStore key
			message     [table] -- Data to be messaged to the profile
			
		ProfileStore:GetAsync(profile_key, version?) --> [Profile] or nil
			-- Reads a profile without starting a session - will not autosave
			profile_key   [string] -- DataStore key
			version       nil or [string] -- DataStore key version

		ProfileStore:VersionQuery(profile_key, sort_direction?, min_date?, max_date?) --> [VersionQuery]
			profile_key      [string]
			sort_direction   nil or [Enum.SortDirection]
			min_date         nil or [DateTime]
			max_date         nil or [DateTime]
			
		ProfileStore:RemoveAsync(profile_key) --> is_success [bool]
			-- Completely removes profile data from the DataStore / mock DataStore with no way to recover it.

	Methods [VersionQuery]:

		VersionQuery:NextAsync() --> [Profile] or nil -- (Yields)
			-- Returned profile is similar to profiles returned by ProfileStore:GetAsync()
		
	Members [Profile]:
	
		Profile.Data               [table]
			-- When the profile is active changes to this table are guaranteed to be saved
		Profile.LastSavedData      [table] (Read-only)
			-- Last snapshot of "Profile.Data" that has been successfully saved to the DataStore;
			Useful for proper developer product purchase receipt handling
		
		Profile.FirstSessionTime   [number] (Read-only)
			-- os.time() timestamp of the first profile session
			
		Profile.SessionLoadCount   [number] (Read-only) -- Amount of times a session was started for this profile
			
		Profile.Session            [table] (Read-only) {PlaceId = number, JobId = string} / nil
			-- Set to a table if this profile is in use by a server; nil if released

		Profile.RobloxMetaData     [table] -- Writable table that gets saved automatically and once the profile is released
		Profile.UserIds            [table] -- (Read-only) -- {user_id [number], ...} -- User ids associated with this profile

		Profile.KeyInfo            [DataStoreKeyInfo] -- Changes before OnAfterSave signal
		
		Profile.OnSave             [Signal] ()
			-- Triggered right before changes to Profile.Data are saved to the DataStore
			
		Profile.OnLastSave         [Signal] (reason [string]: "Manual", "External", "Shutdown")
			-- Triggered right before changes to Profile.Data are saved to the DataStore
			for the last time; A reason is provided for the last save:
				- "Manual"   - Profile:EndSession() was called
				- "Shutdown" - The server that has ownership of this profile is shutting down
				- "External" - Another server has started a session for this profile
			Note that this event will not trigger for when a profile session is ended by
			another server trying to take ownership of the session - this is impossible to
			do without compromising on ProfileStore's speed.
			
		Profile.OnSessionEnd       [Signal] ()
			-- Triggered when the profile session is terminated on this server
		
		Profile.OnAfterSave        [Signal] (last_saved_data)
			-- Triggered after a successful save
			last_saved_data [table] -- Profile.LastSavedData
			
		Profile.ProfileStore       [ProfileStore] -- ProfileStore object this profile belongs to
		Profile.Key                [string] -- DataStore key
		
	Methods [Profile]:
	
		Profile:IsActive() --> [bool] -- If "true" is returned, changes to Profile.Data are guaranteed to save;
			This guarantee is only valid until code yields (e.g. task.wait() is used).
			
		Profile:Reconcile() -- Fills in missing (nil) [string_key] = [value] pairs to the Profile.Data structure
			from the "template" argument that was passed to "ProfileStore.New()"
			
		Profile:EndSession() -- Call after the server has finished working with this profile
			e.g., after the player leaves (Profile object will become inactive)

		Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)
			user_id   [number]

		Profile:RemoveUserId(user_id) -- Removes user_id association with profile (safe function)
			user_id   [number]
			
		Profile:MessageHandler(fn) -- Sets a message handler for this profile
			fn [function] (message [table], processed [function]())
			-- The handler function receives a message table and a callback function;
			The callback function is to be called when a message has been processed
			- this will discard the message from the profile message cache; If the
			callback function is not called, other message handlers will also be triggered
			with unprocessed message data.
			
		Profile:Save() -- If the profile session is still active makes an UpdateAsync call
			to the DataStore to immediately save profile data

		Profile:SetAsync() -- Forcefully saves changes to the profile; Only for profiles
			loaded with ProfileStore:GetAsync() or ProfileStore:VersionQuery()
		
--]]

local AUTO_SAVE_PERIOD = 300 -- (Seconds) Time between when changes to a profile are saved to the DataStore
local LOAD_REPEAT_PERIOD = 10 -- (Seconds) Time between successive profile reads when handling a session conflict
local FIRST_LOAD_REPEAT = 5 -- (Seconds) Time between first and second profile read when handling a session conflict
local SESSION_STEAL = 40 -- (Seconds) Time until a session conflict is resolved with the waiting server stealing the session
local ASSUME_DEAD = 630 -- (Seconds) If a profile hasn't had updates for this long, quickly assume an active session belongs to a crashed server
local START_SESSION_TIMEOUT = 120 -- (Seconds) If a session can't be started for a profile for this long, stop repeating calls to the DataStore

local CRITICAL_STATE_ERROR_COUNT = 5 -- Assume critical state if this many issues happen in a short amount of time
local CRITICAL_STATE_ERROR_EXPIRE = 120 -- (Seconds) Individual issue expiration
local CRITICAL_STATE_EXPIRE = 120 -- (Seconds) Critical state expiration

local MAX_MESSAGE_QUEUE = 1000 -- Max messages saved in a profile that were sent using "ProfileStore:MessageAsync()"

----- Dependencies -----

-- local Util = require(game.ReplicatedStorage.Shared.Util)
-- local Signal = Util.Signal

local Signal do

	local FreeRunnerThread

	--[[
		Yield-safe coroutine reusing by stravant;
		Sources:
		https://devforum.roblox.com/t/lua-signal-class-comparison-optimal-goodsignal-class/1387063
		https://gist.github.com/stravant/b75a322e0919d60dde8a0316d1f09d2f
	--]]

	local function AcquireRunnerThreadAndCallEventHandler(fn, ...)
		local acquired_runner_thread = FreeRunnerThread
		FreeRunnerThread = nil
		fn(...)
		-- The handler finished running, this runner thread is free again.
		FreeRunnerThread = acquired_runner_thread
	end

	local function RunEventHandlerInFreeThread(...)
		AcquireRunnerThreadAndCallEventHandler(...)
		while true do
			AcquireRunnerThreadAndCallEventHandler(coroutine.yield())
		end
	end

	local Connection = {}
	Connection.__index = Connection

	local SignalClass = {}
	SignalClass.__index = SignalClass

	function Connection:Disconnect()

		if self.is_connected == false then
			return
		end

		local signal = self.signal
		self.is_connected = false
		signal.listener_count -= 1

		if signal.head == self then
			signal.head = self.next
		else
			local prev = signal.head
			while prev ~= nil and prev.next ~= self do
				prev = prev.next
			end
			if prev ~= nil then
				prev.next = self.next
			end
		end

	end

	function SignalClass.New()

		local self = {
			head = nil,
			listener_count = 0,
		}
		setmetatable(self, SignalClass)

		return self

	end

	function SignalClass:Connect(listener: (...any) -> ())

		if type(listener) ~= "function" then
			error(`[{script.Name}]: \"listener\" must be a function; Received {typeof(listener)}`)
		end

		local connection = {
			listener = listener,
			signal = self,
			next = self.head,
			is_connected = true,
		}
		setmetatable(connection, Connection)

		self.head = connection
		self.listener_count += 1

		return connection

	end

	function SignalClass:GetListenerCount(): number
		return self.listener_count
	end

	function SignalClass:Fire(...)
		local item = self.head
		while item ~= nil do
			if item.is_connected == true then
				if not FreeRunnerThread then
					FreeRunnerThread = coroutine.create(RunEventHandlerInFreeThread)
				end
				task.spawn(FreeRunnerThread, item.listener, ...)
			end
			item = item.next
		end
	end

	function SignalClass:Wait()
		local co = coroutine.running()
		local connection
		connection = self:Connect(function(...)
			connection:Disconnect()
			task.spawn(co, ...)
		end)
		return coroutine.yield()
	end

	Signal = table.freeze({
		New = SignalClass.New,
	})

end

----- Private -----

local ActiveSessionCheck = {} -- {[session_token] = profile, ...}
local AutoSaveList = {} -- {profile, ...} -- Loaded profile table which will be circularly auto-saved
local IssueQueue = {} -- {issue_time, ...}

local DataStoreService = game:GetService("DataStoreService")
local MessagingService = game:GetService("MessagingService")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

local PlaceId = game.PlaceId
local JobId = game.JobId

local AutoSaveIndex = 1 -- Next profile to auto save
local LastAutoSave = os.clock()

local LoadIndex = 0

local ActiveProfileLoadJobs = 0 -- Number of active threads that are loading in profiles
local ActiveProfileSaveJobs = 0 -- Number of active threads that are saving profiles

local CriticalStateStart = 0 -- os.clock()

local IsStudio = RunService:IsStudio()
local DataStoreState: "NotReady" | "NoInternet" | "NoAccess" | "Access" = "NotReady"

local MockStore = {}
local UserMockStore = {}
local MockFlag = false

local OnError = Signal.New() -- (message, store_name, profile_key)
local OnOverwrite = Signal.New() -- (store_name, profile_key)

local UpdateQueue = { -- For stability sake, we won't do UpdateAsync calls for the same key until all previous calls finish
	--[[
		[session_token] = {
			coroutine, ...
		},
		...
	--]]
}

local function WaitInUpdateQueue(session_token) --> next_in_queue()

	local is_first = false

	if UpdateQueue[session_token] == nil then
		is_first = true
		UpdateQueue[session_token] = {}
	end

	local queue = UpdateQueue[session_token]

	if is_first == false then
		table.insert(queue, coroutine.running())
		coroutine.yield()
	end

	return function()
		local next_co = table.remove(queue, 1)
		if next_co ~= nil then
			coroutine.resume(next_co)
		else
			UpdateQueue[session_token] = nil
		end
	end

end

local function SessionToken(store_name, profile_key, is_mock)

	local session_token = "L_" -- Live

	if is_mock == true then
		session_token = "U_" -- User mock
	elseif DataStoreState ~= "Access" then
		session_token = "M_" -- Mock, cause no DataStore access
	end

	session_token ..= store_name .. "\0" .. profile_key

	return session_token

end

local function DeepCopyTable(t)
	local copy = {}
	for key, value in pairs(t) do
		if type(value) == "table" then
			copy[key] = DeepCopyTable(value)
		else
			copy[key] = value
		end
	end
	return copy
end

local function ReconcileTable(target, template)
	for k, v in pairs(template) do
		if type(k) == "string" then -- Only string keys will be reconciled
			if target[k] == nil then
				if type(v) == "table" then
					target[k] = DeepCopyTable(v)
				else
					target[k] = v
				end
			elseif type(target[k]) == "table" and type(v) == "table" then
				ReconcileTable(target[k], v)
			end
		end
	end
end

local function RegisterError(error_message, store_name, profile_key) -- Called when a DataStore API call errors
	warn(`[{script.Name}]: DataStore API error (STORE:{store_name}; KEY:{profile_key}) - {tostring(error_message)}`)
	table.insert(IssueQueue, os.clock()) -- Adding issue time to queue
	OnError:Fire(tostring(error_message), store_name, profile_key)
end

local function RegisterOverwrite(store_name, profile_key) -- Called when a corrupted profile is loaded
	warn(`[{script.Name}]: Invalid profile was overwritten (STORE:{store_name}; KEY:{profile_key})`)
	OnOverwrite:Fire(store_name, profile_key)
end

local function NewMockDataStoreKeyInfo(params)

	local version_id_string = tostring(params.VersionId or 0)
	local meta_data = params.MetaData or {}
	local user_ids = params.UserIds or {}

	return {
		CreatedTime = params.CreatedTime,
		UpdatedTime = params.UpdatedTime,
		Version = string.rep("0", 16) .. "."
			.. string.rep("0", 10 - string.len(version_id_string)) .. version_id_string
			.. "." .. string.rep("0", 16) .. "." .. "01",

		GetMetadata = function()
			return DeepCopyTable(meta_data)
		end,

		GetUserIds = function()
			return DeepCopyTable(user_ids)
		end,
	}

end

local function MockUpdateAsync(mock_data_store, profile_store_name, key, transform_function, is_get_call) --> loaded_data, key_info

	local profile_store = mock_data_store[profile_store_name]

	if profile_store == nil then
		profile_store = {}
		mock_data_store[profile_store_name] = profile_store
	end

	local epoch_time = math.floor(os.time() * 1000)
	local mock_entry = profile_store[key]
	local mock_entry_was_nil = false

	if mock_entry == nil then
		mock_entry_was_nil = true
		if is_get_call ~= true then
			mock_entry = {
				Data = nil,
				CreatedTime = epoch_time,
				UpdatedTime = epoch_time,
				VersionId = 0,
				UserIds = {},
				MetaData = {},
			}
			profile_store[key] = mock_entry
		end
	end

	local mock_key_info = mock_entry_was_nil == false and NewMockDataStoreKeyInfo(mock_entry) or nil

	local transform, user_ids, roblox_meta_data = transform_function(mock_entry and mock_entry.Data, mock_key_info)

	if transform == nil then
		return nil
	else
		if mock_entry ~= nil and is_get_call ~= true then
			mock_entry.Data = DeepCopyTable(transform)
			mock_entry.UserIds = DeepCopyTable(user_ids or {})
			mock_entry.MetaData = DeepCopyTable(roblox_meta_data or {})
			mock_entry.VersionId += 1
			mock_entry.UpdatedTime = epoch_time
		end

		return DeepCopyTable(transform), mock_entry ~= nil and NewMockDataStoreKeyInfo(mock_entry) or nil
	end

end

local function UpdateAsync(profile_store, profile_key, transform_params, is_user_mock, is_get_call, version) --> loaded_data, key_info
	--transform_params = {
	--	ExistingProfileHandle = function(latest_data),
	--	MissingProfileHandle = function(latest_data),
	--	EditProfile = function(latest_data),
	--}

	local loaded_data, key_info

	local next_in_queue = WaitInUpdateQueue(SessionToken(profile_store.Name, profile_key, is_user_mock))

	local success = true

	local success, error_message = pcall(function()
		local transform_function = function(latest_data)

			local missing_profile = false
			local overwritten = false
			local global_updates = {0, {}}

			if latest_data == nil then

				missing_profile = true

			elseif type(latest_data) ~= "table" then

				missing_profile = true
				overwritten = true

			else

				if type(latest_data.Data) == "table" and type(latest_data.MetaData) == "table" and type(latest_data.GlobalUpdates) == "table" then

					-- Regular profile structure detected:

					latest_data.WasOverwritten = false -- Must be set to false if set previously
					global_updates = latest_data.GlobalUpdates

					if transform_params.ExistingProfileHandle ~= nil then
						transform_params.ExistingProfileHandle(latest_data)
					end

				elseif latest_data.Data == nil and latest_data.MetaData == nil and type(latest_data.GlobalUpdates) == "table" then

					-- Regular structure not detected, but GlobalUpdate data exists:

					latest_data.WasOverwritten = false -- Must be set to false if set previously
					global_updates = latest_data.GlobalUpdates or global_updates
					missing_profile = true

				else

					missing_profile = true
					overwritten = true

				end

			end

			-- Profile was not created or corrupted and no GlobalUpdate data exists:
			if missing_profile == true then
				latest_data = {
					-- Data = nil,
					-- MetaData = nil,
					GlobalUpdates = global_updates,
				}
				if transform_params.MissingProfileHandle ~= nil then
					transform_params.MissingProfileHandle(latest_data)
				end
			end

			-- Editing profile:
			if transform_params.EditProfile ~= nil then
				transform_params.EditProfile(latest_data)
			end

			-- Invalid data handling (Silently override with empty profile)
			if overwritten == true then
				latest_data.WasOverwritten = true -- Temporary tag that will be removed on first save
			end

			return latest_data, latest_data.UserIds, latest_data.RobloxMetaData
		end

		if is_user_mock == true then -- Used when the profile is accessed through ProfileStore.Mock

			loaded_data, key_info = MockUpdateAsync(UserMockStore, profile_store.Name, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield

		elseif DataStoreState ~= "Access" then -- Used when API access is disabled

			loaded_data, key_info = MockUpdateAsync(MockStore, profile_store.Name, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield

		else

			if is_get_call == true then

				if version ~= nil then

					local success, error_message = pcall(function()
						loaded_data, key_info = profile_store.data_store:GetVersionAsync(profile_key, version)
					end)

					if success == false and type(error_message) == "string" and string.find(error_message, "not valid") ~= nil then
						warn(`[{script.Name}]: Passed version argument is not valid; Traceback:\n` .. debug.traceback())
					end

				else

					loaded_data, key_info = profile_store.data_store:GetAsync(profile_key)

				end

				loaded_data = transform_function(loaded_data)

			else

				loaded_data, key_info = profile_store.data_store:UpdateAsync(profile_key, transform_function)

			end

		end

	end)

	next_in_queue()

	if success == true and type(loaded_data) == "table" then
		-- Invalid data handling:
		if loaded_data.WasOverwritten == true and is_get_call ~= true then
			RegisterOverwrite(
				profile_store.Name,
				profile_key
			)
		end
		-- Return loaded_data:
		return loaded_data, key_info
	else
		-- Error handling:
		RegisterError(
			error_message or "Undefined error",
			profile_store.Name,
			profile_key
		)
		-- Return nothing:
		return nil
	end

end

local function IsThisSession(session_tag)
	return session_tag[1] == PlaceId and session_tag[2] == JobId
end

local function ReadMockFlag(): boolean
	local is_mock = MockFlag
	MockFlag = false
	return is_mock
end

local function WaitForStoreReady(profile_store)
	while profile_store.is_ready == false do
		task.wait()
	end
end

local function AddProfileToAutoSave(profile)

	ActiveSessionCheck[profile.session_token] = profile

	-- Add at AutoSaveIndex and move AutoSaveIndex right:

	table.insert(AutoSaveList, AutoSaveIndex, profile)

	if #AutoSaveList > 1 then
		AutoSaveIndex = AutoSaveIndex + 1
	elseif #AutoSaveList == 1 then
		-- First profile created - make sure it doesn't get immediately auto saved:
		LastAutoSave = os.clock()
	end

end

local function RemoveProfileFromAutoSave(profile)

	ActiveSessionCheck[profile.session_token] = nil

	local auto_save_index = table.find(AutoSaveList, profile)

	if auto_save_index ~= nil then
		table.remove(AutoSaveList, auto_save_index)
		if auto_save_index < AutoSaveIndex then
			AutoSaveIndex = AutoSaveIndex - 1 -- Table contents were moved left before AutoSaveIndex so move AutoSaveIndex left as well
		end
		if AutoSaveList[AutoSaveIndex] == nil then -- AutoSaveIndex was at the end of the AutoSaveList - reset to 1
			AutoSaveIndex = 1
		end
	end

end

local function SaveProfileAsync(profile, is_ending_session, is_overwriting, last_save_reason)

	if type(profile.Data) ~= "table" then
		error(`[{script.Name}]: Developer code likely set "Profile.Data" to a non-table value! (STORE:{profile.ProfileStore.Name}; KEY:{profile.Key})`)
	end

	profile.OnSave:Fire()
	if is_ending_session == true then
		profile.OnLastSave:Fire(last_save_reason or "Manual")
	end

	if is_ending_session == true and is_overwriting ~= true then
		if profile.roblox_message_subscription ~= nil then
			profile.roblox_message_subscription:Disconnect()
		end
		RemoveProfileFromAutoSave(profile)
		profile.OnSessionEnd:Fire()
	end

	ActiveProfileSaveJobs = ActiveProfileSaveJobs + 1

	-- Compare "SessionLoadCount" when writing to profile to prevent a rare case of repeat last save when the profile is loaded on the same server again

	local repeat_save_flag = true -- Released Profile save calls have to repeat until they succeed
	local exp_backoff = 1

	while repeat_save_flag == true do

		if is_ending_session ~= true then
			repeat_save_flag = false
		end

		local loaded_data, key_info = UpdateAsync(
			profile.ProfileStore,
			profile.Key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)

					-- Check if this session still owns the profile:

					local session_owns_profile = false

					if is_overwriting ~= true then

						local active_session = latest_data.MetaData.ActiveSession
						local session_load_count = latest_data.MetaData.SessionLoadCount

						if type(active_session) == "table" then
							session_owns_profile = IsThisSession(active_session) and session_load_count == profile.load_index
						end

					else
						session_owns_profile = true
					end

					-- We may only edit the profile if this server has ownership of the profile:

					if session_owns_profile == true then

						-- Clear processed updates (messages):

						local locked_updates = profile.locked_global_updates -- [index] = true, ...
						local active_updates = latest_data.GlobalUpdates[2]
						-- ProfileService module format: {{update_id, version_id, update_locked, update_data}, ...}
						-- ProfileStore module format: {{update_id, update_data}, ...}

						if next(locked_updates) ~= nil then
							local i = 1
							while i <= #active_updates do
								local update = active_updates[i]
								if locked_updates[update[1]] == true then
									table.remove(active_updates, i)
								else
									i += 1
								end
							end
						end

						-- Save profile data:

						latest_data.Data = profile.Data
						latest_data.RobloxMetaData = profile.RobloxMetaData
						latest_data.UserIds = profile.UserIds

						if is_overwriting ~= true then

							latest_data.MetaData.LastUpdate = os.time()

							if is_ending_session == true then
								latest_data.MetaData.ActiveSession = nil
							end

						else

							latest_data.MetaData.ActiveSession = nil
							latest_data.MetaData.ForceLoadSession = nil

						end

					end

				end,
			},
			profile.is_mock
		)

		if loaded_data ~= nil and key_info ~= nil then

			if is_overwriting == true then
				break
			end

			repeat_save_flag = false

			local active_session = loaded_data.MetaData.ActiveSession
			local session_load_count = loaded_data.MetaData.SessionLoadCount
			local session_owns_profile = false

			if type(active_session) == "table" then
				session_owns_profile = IsThisSession(active_session) and session_load_count == profile.load_index
			end

			local force_load_session = loaded_data.MetaData.ForceLoadSession
			local force_load_pending = false
			if type(force_load_session) == "table" then
				force_load_pending = not IsThisSession(force_load_session)
			end

			local is_active = profile:IsActive()

			-- If another server is trying to start a session for this profile - end the session:

			if force_load_pending == true and session_owns_profile == true then
				if is_active == true then
					SaveProfileAsync(profile, true, false, "External")
				end
				break
			end

			-- Clearing processed update list / Detecting new updates:

			local locked_updates = profile.locked_global_updates -- [index] = true, ...
			local received_updates = profile.received_global_updates -- [index] = true, ...
			local active_updates = loaded_data.GlobalUpdates[2]

			local new_updates = {} -- {}, ...
			local still_pending = {} -- [index] = true, ...

			for _, update in ipairs(active_updates) do
				if locked_updates[update[1]] == true then
					still_pending[update[1]] = true
				elseif received_updates[update[1]] ~= true then
					received_updates[update[1]] = true
					table.insert(new_updates, update)
				end
			end

			for index in pairs(locked_updates) do
				if still_pending[index] ~= true then
					locked_updates[index] = nil
				end
			end

			-- Updating profile values:

			profile.KeyInfo = key_info
			profile.LastSavedData = loaded_data.Data
			profile.global_updates = loaded_data.GlobalUpdates and loaded_data.GlobalUpdates[2] or {}

			if session_owns_profile == true then
				if is_active == true and is_ending_session ~= true then

					-- Processing new global updates (messages):

					for _, update in ipairs(new_updates) do

						local index = update[1]
						local update_data = update[#update] -- Backwards compatibility with ProfileService

						for _, handler in ipairs(profile.message_handlers) do

							local is_processed = false
							local processed_callback = function()
								is_processed = true
								locked_updates[index] = true
							end

							local send_update_data = DeepCopyTable(update_data)

							task.spawn(handler, send_update_data, processed_callback)

							if is_processed == true then
								break
							end

						end

					end

				end
			else

				if profile.roblox_message_subscription ~= nil then
					profile.roblox_message_subscription:Disconnect()
				end

				if is_active == true then
					RemoveProfileFromAutoSave(profile)
					profile.OnSessionEnd:Fire()
				end

			end

			profile.OnAfterSave:Fire(profile.LastSavedData)

		elseif repeat_save_flag == true then

			-- DataStore call likely resulted in an error; Repeat the DataStore call shortly
			task.wait(exp_backoff)
			exp_backoff = math.min(if last_save_reason == "Shutdown" then 8 else 20, exp_backoff * 2)

		end

	end

	ActiveProfileSaveJobs = ActiveProfileSaveJobs - 1

end

----- Public -----

--[[
	Saved profile structure:
	
	{
		Data = {},
		
		MetaData = {
			ProfileCreateTime = 0,
			SessionLoadCount = 0,
			ActiveSession = {place_id, game_job_id, unique_session_id} / nil,
			ForceLoadSession = {place_id, game_job_id} / nil,
			LastUpdate = 0, -- os.time()
			MetaTags = {}, -- Backwards compatibility with ProfileService
		},
		
		RobloxMetaData = {},
		UserIds = {},
		
		GlobalUpdates = {
			update_index,
			{
				{update_index, data}, ...
			},
		},
	}

--]]

export type JSONAcceptable = { JSONAcceptable } | { [string]: JSONAcceptable } | number | string | boolean | buffer

export type Profile<T> = {
	Data: T & JSONAcceptable,
	LastSavedData: T & JSONAcceptable,
	FirstSessionTime: number,
	SessionLoadCount: number,
	Session: {PlaceId: number, JobId: string}?,
	RobloxMetaData: JSONAcceptable,
	UserIds: {number},
	KeyInfo: DataStoreKeyInfo,
	OnSave: {Connect: (self: any, listener: () -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnLastSave: {Connect: (self: any, listener: (reason: "Manual" | "External" | "Shutdown") -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnSessionEnd: {Connect: (self: any, listener: () -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnAfterSave: {Connect: (self: any, listener: (last_saved_data: T & JSONAcceptable) -> ()) -> ({Disconnect: (self: any) -> ()})},
	ProfileStore: JSONAcceptable,
	Key: string,

	IsActive: (self: any) -> (boolean),
	Reconcile: (self: any) -> (),
	EndSession: (self: any) -> (),
	AddUserId: (self: any, user_id: number) -> (),
	RemoveUserId: (self: any, user_id: number) -> (),
	MessageHandler: (self: any, fn: (message: JSONAcceptable, processed: () -> ()) -> ()) -> (),
	Save: (self: any) -> (),
	SetAsync: (self: any) -> (),
}

export type VersionQuery<T> = {
	NextAsync: (self: any) -> (Profile<T>?),
}

type ProfileStoreStandard<T> = {
	Name: string,
	StartSessionAsync: (self: any, profile_key: string, params: {Steal: boolean?}) -> (Profile<T>?),
	MessageAsync: (self: any, profile_key: string, message: JSONAcceptable) -> (boolean),
	GetAsync: (self: any, profile_key: string, version: string?) -> (Profile<T>?),
	VersionQuery: (self: any, profile_key: string, sort_direction: Enum.SortDirection?, min_date: DateTime | number | nil, max_date: DateTime | number | nil) -> (VersionQuery<T>),
	RemoveAsync: (self: any, profile_key: string) -> (boolean),
}

export type ProfileStore<T> = {
	Mock: ProfileStoreStandard<T>,
} & ProfileStoreStandard<T>

type ConstantName = "AUTO_SAVE_PERIOD" | "LOAD_REPEAT_PERIOD" | "FIRST_LOAD_REPEAT" | "SESSION_STEAL"
| "ASSUME_DEAD" | "START_SESSION_TIMEOUT" | "CRITICAL_STATE_ERROR_COUNT" | "CRITICAL_STATE_ERROR_EXPIRE"
| "CRITICAL_STATE_EXPIRE" | "MAX_MESSAGE_QUEUE"

export type ProfileStoreModule = {
	IsClosing: boolean,
	IsCriticalState: boolean,
	OnError: {Connect: (self: any, listener: (message: string, store_name: string, profile_key: string) -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnOverwrite: {Connect: (self: any, listener: (store_name: string, profile_key: string) -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnCriticalToggle: {Connect: (self: any, listener: (is_critical: boolean) -> ()) -> ({Disconnect: (self: any) -> ()})},
	DataStoreState: "NotReady" | "NoInternet" | "NoAccess" | "Access",
	New: <T>(store_name: string, template: (T & JSONAcceptable)?) -> (ProfileStore<T>),
	SetConstant: (name: ConstantName, value: number) -> ()
}

local Profile = {}
Profile.__index = Profile

function Profile.New(raw_data, key_info, profile_store, key, is_mock, session_token)

	local data = raw_data.Data or {}
	local session = raw_data.MetaData and raw_data.MetaData.ActiveSession or nil

	local global_updates = raw_data.GlobalUpdates and raw_data.GlobalUpdates[2] or {}
	local received_global_updates = {}

	for _, update in ipairs(global_updates) do
		received_global_updates[update[1]] = true
	end

	local self = {

		Data = data,
		LastSavedData = DeepCopyTable(data),

		FirstSessionTime = raw_data.MetaData and raw_data.MetaData.ProfileCreateTime or 0,
		SessionLoadCount = raw_data.MetaData and raw_data.MetaData.SessionLoadCount or 0,
		Session = session and {PlaceId = session[1], JobId = session[2]},

		RobloxMetaData = raw_data.RobloxMetaData or {},
		UserIds = raw_data.UserIds or {},
		KeyInfo = key_info,

		OnAfterSave = Signal.New(),
		OnSave = Signal.New(),
		OnLastSave = Signal.New(),
		OnSessionEnd = Signal.New(),

		ProfileStore = profile_store,
		Key = key,

		load_timestamp = os.clock(),
		is_mock = is_mock,
		session_token = session_token or "",
		load_index = raw_data.MetaData and raw_data.MetaData.SessionLoadCount or 0,
		locked_global_updates = {},
		received_global_updates = received_global_updates,
		message_handlers = {},
		global_updates = global_updates,

	}
	setmetatable(self, Profile)

	return self

end

function Profile:IsActive()
	return ActiveSessionCheck[self.session_token] == self
end

function Profile:Reconcile()
	ReconcileTable(self.Data, self.ProfileStore.template)
end

function Profile:EndSession()
	if self:IsActive() == true then
		task.spawn(SaveProfileAsync, self, true, nil, "Manual") -- Call save function in a new thread with release_from_session = true
	end
end

function Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)

	if type(user_id) ~= "number" or user_id % 1 ~= 0 then
		warn(`[{script.Name}]: Invalid UserId argument for :AddUserId() ({tostring(user_id)}); Traceback:\n` .. debug.traceback())
		return
	end

	if user_id < 0 and self.is_mock ~= true and DataStoreState == "Access" then
		return -- Avoid giving real Roblox APIs negative UserId's
	end

	if table.find(self.UserIds, user_id) == nil then
		table.insert(self.UserIds, user_id)
	end

end

function Profile:RemoveUserId(user_id) -- Removes user_id association with profile (safe function)

	if type(user_id) ~= "number" or user_id % 1 ~= 0 then
		warn(`[{script.Name}]: Invalid UserId argument for :RemoveUserId() ({tostring(user_id)}); Traceback:\n` .. debug.traceback())
		return
	end

	local index = table.find(self.UserIds, user_id)

	if index ~= nil then
		table.remove(self.UserIds, index)
	end

end

function Profile:SetAsync() -- Saves the profile to the DataStore and removes the session lock

	if self.view_mode ~= true then
		error(`[{script.Name}]: :SetAsync() can only be used in view mode`)
	end

	SaveProfileAsync(self, nil, true)

end

function Profile:MessageHandler(fn)

	if type(fn) ~= "function" then
		error(`[{script.Name}]: fn argument is not a function`)
	end

	if self.view_mode ~= true and self:IsActive() ~= true then
		return -- Don't process messages if the profile session was ended
	end

	local locked_updates = self.locked_global_updates
	table.insert(self.message_handlers, fn)

	for _, update in ipairs(self.global_updates) do

		local index = update[1]
		local update_data = update[#update] -- Backwards compatibility with ProfileService

		if locked_updates[index] ~= true then

			local processed_callback = function()
				locked_updates[index] = true
			end

			local send_update_data = DeepCopyTable(update_data)

			task.spawn(fn, send_update_data, processed_callback)

		end

	end

end

function Profile:Save()

	if self.view_mode == true then
		error(`[{script.Name}]: Can't save profile in view mode; Should you be calling :SetAsync() instead?`)
	end

	if self:IsActive() == false then
		warn(`[{script.Name}]: Attempted saving an inactive profile (STORE:{self.ProfileStore.Name}; KEY:{self.Key});`
			.. ` Traceback:\n` .. debug.traceback())
		return
	end

	-- Move the profile right behind the auto save index to delay the next auto save for it:
	RemoveProfileFromAutoSave(self)
	AddProfileToAutoSave(self)

	-- Perform save in new thread:
	task.spawn(SaveProfileAsync, self)

end

local ProfileStore: ProfileStoreModule = {

	IsClosing = false,
	IsCriticalState = false,
	OnError = OnError, -- (message, store_name, profile_key)
	OnOverwrite = OnOverwrite, -- (store_name, profile_key)
	OnCriticalToggle = Signal.New(), -- (is_critical)
	DataStoreState = "NotReady", -- ("NotReady", "NoInternet", "NoAccess", "Access")

}
ProfileStore.__index = ProfileStore

function ProfileStore.SetConstant(name, value)

	if type(value) ~= "number" then
		error(`[{script.Name}]: Invalid value type`)
	end

	if name == "AUTO_SAVE_PERIOD" then
		AUTO_SAVE_PERIOD = value
	elseif name == "LOAD_REPEAT_PERIOD" then
		LOAD_REPEAT_PERIOD = value
	elseif name == "FIRST_LOAD_REPEAT" then
		FIRST_LOAD_REPEAT = value
	elseif name == "SESSION_STEAL" then
		SESSION_STEAL = value
	elseif name == "ASSUME_DEAD" then
		ASSUME_DEAD = value
	elseif name == "START_SESSION_TIMEOUT" then
		START_SESSION_TIMEOUT = value
	elseif name == "CRITICAL_STATE_ERROR_COUNT" then
		CRITICAL_STATE_ERROR_COUNT = value
	elseif name == "CRITICAL_STATE_ERROR_EXPIRE" then
		CRITICAL_STATE_ERROR_EXPIRE = value
	elseif name == "CRITICAL_STATE_EXPIRE" then
		CRITICAL_STATE_EXPIRE = value
	elseif name == "MAX_MESSAGE_QUEUE" then
		MAX_MESSAGE_QUEUE = value
	else
		error(`[{script.Name}]: Invalid constant name was provided`)
	end

end

function ProfileStore.Test()
	return {
		ActiveSessionCheck = ActiveSessionCheck,
		AutoSaveList = AutoSaveList,
		ActiveProfileLoadJobs = ActiveProfileLoadJobs,
		ActiveProfileSaveJobs = ActiveProfileSaveJobs,
		MockStore = MockStore,
		UserMockStore = UserMockStore,
		UpdateQueue = UpdateQueue,
	}
end

function ProfileStore.New(store_name, template)

	template = template or {}

	if type(store_name) ~= "string" then
		error(`[{script.Name}]: Invalid or missing "store_name"`)
	elseif string.len(store_name) == 0 then
		error(`[{script.Name}]: store_name cannot be an empty string`)
	elseif string.len(store_name) > 50 then
		error(`[{script.Name}]: store_name is too long`)
	end

	if type(template) ~= "table" then
		error(`[{script.Name}]: Invalid template argument`)
	end

	local self
	self = {

		Mock = {

			Name = store_name,

			StartSessionAsync = function(_, profile_key)
				MockFlag = true
				return self:StartSessionAsync(profile_key)
			end,
			MessageAsync = function(_, profile_key, message)
				MockFlag = true
				return self:MessageAsync(profile_key, message)
			end,
			GetAsync = function(_, profile_key, version)
				MockFlag = true
				return self:GetAsync(profile_key, version)
			end,
			VersionQuery = function(_, profile_key, sort_direction, min_date, max_date)
				MockFlag = true
				return self:VersionQuery(profile_key, sort_direction, min_date, max_date)
			end,
			RemoveAsync = function(_, profile_key)
				MockFlag = true
				return self:RemoveAsync(profile_key)
			end
		},

		Name = store_name,

		template = template,
		data_store = nil,
		load_jobs = {},
		mock_load_jobs = {},
		is_ready = true,

	}
	setmetatable(self, ProfileStore)

	local options = Instance.new("DataStoreOptions")
	options:SetExperimentalFeatures({v2 = true})

	if DataStoreState == "NotReady" then

		-- The module is not sure whether DataStores are accessible yet:

		self.is_ready = false

		task.spawn(function()

			repeat task.wait() until DataStoreState ~= "NotReady"

			if DataStoreState == "Access" then
				self.data_store = DataStoreService:GetDataStore(store_name, nil, options)
			end

			self.is_ready = true

		end)

	elseif DataStoreState == "Access" then

		self.data_store = DataStoreService:GetDataStore(store_name, nil, options)

	end

	return self

end

local function RobloxMessageSubscription(profile, unique_session_id)

	local last_roblox_message = 0

	local roblox_message_subscription = MessagingService:SubscribeAsync("PS_" .. unique_session_id, function(message)
		if type(message.Data) == "table" and message.Data.LoadCount == profile.SessionLoadCount then
			-- High reaction rate, based on numPlayers Ã— 10 DataStore budget as of writing
			if os.clock() - last_roblox_message > 6 then 
				last_roblox_message = os.clock()
				if profile:IsActive() == true then
					if message.Data.EndSession == true then
						SaveProfileAsync(profile, true, false, "External")
					else
						profile:Save()
					end
				end
			end
		end
	end)

	if profile:IsActive() == true then
		profile.roblox_message_subscription = roblox_message_subscription
	else
		roblox_message_subscription:Disconnect()
	end

end

function ProfileStore:StartSessionAsync(profile_key, params)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" then
		error(`[{script.Name}]: profile_key must be a string`)
	elseif string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	elseif string.len(profile_key) > 50 then
		error(`[{script.Name}]: profile_key is too long`)
	end

	if params ~= nil and type(params) ~= "table" then
		error(`[{script.Name}]: Invalid params`)
	end

	params = params or {}

	if ProfileStore.IsClosing == true then
		return nil
	end

	WaitForStoreReady(self)

	local session_token = SessionToken(self.Name, profile_key, is_mock)

	if ActiveSessionCheck[session_token] ~= nil then
		error(`[{script.Name}]: Profile (STORE:{self.Name}; KEY:{profile_key}) is already loaded in this session`)
	end

	ActiveProfileLoadJobs = ActiveProfileLoadJobs + 1

	local is_user_cancel = false

	local function cancel_condition()
		if is_user_cancel == false then
			if params.Cancel ~= nil then
				is_user_cancel = params.Cancel() == true
			end
			return is_user_cancel
		end
		return true
	end

	local user_steal = params.Steal == true

	local force_load_steps = 0 -- Session conflict handling values
	local request_force_load = true
	local steal_session = false

	local start = os.clock()
	local exp_backoff = 1

	while ProfileStore.IsClosing == false and cancel_condition() == false do

		-- Load profile:

		-- SPECIAL CASE - If StartSessionAsync is called for the same key again before another StartSessionAsync finishes,
		-- grab the DataStore return for the new call. The early call will return nil. This is supposed to retain
		-- expected and efficient behavior in cases where a player would quickly rejoin the same server.

		LoadIndex += 1
		local load_id = LoadIndex
		local profile_load_jobs = is_mock == true and self.mock_load_jobs or self.load_jobs
		local profile_load_job = profile_load_jobs[profile_key] -- {load_id, {loaded_data, key_info} or nil}

		local loaded_data, key_info
		local unique_session_id = HttpService:GenerateGUID(false)

		if profile_load_job ~= nil then

			profile_load_job[1] = load_id -- Steal load job
			while profile_load_job[2] == nil do -- Wait for job to finish
				task.wait()
			end
			if profile_load_job[1] == load_id then -- Load job hasn't been double-stolen
				loaded_data, key_info = table.unpack(profile_load_job[2])
				profile_load_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil
			end

		else

			profile_load_job = {load_id, nil}
			profile_load_jobs[profile_key] = profile_load_job

			profile_load_job[2] = table.pack(UpdateAsync(
				self,
				profile_key,
				{
					ExistingProfileHandle = function(latest_data)

						if ProfileStore.IsClosing == true or cancel_condition() == true then
							return
						end

						local active_session = latest_data.MetaData.ActiveSession
						local force_load_session = latest_data.MetaData.ForceLoadSession

						if active_session == nil then
							latest_data.MetaData.ActiveSession = {PlaceId, JobId, unique_session_id}
							latest_data.MetaData.ForceLoadSession = nil
						elseif type(active_session) == "table" then
							if IsThisSession(active_session) == false then
								local last_update = latest_data.MetaData.LastUpdate
								if last_update ~= nil then
									if os.time() - last_update > ASSUME_DEAD then
										latest_data.MetaData.ActiveSession = {PlaceId, JobId, unique_session_id}
										latest_data.MetaData.ForceLoadSession = nil
										return
									end
								end
								if steal_session == true or user_steal == true then
									local force_load_interrupted = if force_load_session ~= nil then not IsThisSession(force_load_session) else true
									if force_load_interrupted == false or user_steal == true then
										latest_data.MetaData.ActiveSession = {PlaceId, JobId, unique_session_id}
										latest_data.MetaData.ForceLoadSession = nil
									end
								elseif request_force_load == true then
									latest_data.MetaData.ForceLoadSession = {PlaceId, JobId}
								end
							else
								latest_data.MetaData.ForceLoadSession = nil
							end
						end

					end,
					MissingProfileHandle = function(latest_data)

						local is_cancel = ProfileStore.IsClosing == true or cancel_condition() == true

						latest_data.Data = DeepCopyTable(self.template)
						latest_data.MetaData = {
							ProfileCreateTime = os.time(),
							SessionLoadCount = 0,
							ActiveSession = if is_cancel == false then {PlaceId, JobId, unique_session_id} else nil,
							ForceLoadSession = nil,
							MetaTags = {}, -- Backwards compatibility with ProfileService
						}

					end,
					EditProfile = function(latest_data)

						if ProfileStore.IsClosing == true or cancel_condition() == true then
							return
						end

						local active_session = latest_data.MetaData.ActiveSession
						if active_session ~= nil and IsThisSession(active_session) == true then
							latest_data.MetaData.SessionLoadCount = latest_data.MetaData.SessionLoadCount + 1
							latest_data.MetaData.LastUpdate = os.time()
						end

					end,
				},
				is_mock
				))
			if profile_load_job[1] == load_id then -- Load job hasn't been stolen
				loaded_data, key_info = table.unpack(profile_load_job[2])
				profile_load_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- Load job stolen
			end
		end

		-- Handle load_data:

		if loaded_data ~= nil and key_info ~= nil then
			local active_session = loaded_data.MetaData.ActiveSession
			if type(active_session) == "table" then

				if IsThisSession(active_session) == true then

					-- Profile is now taken by this session:

					local profile = Profile.New(loaded_data, key_info, self, profile_key, is_mock, session_token)
					AddProfileToAutoSave(profile)

					if is_mock ~= true and DataStoreState == "Access" then

						-- Use MessagingService to quickly detect session conflicts and resolve them quickly:
						task.spawn(RobloxMessageSubscription, profile, unique_session_id) -- Blocking prevention

					end

					if ProfileStore.IsClosing == true or cancel_condition() == true then
						-- The server has initiated a shutdown by the time this profile was loaded
						SaveProfileAsync(profile, true) -- Release profile and yield until the DataStore call is finished
						profile = nil -- Don't return the profile object
					end

					ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
					return profile

				else

					if ProfileStore.IsClosing == true or cancel_condition() == true then
						ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
						return nil
					end

					-- Profile is taken by some other session:

					local force_load_session = loaded_data.MetaData.ForceLoadSession
					local force_load_interrupted = if force_load_session ~= nil then not IsThisSession(force_load_session) else true

					if force_load_interrupted == false then

						if request_force_load == false then
							force_load_steps = force_load_steps + 1
							if force_load_steps >= math.ceil(SESSION_STEAL / LOAD_REPEAT_PERIOD) then
								steal_session = true
							end
						end

						-- Request the remote server to end its session:
						if type(active_session[3]) == "string" then
							local session_load_count = loaded_data.MetaData.SessionLoadCount or 0
							task.spawn(MessagingService.PublishAsync, MessagingService, "PS_" .. active_session[3], {LoadCount = session_load_count, EndSession = true})
						end

						-- Attempt to load the profile again after a delay
						local wait_until = os.clock() + if request_force_load == true then FIRST_LOAD_REPEAT else LOAD_REPEAT_PERIOD
						repeat task.wait() until os.clock() >= wait_until or ProfileStore.IsClosing == true

					else
						-- Another session tried to load this profile:
						ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
						return nil
					end

					request_force_load = false -- Only request a force load once

				end

			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- In this scenario it is likely that this server started shutting down
			end
		else

			-- A DataStore call has likely ended in an error:

			local default_timeout = false

			if params.Cancel == nil then
				default_timeout = os.clock() - start >= START_SESSION_TIMEOUT
			end

			if default_timeout == true or ProfileStore.IsClosing == true or cancel_condition() == true then
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil
			end

			task.wait(exp_backoff)  -- Repeat the call shortly
			exp_backoff = math.min(20, exp_backoff * 2)

		end

	end

	ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
	return nil -- Game started shutting down or the request was cancelled - don't return the profile

end

function ProfileStore:MessageAsync(profile_key, message)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" then
		error(`[{script.Name}]: profile_key must be a string`)
	elseif string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	elseif string.len(profile_key) > 50 then
		error(`[{script.Name}]: profile_key is too long`)
	end

	if type(message) ~= "table" then
		error(`[{script.Name}]: message must be a table`)
	end

	if ProfileStore.IsClosing == true then
		return false
	end

	WaitForStoreReady(self)

	local exp_backoff = 1

	while ProfileStore.IsClosing == false do

		-- Updating profile:

		local loaded_data = UpdateAsync(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)

					local global_updates = latest_data.GlobalUpdates
					local update_list = global_updates[2]
					--{
					--	update_index,
					--	{
					--		{update_index, data}, ...
					--	},
					--},

					global_updates[1] += 1
					table.insert(update_list, {global_updates[1], message})

					-- Clearing queue if above limit:

					while #update_list > MAX_MESSAGE_QUEUE do
						table.remove(update_list, 1)
					end

				end,
			},
			is_mock
		)

		if loaded_data ~= nil then

			local session_token = SessionToken(self.Name, profile_key, is_mock)

			local profile = ActiveSessionCheck[session_token]

			if profile ~= nil then

				-- The message was sent to a profile that is active in this server:
				profile:Save()

			else

				local meta_data = loaded_data.MetaData or {}
				local active_session = meta_data.ActiveSession
				local session_load_count = meta_data.SessionLoadCount or 0

				if type(active_session) == "table" and type(active_session[3]) == "string" then
					-- Request the remote server to auto-save sooner and receive the message:
					task.spawn(MessagingService.PublishAsync, MessagingService, "PS_" .. active_session[3], {LoadCount = session_load_count})
				end

			end

			return true

		else

			task.wait(exp_backoff) -- A DataStore call has likely ended in an error - repeat the call shortly
			exp_backoff = math.min(20, exp_backoff * 2)

		end

	end

	return false

end

function ProfileStore:GetAsync(profile_key, version)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" then
		error(`[{script.Name}]: profile_key must be a string`)
	elseif string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	elseif string.len(profile_key) > 50 then
		error(`[{script.Name}]: profile_key is too long`)
	end

	if ProfileStore.IsClosing == true then
		return nil
	end

	WaitForStoreReady(self)

	if version ~= nil and (is_mock or DataStoreState ~= "Access") then
		return nil -- No version support in mock mode
	end

	local exp_backoff = 1

	while ProfileStore.IsClosing == false do

		-- Load profile:

		local loaded_data, key_info = UpdateAsync(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = function(latest_data)

					latest_data.Data = DeepCopyTable(self.template)
					latest_data.MetaData = {
						ProfileCreateTime = os.time(),
						SessionLoadCount = 0,
						ActiveSession = nil,
						ForceLoadSession = nil,
						MetaTags = {}, -- Backwards compatibility with ProfileService
					}

				end,
				EditProfile = nil,
			},
			is_mock,
			true, -- Use :GetAsync()
			version -- DataStore key version
		)

		-- Handle load_data:

		if loaded_data ~= nil then

			if key_info == nil then
				return nil -- Load was successful, but the key was empty - return no profile object
			end

			local profile = Profile.New(loaded_data, key_info, self, profile_key, is_mock)
			profile.view_mode = true

			return profile

		else

			task.wait(exp_backoff) -- A DataStore call has likely ended in an error - repeat the call shortly
			exp_backoff = math.min(20, exp_backoff * 2)

		end

	end

	return nil -- Game started shutting down - don't return the profile

end

function ProfileStore:RemoveAsync(profile_key)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	end

	if ProfileStore.IsClosing == true then
		return false
	end

	WaitForStoreReady(self)

	local wipe_status = false

	local next_in_queue = WaitInUpdateQueue(SessionToken(self.Name, profile_key, is_mock))

	if is_mock == true then -- Used when the profile is accessed through ProfileStore.Mock

		local mock_data_store = UserMockStore[self.Name]

		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
			if next(mock_data_store) == nil then
				UserMockStore[self.Name] = nil
			end
		end

		wipe_status = true
		task.wait() -- Simulate API call yield

	elseif DataStoreState ~= "Access" then -- Used when API access is disabled

		local mock_data_store = MockStore[self.Name]

		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
			if next(mock_data_store) == nil then
				MockStore[self.Name] = nil
			end
		end

		wipe_status = true
		task.wait() -- Simulate API call yield

	else -- Live DataStore

		wipe_status = pcall(function()
			self.data_store:RemoveAsync(profile_key)
		end)

	end

	next_in_queue()

	return wipe_status

end

local ProfileVersionQuery = {}
ProfileVersionQuery.__index = ProfileVersionQuery

function ProfileVersionQuery.New(profile_store, profile_key, sort_direction, min_date, max_date, is_mock)

	local self = {
		profile_store = profile_store,
		profile_key = profile_key,
		sort_direction = sort_direction,
		min_date = min_date,
		max_date = max_date,

		query_pages = nil,
		query_index = 0,
		query_failure = false,

		is_query_yielded = false,
		query_queue = {},

		is_mock = is_mock,
	}
	setmetatable(self, ProfileVersionQuery)

	return self

end

function MoveVersionQueryQueue(self) -- Hidden ProfileVersionQuery method
	while #self.query_queue > 0 do

		local queue_entry = table.remove(self.query_queue, 1)

		task.spawn(queue_entry)

		if self.is_query_yielded == true then
			break
		end

	end
end

local VersionQueryNextAsyncStackingFlag = false
local WarnAboutVersionQueryOnce = false

function ProfileVersionQuery:NextAsync()

	local is_stacking = VersionQueryNextAsyncStackingFlag == true
	VersionQueryNextAsyncStackingFlag = false

	WaitForStoreReady(self.profile_store)

	if ProfileStore.IsClosing == true then
		return nil -- Silently fail :NextAsync() requests
	end

	if self.is_mock == true or DataStoreState ~= "Access" then
		if IsStudio == true and WarnAboutVersionQueryOnce == false then
			WarnAboutVersionQueryOnce = true
			warn(`[{script.Name}]: :VersionQuery() is not supported in mock mode!`)
		end
		return nil -- Silently fail :NextAsync() requests
	end

	local profile
	local is_finished = false

	local function query_job()

		if self.query_failure == true then
			is_finished = true
			return
		end

		-- First "next" call loads version pages:

		if self.query_pages == nil then

			self.is_query_yielded = true

			task.spawn(function()
				VersionQueryNextAsyncStackingFlag = true
				profile = self:NextAsync()
				is_finished = true
			end)

			local list_success, error_message = pcall(function()
				self.query_pages = self.profile_store.data_store:ListVersionsAsync(
					self.profile_key,
					self.sort_direction,
					self.min_date,
					self.max_date
				)
				self.query_index = 0
			end)

			if list_success == false or self.query_pages == nil then
				warn(`[{script.Name}]: Version query fail - {tostring(error_message)}`)
				self.query_failure = true
			end

			self.is_query_yielded = false

			MoveVersionQueryQueue(self)

			return

		end

		local current_page = self.query_pages:GetCurrentPage()
		local next_item = current_page[self.query_index + 1]

		-- No more entries:

		if self.query_pages.IsFinished == true and next_item == nil then
			is_finished = true
			return
		end

		-- Load next page when this page is over:

		if next_item == nil then

			self.is_query_yielded = true
			task.spawn(function()
				VersionQueryNextAsyncStackingFlag = true
				profile = self:NextAsync()
				is_finished = true
			end)

			local success, error_message = pcall(function()
				self.query_pages:AdvanceToNextPageAsync()
				self.query_index = 0
			end)

			if success == false or #self.query_pages:GetCurrentPage() == 0 then
				self.query_failure = true
			end

			self.is_query_yielded = false
			MoveVersionQueryQueue(self)

			return

		end

		-- Next page item:

		self.query_index += 1
		profile = self.profile_store:GetAsync(self.profile_key, next_item.Version)
		is_finished = true

	end

	if self.is_query_yielded == false then
		query_job()
	else
		if is_stacking == true then
			table.insert(self.query_queue, 1, query_job)
		else
			table.insert(self.query_queue, query_job)
		end
	end

	while is_finished == false do
		task.wait()
	end

	return profile

end

function ProfileStore:VersionQuery(profile_key, sort_direction, min_date, max_date)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	end

	-- Type check:

	if sort_direction ~= nil and (typeof(sort_direction) ~= "EnumItem"
		or sort_direction.EnumType ~= Enum.SortDirection) then
		error(`[{script.Name}]: Invalid sort_direction ({tostring(sort_direction)})`)
	end

	if min_date ~= nil and typeof(min_date) ~= "DateTime" and typeof(min_date) ~= "number" then
		error(`[{script.Name}]: Invalid min_date ({tostring(min_date)})`)
	end

	if max_date ~= nil and typeof(max_date) ~= "DateTime" and typeof(max_date) ~= "number" then
		error(`[{script.Name}]: Invalid max_date ({tostring(max_date)})`)
	end

	min_date = typeof(min_date) == "DateTime" and min_date.UnixTimestampMillis or min_date
	max_date = typeof(max_date) == "DateTime" and max_date.UnixTimestampMillis or max_date

	return ProfileVersionQuery.New(self, profile_key, sort_direction, min_date, max_date, is_mock)

end

-- DataStore API access check:

if IsStudio == true then

	task.spawn(function()

		local new_state = "NoAccess"

		local status, message = pcall(function()
			-- This will error if current instance has no Studio API access:
			DataStoreService:GetDataStore("____PS"):SetAsync("____PS", os.time())
		end)

		local no_internet_access = status == false and string.find(message, "ConnectFail", 1, true) ~= nil

		if no_internet_access == true then
			warn(`[{script.Name}]: No internet access - check your network connection`)
		end

		if status == false and
			(string.find(message, "403", 1, true) ~= nil or -- Cannot write to DataStore from studio if API access is not enabled
				string.find(message, "must publish", 1, true) ~= nil or -- Game must be published to access live keys
				no_internet_access == true) then -- No internet access

			new_state = if no_internet_access == true then "NoInternet" else "NoAccess"
			print(`[{script.Name}]: Roblox API services unavailable - data will not be saved`)
		else
			new_state = "Access"
			--print(`[{script.Name}]: Roblox API services available - data will be saved`)
		end

		DataStoreState = new_state
		ProfileStore.DataStoreState = new_state

	end)

else

	DataStoreState = "Access"
	ProfileStore.DataStoreState = "Access"

end

-- Update loop:

RunService.Heartbeat:Connect(function()

	-- Auto saving:

	local auto_save_list_length = #AutoSaveList
	if auto_save_list_length > 0 then
		local auto_save_index_speed = AUTO_SAVE_PERIOD / auto_save_list_length
		local os_clock = os.clock()
		while os_clock - LastAutoSave > auto_save_index_speed do
			LastAutoSave = LastAutoSave + auto_save_index_speed
			local profile = AutoSaveList[AutoSaveIndex]
			if os_clock - profile.load_timestamp < AUTO_SAVE_PERIOD / 2 then
				-- This profile is freshly loaded - auto saving immediately is not necessary:
				profile = nil
				for _ = 1, auto_save_list_length - 1 do
					-- Move auto save index to the right:
					AutoSaveIndex = AutoSaveIndex + 1
					if AutoSaveIndex > auto_save_list_length then
						AutoSaveIndex = 1
					end
					profile = AutoSaveList[AutoSaveIndex]
					if os_clock - profile.load_timestamp >= AUTO_SAVE_PERIOD / 2 then
						break
					else
						profile = nil
					end
				end
			end
			-- Move auto save index to the right:
			AutoSaveIndex = AutoSaveIndex + 1
			if AutoSaveIndex > auto_save_list_length then
				AutoSaveIndex = 1
			end
			-- Perform save call:
			if profile ~= nil then
				task.spawn(SaveProfileAsync, profile) -- Auto save profile in new thread
			end
		end
	end

	-- Critical state handling:

	if ProfileStore.IsCriticalState == false then
		if #IssueQueue >= CRITICAL_STATE_ERROR_COUNT then
			ProfileStore.IsCriticalState = true
			ProfileStore.OnCriticalToggle:Fire(true)
			CriticalStateStart = os.clock()
			warn(`[{script.Name}]: Entered critical state`)
		end
	else
		if #IssueQueue >= CRITICAL_STATE_ERROR_COUNT then
			CriticalStateStart = os.clock()
		elseif os.clock() - CriticalStateStart > CRITICAL_STATE_EXPIRE then
			ProfileStore.IsCriticalState = false
			ProfileStore.OnCriticalToggle:Fire(false)
			warn(`[{script.Name}]: Critical state ended`)
		end
	end

	-- Issue queue:

	while true do
		local issue_time = IssueQueue[1]
		if issue_time == nil then
			break
		elseif os.clock() - issue_time > CRITICAL_STATE_ERROR_EXPIRE then
			table.remove(IssueQueue, 1)
		else
			break
		end
	end

end)

-- Release all loaded profiles when the server is shutting down:

task.spawn(function()

	while DataStoreState == "NotReady" do
		task.wait()
	end

	if DataStoreState ~= "Access" then

		game:BindToClose(function()
			ProfileStore.IsClosing = true
			task.wait() -- Mock shutdown delay
		end)

		return -- Don't wait for profiles to properly save in mock mode so studio could end the simulation faster

	end

	game:BindToClose(function()

		ProfileStore.IsClosing = true

		-- Release all active profiles:
		-- (Clone AutoSaveList to a new table because AutoSaveList changes when profiles are released)

		local on_close_save_job_count = 0
		local active_profiles = {}
		for index, profile in ipairs(AutoSaveList) do
			active_profiles[index] = profile
		end

		-- Release the profiles; Releasing profiles can trigger listeners that release other profiles, so check active state:
		for _, profile in ipairs(active_profiles) do
			if profile:IsActive() == true then
				on_close_save_job_count = on_close_save_job_count + 1
				task.spawn(function() -- Save profile on new thread
					SaveProfileAsync(profile, true, nil, "Shutdown")
					on_close_save_job_count = on_close_save_job_count - 1
				end)
			end
		end

		-- Yield until all active profile jobs are finished:
		while on_close_save_job_count > 0 or ActiveProfileLoadJobs > 0 or ActiveProfileSaveJobs > 0 do
			task.wait()
		end

		return -- We're done!

	end)

end)

return ProfileStore
---

--- ServerScriptService.Modules.DataAccessor (ModuleScript) ---
--[[
    SCRIPT: DataAccessor (MODULE SCRIPT) - SIMPLIFIED
    
    Location: ServerScriptService/Modules/DataAccessor
    
    Description: Optional wrapper for profile data access.
    Optimized: Strict typing, added key get/set for convenience.
--]]
--!strict

local ServerScriptService = game:GetService("ServerScriptService")

local PlayerController = require(ServerScriptService.Controllers.PlayerController)

local DataAccessor = {}

function DataAccessor:GetData(player: Player): table?
	local profile = PlayerController:GetProfile(player)
	return profile and profile.Data
end

function DataAccessor:SaveData(player: Player)
	local profile = PlayerController:GetProfile(player)
	if profile then
		profile:Save()
	end
end

function DataAccessor:GetKey(player: Player, key: string): any?
	local data = self:GetData(player)
	return data and data[key]
end

function DataAccessor:SetKey(player: Player, key: string, value: any)
	local data = self:GetData(player)
	if data then
		data[key] = value
	end
end

return DataAccessor
---

--- ServerScriptService.Modules.Utils (ModuleScript) ---
--!strict
local Utils = {}

function Utils.ToggleRagdoll(character: Model, enabled: boolean)
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		if enabled then
			humanoid:ChangeState(Enum.HumanoidStateType.Physics)
		else
			humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
		end
	end
end

return Utils
---

--- ServerScriptService.Controllers.BlocksShopController (ModuleScript) ---
--!strict
-- BLOCKS / TURRETS CASH SHOP CONTROLLER (uses personal stocks seeded from global baseline)

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

local ItemConfigurations = require(ReplicatedStorage.Modules.ItemConfigurations)
local BadgeController = require(ServerScriptService.Controllers:WaitForChild("BadgeController"))

local PlayerController
local GlobalShopController
local ShopController = {}

local purchaseItemEvent = ReplicatedStorage.Events:WaitForChild("PurchaseBlockItem")
local showNotificationEvent = ReplicatedStorage.Events:WaitForChild("ShowNotification")
local blockInventoryUpdatedEvent = ReplicatedStorage.Events:WaitForChild("BlockInventoryUpdated")

local function onPurchaseRequest(player: Player, itemId: string)
	-- wait until controllers are injected (defensive)
	while not GlobalShopController do task.wait() end
	while not PlayerController do task.wait() end

	local profile = PlayerController:GetProfile(player)
	local config = ItemConfigurations[itemId]
	if not profile or not config then return end
	if config.Price == nil then
		-- not a cash-sellable item in this shop
		return
	end

	-- check personal stock (global baseline -> personal counters)
	if not config.Unlimited then
		local myStock = GlobalShopController:GetPlayerBlocks(player)
		if (myStock[itemId] or 0) <= 0 then
			showNotificationEvent:FireClient(player, "This item is out of stock!", "Error")
			return
		end
	end

	-- funds
	local leaderstats = player:FindFirstChild("leaderstats")
	local cash = leaderstats and leaderstats:FindFirstChild("Cash")
	if not (cash and cash.Value >= config.Price) then
		showNotificationEvent:FireClient(player, "Not enough cash!", "Error")
		return
	end

	-- purchase
	cash.Value -= config.Price
	if not config.Unlimited then
		local ok = GlobalShopController:ConsumeBlocks(player, itemId)
		if not ok then
			showNotificationEvent:FireClient(player, "This item just went out of stock!", "Error")
			return
		end
	end

	local inv = profile.Data.BlockInventory
	inv[itemId] = (inv[itemId] or 0) + 1

	-- ðŸ”” Auto-award badges when buying turrets/cowboys
	if config.Type == "Turrets" then
		BadgeController.SyncForNewItem(player, itemId)
	end

	showNotificationEvent:FireClient(player, `Purchased {config.DisplayName}!`, "Success")
	blockInventoryUpdatedEvent:FireClient(player, inv)

	if not profile.Data.HasCompletedOnboarding and config.Type == "Turrets" then
		ReplicatedStorage.Events.UpdateOnboardingStep:FireClient(player, "Step2_PlaceTurret")
	end
end

function ShopController:PersonalRestock(player: Player)
	GlobalShopController:AddPersonalBlocks(player)
end

function ShopController:Init(controllers: {[string]: any})
	PlayerController        = controllers.PlayerController
	GlobalShopController    = controllers.GlobalShopController
end

function ShopController:Start()
	purchaseItemEvent.OnServerEvent:Connect(onPurchaseRequest)
end

return ShopController

---

--- ServerScriptService.Controllers.ShopController (ModuleScript) ---
--[[
	ShopController Script
	
	Description: Manages interactions with in-world shop trigger parts.
	Detects when a player touches a shop part and fires a remote event
	to that player's client, instructing it to open the correct UI frame.
	
	Location: ServerScriptService/Controllers
--]]
--!strict

-- Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Define the Controller Module
local ShopController = {}

-- Events
local openShopFrameEvent: RemoteEvent = ReplicatedStorage.Events:WaitForChild("OpenShopFrame")

-- Configuration
local shops = {
	WeaponsShop = Workspace:WaitForChild("WeaponsShop"),
	BlocksShop = Workspace:WaitForChild("BlocksShop"),
}

-- State
local debounce = {} -- To prevent spamming the event

-- This function sets up the .Touched event for a given shop part.
local function setupShopTrigger(shopName: string, shopModel: Model)
	local touchPart = shopModel:FindFirstChild("Touch")

	if not (touchPart and touchPart:IsA("BasePart")) then
		warn(`Shop trigger part not found for '{shopName}'. Please add a BasePart named "Touch" to the model.`)
		return
	end

	touchPart.Touched:Connect(function(hit)
		local character = hit.Parent
		local player = Players:GetPlayerFromCharacter(character)

		if not player then return end
		if debounce[player] then return end

		debounce[player] = true

		print(`Player {player.Name} touched the {shopName} trigger.`)
		openShopFrameEvent:FireClient(player, shopName)

		task.delay(1, function()
			debounce[player] = nil
		end)
	end)

	--print(`Successfully set up trigger for {shopName}.`)
end

-- This method will be called by the Bootstrap script.
function ShopController:Start()
	for name, model in pairs(shops) do
		setupShopTrigger(name, model)
	end
end

return ShopController

---

--- ServerScriptService.Controllers.PlotController (ModuleScript) ---
--!strict
-- Grid unlocking system removed. Plot claim + protection model + crates + load items are kept.

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local CollectionService = game:GetService("CollectionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local ModelProgression = require(ReplicatedStorage.Modules.ModelProgression)

-- Controllers (wired by :Init)
local PlacementController: any
local PlayerController: any
local CrateController: any

-- Refs
local PLOTS_FOLDER = Workspace:WaitForChild("Plots")
local CRATE_MODELS = ReplicatedStorage:WaitForChild("Crates")
local Events = ReplicatedStorage:WaitForChild("Events")
local ResetPlotEvent = Events:WaitForChild("ResetPlot")
local UpdateProtectionModelFX = Events:WaitForChild("UpdateProtectionModelFX")

local function spawnPromotionalCrate(plot: Model)
	local spawnPart = plot:FindFirstChild("RobuxCrateSpawn"); if not spawnPart then return end
	local tpl = CRATE_MODELS:FindFirstChild("GoldCrate"); if not (tpl and tpl.PrimaryPart) then return end
	local m = tpl:Clone(); m.Name = "PromotionalGoldCrate"
	m:SetPrimaryPartCFrame(spawnPart.CFrame * CFrame.new(0,3,0))
	m.Parent = plot
end

local PlotController = {}

function PlotController:UpdateProtectionModel(player: Player, plot: Model)
	local profile = PlayerController:GetProfile(player); if not profile then return end
	local modelIndex = profile.Data.UnlockedModelIndex
	local modelData = ModelProgression[modelIndex]; if not modelData then return end

	local ph = plot:FindFirstChild("PlotHealth"); if not ph then return end
	for _, ch in ipairs(ph:GetChildren()) do if ch:IsA("Model") then ch:Destroy() end end

	local tpl = ReplicatedStorage.Models:FindFirstChild(modelData.ModelName)
	if tpl then
		local newM = tpl:Clone()
		if newM.PrimaryPart then newM:SetPrimaryPartCFrame(ph.CFrame) end
		newM.Parent = ph
	end
	ph:SetAttribute("Health", modelData.PlotHealth)
	UpdateProtectionModelFX:FireClient(player, modelData.ImageId, modelData.PlotHealth, modelIndex)
end

-- Plot claiming / lifecycle
local function findAvailablePlot(): Model?
	for _, plot in ipairs(PLOTS_FOLDER:GetChildren()) do
		if plot:IsA("Model") and not plot:GetAttribute("OwnerId") then return plot end
	end
	return nil
end

function PlotController:OnPlayerProfileLoaded(player: Player)
	while not PlacementController or not CrateController or not PlayerController do task.wait() end

	local plot = findAvailablePlot()
	if plot then
		plot:SetAttribute("OwnerId", player.UserId)
		player:SetAttribute("PlotNumber", tonumber(string.match(plot.Name, "%d+")))

		local ph = plot:FindFirstChild("PlotHealth")
		if ph then CollectionService:AddTag(ph, "Damageable") end

		spawnPromotionalCrate(plot)
		self:UpdateProtectionModel(player, plot)

		PlacementController:LoadPlacedItems(player, plot)
		CrateController:LoadPlayerCrates(player, plot)

		local spawnLocation = plot:FindFirstChild("SpawnPart")
		if spawnLocation and spawnLocation:IsA("SpawnLocation") then
			player.RespawnLocation = spawnLocation
			if player.Character then player.Character:SetPrimaryPartCFrame(spawnLocation.CFrame * CFrame.new(0,3,0)) end
		end
	else
		player:Kick("Sorry, all plots are currently taken! Please try a different server.")
	end
end

local function onPlayerRemoving(player: Player)
	for _, plot in ipairs(PLOTS_FOLDER:GetChildren()) do
		if plot:IsA("Model") and plot:GetAttribute("OwnerId") == player.UserId then
			player.RespawnLocation = nil
			local ph = plot:FindFirstChild("PlotHealth"); if ph then CollectionService:RemoveTag(ph, "Damageable") end
			plot:SetAttribute("OwnerId", nil)

			local toDestroy: {Instance} = {}
			for _, ch in ipairs(plot:GetChildren()) do
				if ch:GetAttribute("IsPlacedItem") == true or ch.Name == "PromotionalGoldCrate" then table.insert(toDestroy, ch) end
			end
			local crateFolder = plot:FindFirstChild("Crate")
			if crateFolder then
				for _, m in ipairs(crateFolder:GetChildren()) do if m:IsA("Model") then table.insert(toDestroy, m) end end
			end
			local pol = plot:FindFirstChild("PlotHealth")
			if pol then for _, m in ipairs(pol:GetChildren()) do if m:IsA("Model") then table.insert(toDestroy, m) end end end
			for _, inst in ipairs(toDestroy) do inst:Destroy() end
			return
		end
	end
end

local function setupPlot(plot: Model)
	if not plot:IsA("Model") then return end
	plot:SetAttribute("OwnerId", nil)
end

function PlotController:Init(controllers: {[string]: any})
	PlacementController = controllers.PlacementController
	PlayerController = controllers.PlayerController
	CrateController = controllers.CrateController
end

function PlotController:Start()
	for _, plot in ipairs(PLOTS_FOLDER:GetChildren()) do setupPlot(plot) end
	PLOTS_FOLDER.ChildAdded:Connect(setupPlot)
	Players.PlayerRemoving:Connect(onPlayerRemoving)

	Players.PlayerAdded:Connect(function(player)
		player.CharacterAdded:Connect(function(character)
			task.wait(0.5)
			local n = player:GetAttribute("PlotNumber"); if not n then return end
			local plot = Workspace.Plots:FindFirstChild("Plot" .. tostring(n)); if not plot then return end
			local spawnPart = plot:FindFirstChild("SpawnPart")
			if spawnPart and character:FindFirstChild("HumanoidRootPart") then
				if spawnPart:IsA("SpawnLocation") then player.RespawnLocation = spawnPart end
				character:SetPrimaryPartCFrame(spawnPart.CFrame * CFrame.new(0,3,0))
			end
		end)
	end)

	ResetPlotEvent.OnServerEvent:Connect(function(player)
		PlacementController:ResetPlotItems(player)
	end)
end

return PlotController

---

--- ServerScriptService.Controllers.PlayerController (ModuleScript) ---
--!strict

local Players = game:GetService("Players")
local ServerScriptService = game:GetService("ServerScriptService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local MarketplaceService = game:GetService("MarketplaceService")

local ProfileService = require(ServerScriptService.Modules:WaitForChild("ProfileService"))
local BadgeController = require(game.ServerScriptService.Controllers:WaitForChild("BadgeController"))
local EnemyConfigurations = require(ReplicatedStorage.Modules:WaitForChild("EnemyConfigurations"))

local PlayerController = {}

local GAMEPASS_ID_FASTFORWARD = 1542612384
local GAMEPASS_ID_EXTRA_CRATES = 1572988194
local STARTERPACK_OFFER_SECONDS = 172740

local ProfileTemplate = {
	Cash = 250,
	Strength = 0,
	BlockInventory = {},
	PlacedItems = {},
	HighestWave = 0,
	StartingWave = 1,
	UnlockedModelIndex = 1,
	Crates = {},
	WeaponInventory = { "Heizer" },
	LastEquippedWeapon = "Heizer",
	HasCompletedOnboarding = false,

	BlockShopStock = {},
	WeaponShopStock = {},

	HasClaimedGroupReward = false,

	StarterPackOwned = false,
	Minigun = false,
	StarterPackOfferEndsAt = 0,

	DailyRewards = {
		CurrentDay = 1,
		LastClaimDayId = 0,
	},

	-- Simple map: [enemyId] = count
	EnemyInventory = {},

	-- Cages: [slotIndex] = { EnemyId, Banked, LastTick, LastOfflineEarned, Mutation? }
	CageSlots = {},

	-- Unlock state: [slotIndex] = true/false
	CageUnlocks = {},

	FastForwardUnlocked = false,

	PlotUpgrades = {
		TurretLimitTier = 1,
		TurretHpTier = 1,
		BlockLimitTier = 1,
		BlockHpTier = 1,
	},

	RobuxSpentTotal = 0,

	Settings = {
		WeaponSounds = true,
		Music = true,
		Performance = false,
	},

	ShopState = {
		Bucket = 0,
		Blocks = {},
		Weapons = {},
	},

	Gemstone = 0,
	GuardsInventory = {},
	ActiveMutationJob = nil,
	OwnsExtraCrateGP = false,

	LuckBoostUntil = 0,
	UnlockedTiles = {},
	HasAppliedTileMigration = false,

	DailyReward = {
		lastDayIndex = 0,
		streak = 0,
		lastClaimAt = 0,
	},

	-- Rebirth system
	Rebirths = 0,
	RebirthMoneyMultiplier = 1,
	RebirthLuckMultiplier = 1,
}

local GameProfileStore = ProfileService.New("LiveData", ProfileTemplate)
local _profiles: {[Player]: any} = {}
local _controllers: {[string]: any} = {}

local _remotes: {[string]: Instance} = {}

--------------------------
-- CORE PROFILE HANDLING
--------------------------

function PlayerController:GetProfile(player: Player)
	return _profiles[player]
end

function PlayerController:SetupSharedInstances() end

local function ensureEvents()
	local events = ReplicatedStorage:FindFirstChild("Events")
	if not events then
		events = Instance.new("Folder")
		events.Name = "Events"
		events.Parent = ReplicatedStorage
	end

	local functions = ReplicatedStorage:FindFirstChild("Functions")
	if not functions then
		functions = Instance.new("Folder")
		functions.Name = "Functions"
		functions.Parent = ReplicatedStorage
	end

	local function ensureRemoteEvent(name: string, parent: Instance): RemoteEvent
		local ev = parent:FindFirstChild(name) :: RemoteEvent?
		if not ev then
			ev = Instance.new("RemoteEvent")
			ev.Name = name
			ev.Parent = parent
		end
		_remotes[name] = ev
		return ev
	end

	local function ensureRemoteFunction(name: string, parent: Instance): RemoteFunction
		local fn = parent:FindFirstChild(name) :: RemoteFunction?
		if not fn then
			fn = Instance.new("RemoteFunction")
			fn.Name = name
			fn.Parent = parent
		end
		_remotes[name] = fn
		return fn
	end

	ensureRemoteEvent("CashUpdated", events)
	ensureRemoteFunction("GetPlayerCash", functions)

	ensureRemoteEvent("StarterPackOwned", events)
	ensureRemoteEvent("StarterPackOfferEndsAtUpdated", events)
	ensureRemoteEvent("FastForwardUnlocked", events)
	ensureRemoteEvent("RefreshFastForwardOwnership", events)

	ensureRemoteFunction("GetStarterPackOwned", functions)
	ensureRemoteFunction("GetStarterPackOfferEndsAt", functions)

	-- NOTE: original bug (GetPlayerSettings under events) kept as-is for compat
	ensureRemoteFunction("GetPlayerSettings", events)
	ensureRemoteEvent("SavePlayerSettings", events)

	ensureRemoteEvent("WeaponInventoryUpdated", events)
	ensureRemoteEvent("BlockInventoryUpdated", events)
	ensureRemoteEvent("CrateDataUpdated", events)
	ensureRemoteEvent("PlotUpgradesUpdated", events)
	ensureRemoteEvent("StartOnboarding", events)

	ensureRemoteEvent("GuardsInventoryUpdated", events)

	-- Enemy inventory + lasso
	ensureRemoteEvent("EnemyInventoryUpdated", events)
	ensureRemoteEvent("LassoCaptureRequest", events)
	ensureRemoteEvent("LassoSceneStarted", events)
	ensureRemoteEvent("LassoSceneFinished", events)
	ensureRemoteEvent("LassoClickEnemy", events)
	ensureRemoteFunction("GetEnemyInventory", functions)

	-- enemy auto-sell + placement tools
	ensureRemoteEvent("EnemyAutoSellUpdated", events)
	ensureRemoteEvent("SetEnemyAutoSell", events)
	ensureRemoteEvent("RequestEnemyPlacementTool", events)

	ensureRemoteEvent("TileUnlocked", events)
	ensureRemoteEvent("PlotResetNotice", events)

	return events
end

local function fireOwned(player: Player)
	local ev = _remotes["FastForwardUnlocked"]
	if ev and ev:IsA("RemoteEvent") then
		(ev :: RemoteEvent):FireClient(player)
	end
end

local function checkAndApplyGamePass(player: Player, profile: any)
	local ok, owns = pcall(function()
		return MarketplaceService:UserOwnsGamePassAsync(player.UserId, GAMEPASS_ID_FASTFORWARD)
	end)
	if ok and owns then
		if not profile.Data.FastForwardUnlocked then
			profile.Data.FastForwardUnlocked = true
		end
		fireOwned(player)
	end
end

local function onPlayerAdded(player: Player)
	local profileKey = tostring(player.UserId)
	local profile = GameProfileStore:StartSessionAsync(profileKey, { Steal = true })
	if not profile then
		player:Kick("Failed to load your data. Please rejoin.")
		return
	end

	profile:Reconcile()
	profile:AddUserId(player.UserId)
	_profiles[player] = profile

	do
		local ok, owns = pcall(MarketplaceService.UserOwnsGamePassAsync, MarketplaceService, player.UserId, GAMEPASS_ID_EXTRA_CRATES)
		owns = ok and owns == true
		profile.Data.OwnsExtraCrateGP = owns
		player:SetAttribute("HasCrateSlotsPass", owns)
	end

	local leaderstats = Instance.new("Folder")
	leaderstats.Name = "leaderstats"
	leaderstats.Parent = player

	local cashVal = Instance.new("IntValue")
	cashVal.Name = "Cash"
	cashVal.Value = profile.Data.Cash
	cashVal.Parent = leaderstats

	local highestWave = Instance.new("IntValue")
	highestWave.Name = "Highest Wave"
	highestWave.Value = profile.Data.HighestWave
	highestWave.Parent = leaderstats

	player:SetAttribute("Gemstone", profile.Data.Gemstone or 0)

	if not profile.Data.StarterPackOwned and (profile.Data.StarterPackOfferEndsAt or 0) == 0 then
		profile.Data.StarterPackOfferEndsAt = os.time() + STARTERPACK_OFFER_SECONDS
	end

	local cashEv = _remotes["CashUpdated"]
	if cashEv and cashEv:IsA("RemoteEvent") then
		(cashEv :: RemoteEvent):FireClient(player, profile.Data.Cash)
	end

	if profile.Data.LastEquippedWeapon then
		player:SetAttribute("LastEquippedWeapon", profile.Data.LastEquippedWeapon)
	end

	-- settings
	do
		local s = profile.Data.Settings or {}
		local ws = (typeof(s.WeaponSounds) == "boolean") and s.WeaponSounds or true
		local mu = (typeof(s.Music) == "boolean") and s.Music or true
		local pf = (typeof(s.Performance) == "boolean") and s.Performance or false
		player:SetAttribute("Setting_WeaponSounds", ws)
		player:SetAttribute("Setting_Music", mu)
		player:SetAttribute("Setting_PerformanceMode", pf)

		BadgeController.SyncFor(player, profile.Data)
	end

	-- inventory sync
	local wEv = _remotes["WeaponInventoryUpdated"]
	if wEv and wEv:IsA("RemoteEvent") then
		(wEv :: RemoteEvent):FireClient(player, profile.Data.WeaponInventory)
	end

	local bEv = _remotes["BlockInventoryUpdated"]
	if bEv and bEv:IsA("RemoteEvent") then
		(bEv :: RemoteEvent):FireClient(player, profile.Data.BlockInventory)
	end

	local cEv = _remotes["CrateDataUpdated"]
	if cEv and cEv:IsA("RemoteEvent") then
		(cEv :: RemoteEvent):FireClient(player, profile.Data.Crates)
	end

	local pEv = _remotes["PlotUpgradesUpdated"]
	if pEv and pEv:IsA("RemoteEvent") then
		(pEv :: RemoteEvent):FireClient(player, profile.Data.PlotUpgrades)
	end

	local gi = _remotes["GuardsInventoryUpdated"]
	if gi and gi:IsA("RemoteEvent") then
		(gi :: RemoteEvent):FireClient(player, profile.Data.GuardsInventory)
	end

	-- Enemy inventory sync
	local ei = _remotes["EnemyInventoryUpdated"]
	if ei and ei:IsA("RemoteEvent") then
		profile.Data.EnemyInventory = profile.Data.EnemyInventory or {}
		(ei :: RemoteEvent):FireClient(player, profile.Data.EnemyInventory)
	end

	if _controllers.GlobalShopController then
		_controllers.GlobalShopController:GetPlayerBlocks(player)
		_controllers.GlobalShopController:GetPlayerWeapons(player)
	end

	checkAndApplyGamePass(player, profile)

	local offerEv = _remotes["StarterPackOfferEndsAtUpdated"]
	if offerEv and offerEv:IsA("RemoteEvent") then
		(offerEv :: RemoteEvent):FireClient(player, profile.Data.StarterPackOfferEndsAt or 0)
	end

	if profile.Data.StarterPackOwned then
		local ownedEv = _remotes["StarterPackOwned"]
		if ownedEv and ownedEv:IsA("RemoteEvent") then
			(ownedEv :: RemoteEvent):FireClient(player)
		end
	end

	if not profile.Data.HasCompletedOnboarding then
		local so = _remotes["StartOnboarding"]
		if so and so:IsA("RemoteEvent") then
			(so :: RemoteEvent):FireClient(player)
		end
	end

	-- Plot + cages
	if _controllers.PlotController and _controllers.PlotController.OnPlayerProfileLoaded then
		_controllers.PlotController:OnPlayerProfileLoaded(player)
	end

	if _controllers.CageController and _controllers.CageController.OnPlayerProfileLoaded then
		_controllers.CageController:OnPlayerProfileLoaded(player)
	end

	print(`Player {player.Name} joined and data was loaded successfully.`)
end

local function onPlayerRemoving(player: Player)
	local profile = _profiles[player]
	if profile then
		profile:EndSession()
		_profiles[player] = nil
		print(`Player {player.Name} left. Data session ended.`)
	end
end

--------------------------
-- CENTRALIZED CASH
--------------------------

local function syncLeaderstats(player: Player, cashValue: number)
	local ls = player:FindFirstChild("leaderstats")
	local cash = ls and ls:FindFirstChild("Cash")
	if cash and cash:IsA("IntValue") then
		cash.Value = cashValue
	end
end

local function getFriendBoostMultiplier(player: Player): number
	local multiplier = 1
	local friendsCount = 0

	for _, other in ipairs(Players:GetPlayers()) do
		if other ~= player then
			local ok, isFriend = pcall(function()
				return player:IsFriendsWith(other.UserId)
			end)
			if ok and isFriend then
				friendsCount += 1
			end
		end
	end

	local bonusPercent = math.clamp(friendsCount * 10, 0, 30) -- 0â€“30%
	multiplier += bonusPercent / 100
	return multiplier
end


function PlayerController.AddCash(player: Player, amount: number)
	local profile = PlayerController:GetProfile(player)
	amount = tonumber(amount) or 0
	if not profile or amount <= 0 then return end

	-- Base rebirth multiplier
	local rebirthMult = profile.Data.RebirthMoneyMultiplier or 1

	-- Friend boost multiplier (10% per friend, max 30%)
	local friendMult = getFriendBoostMultiplier(player)

	-- Final reward
	local final = amount * rebirthMult * friendMult

	local newCash = (profile.Data.Cash or 0) + final
	profile.Data.Cash = newCash
	profile:Save()

	syncLeaderstats(player, newCash)

	local ev = _remotes["CashUpdated"]
	if ev and ev:IsA("RemoteEvent") then
		(ev :: RemoteEvent):FireClient(player, newCash)
	end
end


function PlayerController.RemoveCash(player: Player, amount: number): boolean
	local profile = PlayerController:GetProfile(player)
	amount = tonumber(amount) or 0
	if not profile or amount <= 0 then return false end

	if (profile.Data.Cash or 0) >= amount then
		local newCash = profile.Data.Cash - amount
		profile.Data.Cash = newCash
		profile:Save()

		syncLeaderstats(player, newCash)

		local ev = _remotes["CashUpdated"]
		if ev and ev:IsA("RemoteEvent") then
			(ev :: RemoteEvent):FireClient(player, newCash)
		end
		return true
	end

	return false
end

local function onPlayerCashRequested(player: Player): number?
	local profile = PlayerController:GetProfile(player)
	while not profile do
		task.wait()
		profile = PlayerController:GetProfile(player)
	end

	return profile.Data.Cash or 0
end

--------------------------
-- ENEMY INVENTORY API
--------------------------

function PlayerController.AddCapturedEnemy(player: Player, enemyId: string)
	if not enemyId or enemyId == "" then return end

	local profile = PlayerController:GetProfile(player)
	if not profile then return end

	local inv = profile.Data.EnemyInventory or {}
	inv[enemyId] = (inv[enemyId] or 0) + 1
	profile.Data.EnemyInventory = inv
	profile:Save()

	local ev = _remotes["EnemyInventoryUpdated"]
	if ev and ev:IsA("RemoteEvent") then
		(ev :: RemoteEvent):FireClient(player, inv)
	end
end

function PlayerController.TryConsumeEnemy(player: Player, enemyId: string): boolean
	if not enemyId or enemyId == "" then return false end

	local profile = PlayerController:GetProfile(player)
	if not profile then return false end

	local inv = profile.Data.EnemyInventory or {}
	local current = inv[enemyId] or 0
	if current <= 0 then return false end

	inv[enemyId] = current - 1
	profile.Data.EnemyInventory = inv
	profile:Save()

	local ev = _remotes["EnemyInventoryUpdated"]
	if ev and ev:IsA("RemoteEvent") then
		(ev :: RemoteEvent):FireClient(player, inv)
	end

	return true
end

--------------------------
-- KILL HANDLING â€“ ALWAYS CAPTURE
--------------------------

function PlayerController.HandleEnemyKill(player: Player, enemyId: string, killMult: number?)
	if not enemyId or enemyId == "" then return end

	local profile = PlayerController:GetProfile(player)
	if not profile then return end

	killMult = killMult or 1

	local conf = EnemyConfigurations[enemyId]

	-- Cash for kill if configured
	if conf then
		local baseReward = conf.KillCash or 0
		if baseReward > 0 then
			PlayerController.AddCash(player, baseReward * killMult)
		end
	end

	-- ðŸ”¥ Always capture enemy
	PlayerController.AddCapturedEnemy(player, enemyId)
end

--------------------------
-- GEMSTONE FUNCTIONS
--------------------------

function PlayerController.AddGems(player: Player, amount: number)
	amount = tonumber(amount) or 0
	if amount <= 0 then return end
	local profile = _profiles[player]; if not profile then return end

	profile.Data.Gemstone = (profile.Data.Gemstone or 0) + amount
	player:SetAttribute("Gemstone", profile.Data.Gemstone)
end

function PlayerController.GetGems(player: Player): number
	local profile = _profiles[player]
	if not profile then return 0 end
	return tonumber(profile.Data.Gemstone) or 0
end

function PlayerController._SetGemsAbsolute(player: Player, newAmount: number)
	newAmount = math.max(0, math.floor(tonumber(newAmount) or 0))
	local profile = _profiles[player]; if not profile then return end

	profile.Data.Gemstone = newAmount
	player:SetAttribute("Gemstone", newAmount)
end

function PlayerController.TrySpendGems(player: Player, cost: number): boolean
	cost = math.max(0, math.floor(tonumber(cost) or 0))
	if cost <= 0 then return true end

	local have = PlayerController.GetGems(player)
	if have < cost then return false end

	PlayerController._SetGemsAbsolute(player, have - cost)
	return true
end

--------------------------
-- INITIALIZATION
--------------------------

function PlayerController:Init(controllers: {[string]: any})
	ensureEvents()

	_controllers = controllers

	local getCashFn = _remotes["GetPlayerCash"]
	if getCashFn and getCashFn:IsA("RemoteFunction") then
		(getCashFn :: RemoteFunction).OnServerInvoke = onPlayerCashRequested
	end

	local getEnemyInvFn = _remotes["GetEnemyInventory"]
	if getEnemyInvFn and getEnemyInvFn:IsA("RemoteFunction") then
		(getEnemyInvFn :: RemoteFunction).OnServerInvoke = function(plr: Player)
			local profile = PlayerController:GetProfile(plr)
			while not profile do
				task.wait()
				profile = PlayerController:GetProfile(plr)
			end
			profile.Data.EnemyInventory = profile.Data.EnemyInventory or {}
			return profile.Data.EnemyInventory
		end
	end

	-- tool request -> forward to CageController
	local requestToolEv = _remotes["RequestEnemyPlacementTool"]
	if requestToolEv and requestToolEv:IsA("RemoteEvent") then
		(requestToolEv :: RemoteEvent).OnServerEvent:Connect(function(plr: Player, enemyId: string)
			local cageCtrl = _controllers.CageController
			if cageCtrl and cageCtrl.GivePlacementTool then
				cageCtrl:GivePlacementTool(plr, enemyId)
			end
		end)
	end

	local defaults = { WeaponSounds = true, Music = true, Performance = false }
	local function sanitize(t)
		if typeof(t) ~= "table" then return nil end
		local ws, mu, pf = t.WeaponSounds, t.Music, t.Performance
		if typeof(ws) ~= "boolean" or typeof(mu) ~= "boolean" or typeof(pf) ~= "boolean" then return nil end
		return { WeaponSounds = ws, Music = mu, Performance = pf }
	end

	local getSettingsFn = _remotes["GetPlayerSettings"]
	if getSettingsFn and getSettingsFn:IsA("RemoteFunction") then
		(getSettingsFn :: RemoteFunction).OnServerInvoke = function(plr: Player)
			local p = _profiles[plr]
			while not p do
				task.wait()
				p = _profiles[plr]
			end
			p.Data.Settings = p.Data.Settings or table.clone(defaults)
			return p.Data.Settings
		end
	end

	local saveSettingsEv = _remotes["SavePlayerSettings"]
	if saveSettingsEv and saveSettingsEv:IsA("RemoteEvent") then
		(saveSettingsEv :: RemoteEvent).OnServerEvent:Connect(function(plr: Player, payload)
			local p = _profiles[plr]
			if not p then return end
			local v = sanitize(payload)
			if not v then return end
			p.Data.Settings = v
			plr:SetAttribute("Setting_WeaponSounds", v.WeaponSounds)
			plr:SetAttribute("Setting_Music", v.Music)
			plr:SetAttribute("Setting_PerformanceMode", v.Performance)
		end)
	end

	local refresh = _remotes["RefreshFastForwardOwnership"]
	if refresh and refresh:IsA("RemoteEvent") then
		(refresh :: RemoteEvent).OnServerEvent:Connect(function(plr: Player)
			local profile = _profiles[plr]
			if not profile then return end
			checkAndApplyGamePass(plr, profile)
		end)
	end

	MarketplaceService.PromptGamePassPurchaseFinished:Connect(function(plr: Player, gamePassId: number, wasPurchased: boolean)
		if gamePassId ~= GAMEPASS_ID_EXTRA_CRATES then return end
		local p = _profiles[plr]
		if not p then return end
		if wasPurchased then
			p.Data.OwnsExtraCrateGP = true
			plr:SetAttribute("HasCrateSlotsPass", true)
		end
	end)
end

function PlayerController:Start()
	Players.PlayerAdded:Connect(onPlayerAdded)
	Players.PlayerRemoving:Connect(onPlayerRemoving)

	-- for existing players in Studio
	for _, plr in ipairs(Players:GetPlayers()) do
		task.spawn(onPlayerAdded, plr)
	end
end

function PlayerController:MarkStarterPackOwned(player: Player)
	local profile = _profiles[player]
	if not profile then return end
	if profile.Data.StarterPackOwned then return end
	profile.Data.StarterPackOwned = true
	local ev = _remotes["StarterPackOwned"]
	if ev and ev:IsA("RemoteEvent") then
		(ev :: RemoteEvent):FireClient(player)
	end
end

function PlayerController:GrantFastForward(player: Player)
	local profile = _profiles[player]
	if not profile then return end
	if profile.Data.FastForwardUnlocked then return end
	profile.Data.FastForwardUnlocked = true
	fireOwned(player)
end

function PlayerController:GetPlotUpgrades(player: Player)
	local profile = _profiles[player]
	if not profile then return nil end
	return profile.Data.PlotUpgrades
end

return PlayerController

---

--- ServerScriptService.Controllers.PlacementController (ModuleScript) ---
--!strict
-- Server placement/removal with contiguous stacking and anti-floating TURRETS only.
-- Rules:
--  - Blocks stack on blocks up to MAX_HEIGHT (never on a turret), must TOUCH valid support at placement time.
--  - Turrets can sit on plot base or on a block (never on a turret), must TOUCH valid support.
--  - If support is removed:
--      * Blocks: do NOTHING (they can float).
--      * Turrets: remove if unsupported (refund on player removals; no refund on NPC).

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local HttpService = game:GetService("HttpService")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")

local ItemConfigurations = require(ReplicatedStorage.Modules.ItemConfigurations)

-- Controllers (wired by :Init)
local PlayerController: any
local TurretController: any

-- Events
local EventsFolder = ReplicatedStorage:WaitForChild("Events")
local PlaceItemEvent = EventsFolder:WaitForChild("PlaceItemEvent")
local RemoveItemEvent = EventsFolder:WaitForChild("RemoveItemEvent")
local ItemPlacedFX = EventsFolder:WaitForChild("ItemPlacedFX")
local ItemRemovedFX = EventsFolder:WaitForChild("ItemRemovedFX")

local PlacementDenied = EventsFolder:FindFirstChild("PlacementDenied")
if not PlacementDenied then
	local e = Instance.new("RemoteEvent")
	e.Name = "PlacementDenied"
	e.Parent = EventsFolder
	PlacementDenied = e
end

local BLOCKS_MODELS = ReplicatedStorage:WaitForChild("Blocks")
local TURRETS_MODELS = ReplicatedStorage:WaitForChild("Turrets")

local PlacementController = {}
local placementDebounce: {[Player]: boolean} = {}

-- ====== CONFIG ======
local MAX_HEIGHT = 4 -- contiguous blocks from base
local EPS = 0.05

-- ====== Utilities ======
local function getModelTemplate(itemId: string)
	local cfg = ItemConfigurations[itemId]
	if not cfg then return nil end
	if cfg.Type == "Blocks" then return BLOCKS_MODELS:FindFirstChild(itemId) end
	if cfg.Type == "Turrets" then return TURRETS_MODELS:FindFirstChild(itemId) end
	return nil
end

local function getPlacementBox(model: Model): BasePart?
	local pb = model:FindFirstChild("PlacementBox")
	return (pb and pb:IsA("BasePart")) and pb or nil
end

local function isBlock(itemId: string): boolean
	local cfg = ItemConfigurations[itemId]
	return (cfg and cfg.Type == "Blocks") == true
end

local function isTurret(itemId: string): boolean
	local cfg = ItemConfigurations[itemId]
	return (cfg and cfg.Type == "Turrets") == true
end

local function cframeToPositionTable(cf: CFrame)
	local _, ry, _ = cf:ToOrientation()
	return {cf.X, cf.Y, cf.Z, math.deg(ry)}
end

local function positionTableToCFrame(pos: {number})
	return CFrame.new(pos[1], pos[2], pos[3]) * CFrame.Angles(0, math.rad(pos[4]), 0)
end

local function baseTopY(plot: Model): number
	local base = (plot and plot:FindFirstChild("Base")) :: BasePart?
	return base and (base.Position.Y + base.Size.Y/2) or 0
end

local function fitsXZ(pb: BasePart, xz: Vector3, footprint: Vector3): boolean
	local dx = math.abs(pb.Position.X - xz.X)
	local dz = math.abs(pb.Position.Z - xz.Z)
	return (dx <= math.max(pb.Size.X, footprint.X) / 2 + EPS)
		and (dz <= math.max(pb.Size.Z, footprint.Z) / 2 + EPS)
end

-- Find touching support below bottomY (must be top face within EPS)
local function findTouchingSupportBelow(plot: Model, xz: Vector3, footprint: Vector3, bottomY: number): (Model?, BasePart?, number)
	local bestModel: Model? = nil
	local bestPB: BasePart? = nil
	local bestTopY = -math.huge
	for _, ch in ipairs(plot:GetChildren()) do
		if not CollectionService:HasTag(ch, "PlacedItem") then continue end
		local pb = ch:FindFirstChild("PlacementBox")
		if not (pb and pb:IsA("BasePart")) then continue end
		if not fitsXZ(pb, xz, footprint) then continue end

		local topY = pb.Position.Y + pb.Size.Y/2
		if topY <= (bottomY + EPS) and math.abs(bottomY - topY) <= (EPS * 2) and topY > bestTopY then
			bestTopY = topY
			bestModel = ch
			bestPB = pb
		end
	end
	return bestModel, bestPB, bestTopY
end

-- Count contiguous blocks from base up to (and including) 'startModel' (0 if touching base)
local function countContiguousHeightFromBase(plot: Model, startModel: Model?, startPB: BasePart?, baseTop: number, xz: Vector3, footprint: Vector3): number
	if not startModel then
		return 0
	end
	local cfg = ItemConfigurations[startModel.Name]
	if not (cfg and cfg.Type == "Blocks") then
		return 0
	end

	local count = 1
	local currentModel = startModel
	local currentPB = startPB
	while currentModel and currentPB do
		local currentBottomY = currentPB.Position.Y - currentPB.Size.Y/2
		if math.abs(currentBottomY - baseTop) <= (EPS * 2) then
			return count
		end
		-- find touching block immediately below
		local foundBelowModel: Model? = nil
		local foundBelowPB: BasePart? = nil
		local foundBelowTopY = -math.huge
		for _, ch in ipairs(plot:GetChildren()) do
			if not CollectionService:HasTag(ch, "PlacedItem") then continue end
			if ch == currentModel then continue end
			local pb = ch:FindFirstChild("PlacementBox")
			if not (pb and pb:IsA("BasePart")) then continue end
			if not fitsXZ(pb, xz, footprint) then continue end
			local cfgB = ItemConfigurations[ch.Name]
			if not (cfgB and cfgB.Type == "Blocks") then continue end
			local topY = pb.Position.Y + pb.Size.Y/2
			if math.abs(currentBottomY - topY) <= (EPS * 2) and topY > foundBelowTopY then
				foundBelowTopY = topY
				foundBelowModel = ch
				foundBelowPB = pb
			end
		end
		if foundBelowModel and foundBelowPB then
			count += 1
			currentModel = foundBelowModel
			currentPB = foundBelowPB
		else
			-- chain broken (not attached to base) -> treat as invalid (infinite height)
			return math.huge
		end
	end
	return count
end

-- Is a turret model supported (by base or a block) right under its bottom?
local function turretIsSupported(turret: Model, plot: Model): boolean
	local tPB = getPlacementBox(turret); if not tPB then return false end
	local bottomY = tPB.Position.Y - tPB.Size.Y/2
	local base = plot:FindFirstChild("Base")
	if base and base:IsA("BasePart") then
		local baseTop = base.Position.Y + base.Size.Y/2
		if math.abs(bottomY - baseTop) <= (EPS * 2) then
			return true
		end
	end
	for _, ch in ipairs(plot:GetChildren()) do
		if not CollectionService:HasTag(ch, "PlacedItem") then continue end
		if ch == turret then continue end
		local cfg = ItemConfigurations[ch.Name]
		if not (cfg and cfg.Type == "Blocks") then continue end
		local pb = getPlacementBox(ch); if not pb then continue end
		if not fitsXZ(pb, tPB.Position, tPB.Size) then continue end
		local topY = pb.Position.Y + pb.Size.Y/2
		if math.abs(bottomY - topY) <= (EPS * 2) then
			return true
		end
	end
	return false
end

-- ====== Validation ======

local function validatePlacement(plot: Model, itemId: string, targetCFrame: CFrame): (boolean, string?)
	local placingBlock = isBlock(itemId)
	local placingTurret = isTurret(itemId)
	if not (placingBlock or placingTurret) then return false, "Unknown item." end

	local tpl = getModelTemplate(itemId); if not tpl then return false, "No template." end
	local pb = getPlacementBox(tpl); if not pb then return false, "Missing PlacementBox." end

	local pos = targetCFrame.Position
	local xz = Vector3.new(pos.X, 0, pos.Z)
	local bottomY = pos.Y - tpl.PrimaryPart.Size.Y/2
	local baseTop = baseTopY(plot)

	-- Must TOUCH valid support: base OR touching block under
	local supportModel, supportPB, _ = findTouchingSupportBelow(plot, xz, pb.Size, bottomY)
	local touchingBase = math.abs(bottomY - baseTop) <= (EPS * 2)

	if not touchingBase and not supportModel then
		return false, "Must be on base or a block."
	end

	-- never sit on turret
	if supportModel then
		local cfgS = ItemConfigurations[supportModel.Name]
		if cfgS and cfgS.Type == "Turrets" then
			return false, placingBlock and "Cannot place a block on a turret." or "Cannot place a turret on a turret."
		end
	end

	-- height cap uses CONTIGUOUS chain from base
	if placingBlock then
		local contiguous = countContiguousHeightFromBase(plot, supportModel, supportPB, baseTop, xz, pb.Size)
		if (contiguous + 1) > MAX_HEIGHT then
			return false, "Max block height reached."
		end
	elseif placingTurret then
		-- touching support is already enforced; turret cannot sit on turret handled above
	end

	return true, nil
end

local function sideOverlapDenied(plot: Model, tpl: Model, targetCFrame: CFrame, supportModel: Model?)
	local placementBox = getPlacementBox(tpl); if not placementBox then return true end
	local temp = placementBox:Clone()
	temp.CFrame = targetCFrame * tpl.PrimaryPart.CFrame:ToObjectSpace(placementBox.CFrame)
	temp.Parent = Workspace
	task.wait()

	local deny = false
	local params = OverlapParams.new()
	params.FilterDescendantsInstances = { temp }
	for _, part in ipairs(Workspace:GetPartsInPart(temp, params)) do
		local model = part:FindFirstAncestorOfClass("Model")
		if model and model.Parent == plot and CollectionService:HasTag(model, "PlacedItem") then
			-- allow small contact with the one directly below
			if not (supportModel and model == supportModel) then
				deny = true
				break
			end
		end
	end
	temp:Destroy()
	return deny
end

-- ====== Core ======

function PlacementController:LoadPlacedItems(player: Player, plot: Model)
	local profile = PlayerController:GetProfile(player)
	if not (profile and profile.Data.PlacedItems) then return end

	local plotBase = plot:FindFirstChild("Base")
	if not plotBase then warn("LoadPlacedItems: plot missing Base"); return end

	for _, data in ipairs(profile.Data.PlacedItems) do
		local tpl = getModelTemplate(data.ItemId); if not tpl then continue end
		local newItem = tpl:Clone()
		local cfg = ItemConfigurations[newItem.Name]

		newItem:SetAttribute("UniqueId", data.UniqueId)
		newItem:SetAttribute("IsPlacedItem", true)
		if cfg and cfg.Health then newItem:SetAttribute("Health", cfg.Health) end

		local rel = positionTableToCFrame(data.Position)
		local worldCF = plotBase.CFrame * rel

		newItem:SetPrimaryPartCFrame(worldCF)
		newItem.Parent = plot
		CollectionService:AddTag(newItem, "PlacedItem")
		CollectionService:AddTag(newItem, "Damageable")

		if cfg and cfg.Type == "Turrets" then
			TurretController:AddTurret(newItem, plot)
		end
	end
end

-- Reset (returns all items to inventory)
function PlacementController:ResetPlotItems(player: Player)
	local profile = PlayerController:GetProfile(player); if not profile then return end

	local playerPlot: Model?
	for _, plot in ipairs(Workspace.Plots:GetChildren()) do
		if plot:IsA("Model") and plot:GetAttribute("OwnerId") == player.UserId then playerPlot = plot; break end
	end
	if not playerPlot then return end

	local items: {Model} = {}
	for _, ch in ipairs(playerPlot:GetChildren()) do
		if CollectionService:HasTag(ch, "PlacedItem") then table.insert(items, ch) end
	end
	if #items == 0 then return end

	for _, m in ipairs(items) do
		local id = m.Name
		local uid = m:GetAttribute("UniqueId")
		local cfg = ItemConfigurations[id]

		-- remove data entry
		for i = #profile.Data.PlacedItems, 1, -1 do
			if profile.Data.PlacedItems[i].UniqueId == uid then table.remove(profile.Data.PlacedItems, i); break end
		end

		-- refund
		profile.Data.BlockInventory[id] = (profile.Data.BlockInventory[id] or 0) + 1

		-- unregister turret
		if cfg and cfg.Type == "Turrets" then TurretController:RemoveTurret(m) end
		m:Destroy()
	end

	ReplicatedStorage.Events.BlockInventoryUpdated:FireClient(player, profile.Data.BlockInventory)
	ItemRemovedFX:FireClient(player)
end

local function denyPlacement(player: Player, reason: string)
	PlacementDenied:FireClient(player, reason)
end

local function onPlaceItem(player: Player, itemId: string, targetCFrame: CFrame, plot: Model)
	if placementDebounce[player] then return end
	placementDebounce[player] = true

	local profile = PlayerController:GetProfile(player)
	local cfg = ItemConfigurations[itemId]
	if not (profile and cfg and plot and plot:GetAttribute("OwnerId") == player.UserId) then
		placementDebounce[player] = nil
		return
	end

	-- Inventory check
	local owned = profile.Data.BlockInventory[itemId] or 0
	if owned <= 0 then placementDebounce[player] = nil; return end

	local tpl = getModelTemplate(itemId)
	if not (tpl and tpl.PrimaryPart) then placementDebounce[player] = nil; return end

	-- Stacking rules (contiguous + touching)
	local okStack, why = validatePlacement(plot, itemId, targetCFrame)
	if not okStack then
		placementDebounce[player] = nil
		denyPlacement(player, why or "Invalid placement.")
		return
	end

	-- Overlap check (allow side contact with the touching support only)
	local pb = getPlacementBox(tpl)
	local supportModel: Model? = nil
	if pb then
		local xz = Vector3.new(targetCFrame.X, 0, targetCFrame.Z)
		local bottomY = targetCFrame.Y - tpl.PrimaryPart.Size.Y/2
		local sm = select(1, findTouchingSupportBelow(plot, xz, pb.Size, bottomY))
		supportModel = sm
	end
	if sideOverlapDenied(plot, tpl, targetCFrame, supportModel) then
		placementDebounce[player] = nil
		denyPlacement(player, "Not enough space!")
		return
	end

	-- Consume + save
	profile.Data.BlockInventory[itemId] = owned - 1
	local uid = HttpService:GenerateGUID(false)

	local plotBase = plot:FindFirstChild("Base"); if not plotBase then placementDebounce[player] = nil; return end
	local rel = plotBase.CFrame:ToObjectSpace(targetCFrame)
	table.insert(profile.Data.PlacedItems, {
		UniqueId = uid,
		ItemId = itemId,
		Position = cframeToPositionTable(rel),
	})

	-- Spawn
	local newItem = tpl:Clone()
	newItem:SetAttribute("UniqueId", uid)
	newItem:SetAttribute("IsPlacedItem", true)
	if cfg.Health then newItem:SetAttribute("Health", cfg.Health) end
	newItem:SetPrimaryPartCFrame(targetCFrame)
	newItem.Parent = plot
	CollectionService:AddTag(newItem, "PlacedItem")
	CollectionService:AddTag(newItem, "Damageable")
	if cfg.Type == "Turrets" then
		TurretController:AddTurret(newItem, plot)
	end

	ItemPlacedFX:FireClient(player)
	ReplicatedStorage.Events.BlockInventoryUpdated:FireClient(player, profile.Data.BlockInventory)

	task.delay(0.2, function()
		placementDebounce[player] = nil
	end)
end

local function onRemoveItem(player: Player, itemToRemove: Model)
	local profile = PlayerController:GetProfile(player)
	local uid = itemToRemove:GetAttribute("UniqueId")
	if not (profile and uid and itemToRemove.Parent and itemToRemove.Parent:GetAttribute("OwnerId") == player.UserId) then return end

	local plot = itemToRemove.Parent :: Model
	local itemId = itemToRemove.Name
	local cfg = ItemConfigurations[itemId]; if not cfg then return end

	-- remove from data
	for i, data in ipairs(profile.Data.PlacedItems) do
		if data.UniqueId == uid then table.remove(profile.Data.PlacedItems, i); break end
	end
	-- refund removed item
	profile.Data.BlockInventory[itemId] = (profile.Data.BlockInventory[itemId] or 0) + 1

	-- unregister if turret
	if cfg.Type == "Turrets" then TurretController:RemoveTurret(itemToRemove) end
	itemToRemove:Destroy()

	-- DO NOT touch blocks; but remove any turrets now left unsupported (refund since player action)
	for _, ch in ipairs(plot:GetChildren()) do
		if not CollectionService:HasTag(ch, "PlacedItem") then continue end
		local cfg2 = ItemConfigurations[ch.Name]
		if cfg2 and cfg2.Type == "Turrets" and not turretIsSupported(ch, plot) then
			-- remove turret + refund
			local tUid = ch:GetAttribute("UniqueId")
			for i = #profile.Data.PlacedItems, 1, -1 do
				if profile.Data.PlacedItems[i].UniqueId == tUid then
					table.remove(profile.Data.PlacedItems, i)
					break
				end
			end
			profile.Data.BlockInventory[ch.Name] = (profile.Data.BlockInventory[ch.Name] or 0) + 1
			TurretController:RemoveTurret(ch)
			ch:Destroy()
		end
	end

	ItemRemovedFX:FireClient(player)
	ReplicatedStorage.Events.BlockInventoryUpdated:FireClient(player, profile.Data.BlockInventory)
end

local function onItemDestroyedByNPC(player: Player, uniqueId: string)
	local profile = PlayerController:GetProfile(player); if not profile then return end

	-- remove entry from placed list (the physical model was already destroyed by NPC)
	for i = #profile.Data.PlacedItems, 1, -1 do
		if profile.Data.PlacedItems[i].UniqueId == uniqueId then
			table.remove(profile.Data.PlacedItems, i)
			break
		end
	end

	-- If turrets became unsupported because of NPC action, remove them (no refund)
	local playerPlot: Model?
	for _, plot in ipairs(Workspace.Plots:GetChildren()) do
		if plot:IsA("Model") and plot:GetAttribute("OwnerId") == player.UserId then
			playerPlot = plot; break
		end
	end
	if not playerPlot then return end

	for _, ch in ipairs(playerPlot:GetChildren()) do
		if not CollectionService:HasTag(ch, "PlacedItem") then continue end
		local cfg2 = ItemConfigurations[ch.Name]
		if cfg2 and cfg2.Type == "Turrets" and not turretIsSupported(ch, playerPlot) then
			-- remove turret without refund
			local tUid = ch:GetAttribute("UniqueId")
			for i = #profile.Data.PlacedItems, 1, -1 do
				if profile.Data.PlacedItems[i].UniqueId == tUid then
					table.remove(profile.Data.PlacedItems, i)
					break
				end
			end
			TurretController:RemoveTurret(ch)
			ch:Destroy()
		end
	end
end

function PlacementController:Init(controllers: {[string]: any})
	PlayerController = controllers.PlayerController
	TurretController  = controllers.TurretController
end

function PlacementController:Start()
	PlaceItemEvent.OnServerEvent:Connect(onPlaceItem)
	RemoveItemEvent.OnServerEvent:Connect(onRemoveItem)
	ReplicatedStorage.Events:WaitForChild("ItemDestroyedByNPC").Event:Connect(onItemDestroyedByNPC)
end

return PlacementController

---

--- ServerScriptService.Controllers.WaveController (ModuleScript) ---
--!strict
local ReplicatedStorage   = game:GetService("ReplicatedStorage")
local Workspace           = game:GetService("Workspace")
local Players             = game:GetService("Players")
local ServerScriptService = game:GetService("ServerScriptService")

local PlayerController
local TurretController
local PlacementController
local WeaponController
local PlotController

local WaveConfigurations     = require(ReplicatedStorage.Modules.WaveConfigurations)
local ItemConfigurations     = require(ReplicatedStorage.Modules.ItemConfigurations)
local EnemyConfigurations    = require(ReplicatedStorage.Modules.EnemyConfigurations)
local ModelProgression       = require(ReplicatedStorage.Modules.ModelProgression)
local MutationConfigurations = require(ReplicatedStorage.Modules.MutationConfigurations)

local LuckHelper = require(ReplicatedStorage.Modules:WaitForChild("LuckHelper"))

local INTERMISSION_TIME = 1
local NO_ACTIVITY_TIMEOUT = 40

local RNG = Random.new()

local WaveController = {}
local _plotStates: {[Model]: {
	IsActive: boolean,
	CurrentWave: number,
	EnemiesKilledInWave: number,
	TotalEnemiesInWave: number,
	IsStartingNextWave: boolean,
	WaveSpeedMultiplier: number,
	HealthConnection: RBXScriptConnection?,
	AliveEnemies: number,
}} = {}
local _fightToggleDebounce: {[Player]: boolean} = {}
local _autoWaveStates: {[Player]: boolean} = {}
local _preferredMultiplier: {[Player]: number} = {}

local activeEnemiesFolder = Workspace:FindFirstChild("ActiveEnemies") or Instance.new("Folder")
activeEnemiesFolder.Name = "ActiveEnemies"
activeEnemiesFolder.Parent = Workspace

-- all mutation ids except "None"
local ENEMY_MUTATIONS: {string} = {}
for id, _ in pairs(MutationConfigurations) do
	if id ~= "None" then
		table.insert(ENEMY_MUTATIONS, id)
	end
end

local function rollEnemyMutationId(player: Player): string?
	if #ENEMY_MUTATIONS == 0 then return nil end

	local BASE_CHANCE = 0.02
	if not LuckHelper.Roll(player, BASE_CHANCE) then
		return nil
	end

	local idx = RNG:NextInteger(1, #ENEMY_MUTATIONS)
	return ENEMY_MUTATIONS[idx]
end

local function getPlotForPlayer(player: Player): Model?
	local plotNum = player:GetAttribute("PlotNumber")
	if plotNum then
		local plot = Workspace.Plots:FindFirstChild("Plot" .. tostring(plotNum))
		if plot and plot:IsA("Model") then return plot end
	end
	for _, plot in ipairs(Workspace.Plots:GetChildren()) do
		if plot:IsA("Model") and plot:GetAttribute("OwnerId") == player.UserId then
			return plot
		end
	end
	return nil
end

local function getRandomSpawnCFrame(spawnPart: BasePart): CFrame
	local s = spawnPart.Size
	return spawnPart.CFrame * CFrame.new((RNG:NextNumber() - 0.5) * s.X, s.Y / 2 + 3, (RNG:NextNumber() - 0.5) * s.Z)
end

local function getWaveSpeed(state): number
	return math.clamp((state and state.WaveSpeedMultiplier) or 1, 0.25, 4)
end

local function hasFastForwardUnlocked(player: Player): boolean
	local profile = PlayerController and PlayerController:GetProfile(player)
	return profile and profile.Data and profile.Data.FastForwardUnlocked == true or false
end

function WaveController:IsPlayerFighting(player: Player): boolean
	local plot = getPlotForPlayer(player)
	if not plot or not _plotStates[plot] then return false end
	return _plotStates[plot].IsActive
end

-- 500 kills => 90%, +1% per 25 kills (600=94%, 700=98%, 750=100%)
local function computeBossWaveChance(killsSinceLastBoss: number): number
	if killsSinceLastBoss < 500 then
		return 0
	end
	local extra = killsSinceLastBoss - 500
	local steps = math.floor(extra / 25)
	local chance = 0.90 + steps * 0.01
	if chance > 1 then chance = 1 end
	return chance
end

-- weighted pick for rarity map { [rarity] = weight }
local function pickRarity(weights: {[string]: number}): string
	local total = 0
	for _, w in pairs(weights) do
		total += w
	end
	if total <= 0 then
		return "Common"
	end

	local r = RNG:NextNumber() * total
	local acc = 0
	for rarity, w in pairs(weights) do
		acc += w
		if r <= acc then
			return rarity
		end
	end

	return "Common"
end

local startNextWave
local stopFight
local startFight

startNextWave = function(player: Player, plot: Model)
	local state = _plotStates[plot]
	if not state or not state.IsActive then return end
	state.IsStartingNextWave = false

	local profile = PlayerController:GetProfile(player)
	if not profile then
		stopFight(plot, "manual")
		return
	end

	state.CurrentWave += 1

	-- boss wave based on kills since last boss
	profile.Data.KillsSinceLastBoss = profile.Data.KillsSinceLastBoss or 0
	local killsSince = profile.Data.KillsSinceLastBoss
	local isBossWave = false

	local chance = computeBossWaveChance(killsSince)
	if chance > 0 and math.random() < chance then
		isBossWave = true
		profile.Data.KillsSinceLastBoss = 0
	end

	local waveConfig
	if isBossWave then
		waveConfig = WaveConfigurations.ResolveBossWave(state.CurrentWave)
	else
		waveConfig = WaveConfigurations.ResolveWave(state.CurrentWave)
	end
	if not waveConfig then
		stopFight(plot, "win")
		return
	end

	-- highest wave / model progression
	if state.CurrentWave > profile.Data.HighestWave then
		profile.Data.HighestWave = state.CurrentWave

		local ls = player:FindFirstChild("leaderstats")
		local hw = ls and ls:FindFirstChild("Highest Wave")
		if hw then hw.Value = state.CurrentWave end

		local nextIdx = profile.Data.UnlockedModelIndex + 1
		local nextModel = ModelProgression[nextIdx]
		if nextModel and state.CurrentWave >= nextModel.WaveRequirement then
			profile.Data.UnlockedModelIndex = nextIdx
			PlotController:UpdateProtectionModel(player, plot)
			ReplicatedStorage.Events.ShowModelAward:FireClient(player, nextModel.ModelName, nextModel.ImageId)
		end
	end

	-- totals / UI
	local total = 0
	for _, g in ipairs(waveConfig.Enemies) do
		total += g.Count
	end

	state.EnemiesKilledInWave = 0
	state.TotalEnemiesInWave = total

	ReplicatedStorage.Events.WaveUIStateChanged:FireClient(
		player,
		true,
		state.CurrentWave,
		total,
		waveConfig.IsBossWave
	)

	local spawnPart = plot:FindFirstChild("EnemySpawn")
	if not spawnPart then return end

	-- ðŸ”¥ MUCH HIGHER CONCURRENCY, scales with wave
	local BASE_TARGET_CONCURRENT = waveConfig.TargetConcurrent
	if not BASE_TARGET_CONCURRENT then
		if waveConfig.IsBossWave then
			BASE_TARGET_CONCURRENT = 1
		else
			-- start at 12, +4 every 40 waves, capped at 40
			local base = 12
			local extra = math.floor(state.CurrentWave / 40)
			BASE_TARGET_CONCURRENT = math.clamp(base + extra * 4, 12, 40)
		end
	end

	-- smaller tick so we can fill waves quickly
	local MIN_TICK = 0.03

	-- build spawn groups â€“ IGNORE big DelayBetweenSpawns, use a tiny fixed gap
	local groups = {}
	local FIXED_GAP = 0.12 -- seconds between spawns for a given group (before wave speed)

	for _, g in ipairs(waveConfig.Enemies) do
		table.insert(groups, {
			Enemy = g.Enemy,
			Remaining = g.Count or 0,
			MinGap = FIXED_GAP,
			_LastSpawnT = 0,
		})
	end

	local function totalRemaining(): number
		local t = 0
		for _, gg in ipairs(groups) do
			t += gg.Remaining
		end
		return t
	end

	local rrIndex = 1
	local function nextGroupToSpawn(now: number, speed: number)
		local n = #groups
		for i = 1, n do
			local idx = ((rrIndex + i - 2) % n) + 1
			local g = groups[idx]
			if g.Remaining > 0 then
				local gap = g.MinGap or 0
				local okByGap = (gap == 0) or (now - g._LastSpawnT) >= (gap / speed)
				if okByGap then
					rrIndex = idx + 1
					return g
				end
			end
		end
		return nil
	end

	local lastActivityT = os.clock()
	local function markActivity()
		lastActivityT = os.clock()
	end

	-- rarity weights for this wave + player rebirths
	local rebirths = profile.Data.Rebirths or 0
	local rarityWeightsForWave = WaveConfigurations.GetRarityWeights(state.CurrentWave, rebirths)

	local enemiesFolder = ReplicatedStorage:WaitForChild("Enemies")
	local mutationsFolder = enemiesFolder:FindFirstChild("Mutations")

	local function spawnOne(fromGroup)
		local baseTemplate = enemiesFolder:FindFirstChild(fromGroup.Enemy) :: Model?
		if not baseTemplate then return end

		-- mutation roll
		local mutationId: string? = nil
		local mutationMult = 1
		if not waveConfig.IsBossWave then
			mutationId = rollEnemyMutationId(player)
			if mutationId then
				local mCfg = MutationConfigurations[mutationId]
				mutationMult = (mCfg and mCfg.Multiplier) or 1.5
			end
		end

		-- choose mutated visual if present
		local templateToUse: Model? = baseTemplate
		if mutationId and mutationsFolder then
			local byMutation = mutationsFolder:FindFirstChild(mutationId)
			if byMutation then
				local mutated = byMutation:FindFirstChild(fromGroup.Enemy)
				if mutated and mutated:IsA("Model") then
					templateToUse = mutated
				end
			end
		end
		if not templateToUse then return end

		local enemy = templateToUse:Clone()
		local hum = enemy:WaitForChild("Humanoid")

		-- rarity
		local spawnRarity = pickRarity(rarityWeightsForWave)
		enemy:SetAttribute("Rarity", spawnRarity)

		-- mutation attrs
		if waveConfig.IsBossWave then
			enemy:SetAttribute("Mutation", "")
			enemy:SetAttribute("KillCashMultiplier", 1)
		else
			if mutationId then
				enemy:SetAttribute("Mutation", mutationId)
				enemy:SetAttribute("KillCashMultiplier", mutationMult)
			else
				enemy:SetAttribute("Mutation", "")
				enemy:SetAttribute("KillCashMultiplier", 1)
			end
		end

		-- health
		local conf = EnemyConfigurations[enemy.Name]
		local baseHealth = (conf and conf.MaxHealth) or hum.MaxHealth
		local waveHealthMult = waveConfig.HealthMultiplier or 1
		local maxHp = math.max(1, math.floor(baseHealth * waveHealthMult * mutationMult))
		hum.MaxHealth, hum.Health = maxHp, maxHp

		-- ðŸ”µ SLOW THEM DOWN so we can have many at once
		local baseSpeed = hum.WalkSpeed
		hum.WalkSpeed = math.max(6, baseSpeed * 0.65)

		if waveConfig.IsBossWave then
			hum.MaxSlopeAngle = 0
			hum.AutoJumpEnabled = false
			hum.JumpPower = 0
		end

		local damageMult = (waveConfig.DamageMultiplier or 1) * mutationMult
		if damageMult ~= 1 then
			enemy:SetAttribute("DamageMultiplier", damageMult)
		end

		local goal = Instance.new("ObjectValue")
		goal.Name = "Goal"
		goal.Value = plot:FindFirstChild("PlotHealth")
		goal.Parent = enemy

		local owner = Instance.new("ObjectValue")
		owner.Name = "OwnerPlot"
		owner.Value = plot
		owner.Parent = enemy

		for _, d in ipairs(enemy:GetDescendants()) do
			if d:IsA("BasePart") then
				d.CollisionGroup = "Zombies"
			end
		end

		enemy:SetPrimaryPartCFrame(getRandomSpawnCFrame(spawnPart))
		enemy.Parent = activeEnemiesFolder
		local root = enemy:FindFirstChild("HumanoidRootPart")
		if root then
			root:SetNetworkOwner(nil)
		end

		if waveConfig.IsBossWave then
			ReplicatedStorage.Events.BossWaveStarted:FireClient(player, hum, waveConfig.BossImageId)
		end

		state.AliveEnemies += 1
		fromGroup.Remaining -= 1
		fromGroup._LastSpawnT = os.clock()
		markActivity()

		hum.Died:Once(function()
			state.AliveEnemies -= 1
			state.EnemiesKilledInWave += 1
			markActivity()

			local profileNow = PlayerController:GetProfile(player)
			if profileNow then
				profileNow.Data.KillsSinceLastBoss = (profileNow.Data.KillsSinceLastBoss or 0) + 1
			end

			local confNow = EnemyConfigurations[enemy.Name]
			if confNow then
				local killMult = waveConfig.KillCashMultiplier
				local extraMult = enemy:GetAttribute("KillCashMultiplier") :: number?
				if extraMult and extraMult ~= 1 then
					killMult = (killMult or 1) * extraMult
				end
				PlayerController.HandleEnemyKill(player, enemy.Name, killMult)
			end

			ReplicatedStorage.Events.ZombieKilled:FireClient(
				player,
				state.EnemiesKilledInWave,
				state.CurrentWave
			)
			enemy:Destroy()

			if state.EnemiesKilledInWave >= state.TotalEnemiesInWave
				and state.IsActive
				and not state.IsStartingNextWave
			then
				state.IsStartingNextWave = true
				task.spawn(function()
					if waveConfig.IsBossWave then
						ReplicatedStorage.Events.BossWaveEnded:FireClient(player)
					end

					if waveConfig.CashReward then
						local ls = player:FindFirstChild("leaderstats")
						local cash = ls and ls:FindFirstChild("Cash")
						if cash then
							cash.Value += waveConfig.CashReward
							ReplicatedStorage.Events.ShowNotification:FireClient(
								player,
								("+" .. tostring(waveConfig.CashReward) .. " Cash"),
								"Success"
							)
						end
					end

					local speedNow = getWaveSpeed(state)
					local pause = (speedNow >= 2) and 0 or (INTERMISSION_TIME / speedNow)
					if pause > 0 then
						task.wait(pause)
					end
					if state.IsActive then
						startNextWave(player, plot)
					end
				end)
			end
		end)
	end

	-- spawn loop â€“ fills up to desired concurrently, but with small gaps
	task.spawn(function()
		while state.IsActive and totalRemaining() > 0 do
			local speed = getWaveSpeed(state)
			local desired = math.max(1, math.floor(BASE_TARGET_CONCURRENT * speed))
			if waveConfig.IsBossWave then
				desired = 1
			end

			if state.AliveEnemies < desired then
				local deficit = math.min(desired - state.AliveEnemies, totalRemaining())
				local nNow = os.clock()
				for _ = 1, deficit do
					local g = nextGroupToSpawn(nNow, speed)
					if g then
						spawnOne(g)
					else
						break
					end
				end
			end

			task.wait(MIN_TICK / speed)
		end
	end)

	-- AFK timeout (unchanged)
	task.spawn(function()
		while state.IsActive and totalRemaining() > 0 do
			if not waveConfig.IsBossWave then
				local now = os.clock()
				if (now - lastActivityT) >= NO_ACTIVITY_TIMEOUT then
					for _, enemy in ipairs(activeEnemiesFolder:GetChildren()) do
						local owner = enemy:FindFirstChild("OwnerPlot")
						if owner and owner.Value == plot then
							enemy:Destroy()
						end
					end
					for _, gg in ipairs(groups) do
						gg.Remaining = 0
					end
					state.AliveEnemies = 0
					state.EnemiesKilledInWave = state.TotalEnemiesInWave

					state.IsStartingNextWave = true
					task.spawn(function()
						if waveConfig.IsBossWave then
							ReplicatedStorage.Events.BossWaveEnded:FireClient(player)
						end

						if waveConfig.CashReward then
							local ls = player:FindFirstChild("leaderstats")
							local cash = ls and ls:FindFirstChild("Cash")
							if cash then
								cash.Value += waveConfig.CashReward
								ReplicatedStorage.Events.ShowNotification:FireClient(
									player,
									("+" .. tostring(waveConfig.CashReward) .. " Cash"),
									"Success"
								)
							end
						end

						local speedNow = getWaveSpeed(state)
						local pause = (speedNow >= 2) and 0 or (INTERMISSION_TIME / speedNow)
						if pause > 0 then
							task.wait(pause)
						end
						if state.IsActive then
							startNextWave(player, plot)
						end
					end)

					return
				end
			end

			task.wait(0.5)
		end
	end)
end


stopFight = function(plot: Model, reason: string)
	local state = _plotStates[plot]
	if not state then return end
	local player = Players:GetPlayerByUserId(plot:GetAttribute("OwnerId"))
	state.IsActive = false

	if state.HealthConnection then
		state.HealthConnection:Disconnect()
		state.HealthConnection = nil
	end

	for _, enemy in ipairs(activeEnemiesFolder:GetChildren()) do
		local owner = enemy:FindFirstChild("OwnerPlot")
		if owner and owner.Value == plot then enemy:Destroy() end
	end

	_plotStates[plot] = nil

	if player then
		if reason == "manual" then
			ReplicatedStorage.Events.EquipLastWeaponRequest:FireClient(player)
		end

		for _, itemModel in ipairs(plot:GetChildren()) do
			if itemModel:GetAttribute("IsPlacedItem") then
				local config = ItemConfigurations[itemModel.Name]
				if config and config.Type == "Turrets" then
					TurretController:RemoveTurret(itemModel)
				end
				itemModel:Destroy()
			end
		end

		task.wait(0.1)
		PlacementController:LoadPlacedItems(player, plot)

		local profile = PlayerController:GetProfile(player)
		if profile then
			local md = ModelProgression[profile.Data.UnlockedModelIndex]
			local maxHealth = (md and md.PlotHealth) or 10
			local plotHealthPart = plot:FindFirstChild("PlotHealth")
			if plotHealthPart then
				plotHealthPart:SetAttribute("Health", maxHealth)
			end
		end

		ReplicatedStorage.Events.WaveStateChanged:FireClient(player, false)
		ReplicatedStorage.Events.WaveUIStateChanged:FireClient(player, false)
		ReplicatedStorage.Events.BossWaveEnded:FireClient(player)

		if reason == "loss" and _autoWaveStates[player] == true then
			task.wait(1)
			if player.Parent then startFight(player) end
		end
	end
end

startFight = function(player: Player)
	local plot = getPlotForPlayer(player)
	if not plot then return end
	local profile = PlayerController:GetProfile(player)
	if not profile or _plotStates[plot] then return end

	local md = ModelProgression[profile.Data.UnlockedModelIndex]
	local maxHealth = (md and md.PlotHealth) or 10

	local plotHealth = plot:FindFirstChild("PlotHealth")
	if not plotHealth then return end
	plotHealth:SetAttribute("Health", maxHealth)

	-- ðŸ”¥ Starting wave logic:
	-- if they've beaten wave 15, start runs from wave 16.
	local startWave = 1
	if profile.Data.HighestWave >= 15 then
		startWave = 16
	end

	local startMultiplier = 1
	if hasFastForwardUnlocked(player) then
		startMultiplier = math.clamp(_preferredMultiplier[player] or 1, 1, 4)
	end

	_plotStates[plot] = {
		IsActive = true,
		CurrentWave = startWave - 1, -- so first startNextWave jumps to startWave
		EnemiesKilledInWave = 0,
		TotalEnemiesInWave = 0,
		IsStartingNextWave = false,
		WaveSpeedMultiplier = startMultiplier,
		AliveEnemies = 0,
		HealthConnection = plotHealth:GetAttributeChangedSignal("Health"):Connect(function()
			if (plotHealth:GetAttribute("Health") or maxHealth) <= 0 then
				ReplicatedStorage.Events.ShowNotification:FireClient(player, "Your plot was destroyed!", "Error")
				stopFight(plot, "loss")
			end
		end),
	}

	local waveSpeedChanged = ReplicatedStorage.Events:FindFirstChild("WaveSpeedChanged")
	if waveSpeedChanged then
		(waveSpeedChanged :: RemoteEvent):FireClient(player, startMultiplier)
	end

	local startingWaveUpdated = ReplicatedStorage.Events:FindFirstChild("StartingWaveUpdated")
	if startingWaveUpdated then
		(startingWaveUpdated :: RemoteEvent):FireClient(player, startWave)
	end

	ReplicatedStorage.Events.WaveStateChanged:FireClient(player, true, maxHealth, maxHealth)
	startNextWave(player, plot)
end

function WaveController:Init(controllers: {[string]: any})
	PlayerController   = controllers.PlayerController
	TurretController   = controllers.TurretController
	PlacementController = controllers.PlacementController
	WeaponController   = controllers.WeaponController
	PlotController     = controllers.PlotController
end

function WaveController:Start()
	local function ensureRemote(name: string): RemoteEvent
		local events = ReplicatedStorage:FindFirstChild("Events") or Instance.new("Folder")
		events.Name = "Events"
		events.Parent = ReplicatedStorage
		local r = events:FindFirstChild(name) :: RemoteEvent?
		if not r then
			r = Instance.new("RemoteEvent")
			r.Name = name
			r.Parent = events
		end
		return r
	end

	ensureRemote("ToggleFastForward")
	ensureRemote("SetWaveSpeedMultiplier")
	ensureRemote("WaveSpeedChanged")
	ensureRemote("StartingWaveUpdated")

	ReplicatedStorage.Events.SetAutoWave.OnServerEvent:Connect(function(player, isEnabled)
		_autoWaveStates[player] = isEnabled
	end)

	ReplicatedStorage.Events.ToggleWaveState.OnServerEvent:Connect(function(player)
		if _fightToggleDebounce[player] then return end
		_fightToggleDebounce[player] = true

		local profile = PlayerController:GetProfile(player)
		if profile and not profile.Data.HasCompletedOnboarding then
			profile.Data.HasCompletedOnboarding = true
			ReplicatedStorage.Events.EndOnboarding:FireClient(player)
		end

		local plot = getPlotForPlayer(player)
		if not plot then
			_fightToggleDebounce[player] = nil
			return
		end

		if _plotStates[plot] and _plotStates[plot].IsActive then
			if _autoWaveStates[player] then
				_autoWaveStates[player] = false
				ReplicatedStorage.Events.AutoWaveStateChanged:FireClient(player, false)
			end
			stopFight(plot, "manual")
		else
			startFight(player)
		end

		task.delay(1, function()
			_fightToggleDebounce[player] = nil
		end)
	end)

	ReplicatedStorage.Events.ToggleFastForward.OnServerEvent:Connect(function(player)
		if not hasFastForwardUnlocked(player) then
			local sn = ReplicatedStorage.Events:FindFirstChild("ShowNotification")
			if sn then sn:FireClient(player, "Unlock Fast-Forward to use this!", "Warning") end
			return
		end
		local plot = getPlotForPlayer(player)
		local state = plot and _plotStates[plot] or nil
		if state and state.IsActive then
			state.WaveSpeedMultiplier = (getWaveSpeed(state) == 1) and 2 or 1
			ReplicatedStorage.Events.WaveSpeedChanged:FireClient(player, state.WaveSpeedMultiplier)
		else
			local cur = math.clamp(_preferredMultiplier[player] or 1, 1, 4)
			local newV = (cur == 1) and 2 or 1
			_preferredMultiplier[player] = newV
			ReplicatedStorage.Events.WaveSpeedChanged:FireClient(player, newV)
			local sn = ReplicatedStorage.Events:FindFirstChild("ShowNotification")
			if sn then sn:FireClient(player, "Fast-Forward set. It will apply on your next wave.", "Normal") end
		end
	end)

	ReplicatedStorage.Events.SetWaveSpeedMultiplier.OnServerEvent:Connect(function(player, m)
		if not hasFastForwardUnlocked(player) then
			local sn = ReplicatedStorage.Events:FindFirstChild("ShowNotification")
			if sn then sn:FireClient(player, "Unlock Fast-Forward to use this!", "Warning") end
			return
		end
		m = tonumber(m) or 1
		m = math.clamp(m, 0.25, 4)
		local plot = getPlotForPlayer(player)
		local state = plot and _plotStates[plot] or nil
		if state and state.IsActive then
			state.WaveSpeedMultiplier = m
			ReplicatedStorage.Events.WaveSpeedChanged:FireClient(player, m)
		else
			_preferredMultiplier[player] = math.max(1, math.floor(m + 0.5))
			ReplicatedStorage.Events.WaveSpeedChanged:FireClient(player, _preferredMultiplier[player])
			local sn = ReplicatedStorage.Events:FindFirstChild("ShowNotification")
			if sn then sn:FireClient(player, "Fast-Forward set. It will apply on your next wave.", "Normal") end
		end
	end)

	Players.PlayerRemoving:Connect(function(player)
		_autoWaveStates[player] = nil
		_preferredMultiplier[player] = nil

		local plot = getPlotForPlayer(player)
		if not plot then return end
		local state = _plotStates[plot]
		if not state then return end

		state.IsActive = false
		if state.HealthConnection then
			state.HealthConnection:Disconnect()
		end

		for _, enemy in ipairs(activeEnemiesFolder:GetChildren()) do
			local owner = enemy:FindFirstChild("OwnerPlot")
			if owner and owner.Value == plot then enemy:Destroy() end
		end
		_plotStates[plot] = nil
	end)
end

return WaveController

---

--- ServerScriptService.Controllers.PhysicsController (ModuleScript) ---
--!strict
local PhysicsService = game:GetService("PhysicsService")
local PhysicsController = {}
function PhysicsController:Start()
	pcall(PhysicsService.RegisterCollisionGroup, PhysicsService, "Players")
	pcall(PhysicsService.RegisterCollisionGroup, PhysicsService, "Zombies")
	PhysicsService:CollisionGroupSetCollidable("Zombies", "Zombies", false)
	PhysicsService:CollisionGroupSetCollidable("Zombies", "Players", false)
	PhysicsService:CollisionGroupSetCollidable("Players", "Players", false)
	--print("Custom collision groups for Players and Zombies have been configured.")
end
return PhysicsController
---

--- ServerScriptService.Controllers.TurretController (ModuleScript) ---
--!strict

local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")

local ItemConfigurations = require(ReplicatedStorage.Modules.ItemConfigurations)
local DamageHandler = require(ReplicatedStorage.Modules.DamageHandler)

local TurretFiredFX = ReplicatedStorage.Events:WaitForChild("TurretFiredFX")

local TurretController = {}
type TurretData = {
	config: any,
	plot: Model,
	lastFireTime: number,
	attachments: {Attachment},
	currentTarget: Model?,
	lockOnTime: number,
}
local _activeTurrets: {[Model]: TurretData} = {}

-- ========= helpers =========

local function enemyIsAlive(m: Model): boolean
	local hum = m:FindFirstChildOfClass("Humanoid")
	return hum ~= nil and hum.Health > 0
end

local function isMortarTurret(turretModel: Model): boolean
	return string.find(turretModel.Name:lower(), "mortar") ~= nil
end

local function safeNum(v: any, fallback: number): number
	local n = tonumber(v)
	if not n or n ~= n or n == math.huge or n == -math.huge then
		return fallback
	end
	return n
end

-- lead point once (simple 2-pass)
local function leadPoint(p0: Vector3, pT: Vector3, vT: Vector3, projSpeed: number): Vector3
	local r = pT - p0
	local t = r.Magnitude / math.max(1, projSpeed)
	local p = pT + vT * t
	local r2 = p - p0
	local t2 = r2.Magnitude / math.max(1, projSpeed)
	return pT + vT * t2
end

-- ballistic solve (returns initial velocity; highArc optional)
local function solveBallistic(p0: Vector3, pT: Vector3, speed: number, highArc: boolean?): Vector3?
	local g = Workspace.Gravity
	local r = pT - p0
	local dxz = Vector3.new(r.X, 0, r.Z)
	local d = dxz.Magnitude
	if d < 1e-3 then return Vector3.new(0, speed, 0) end
	local dir = dxz.Unit
	local vy = r.Y
	local v2 = speed * speed
	local disc = (v2 * v2) - g * (g * d * d + 2 * vy * v2)
	if disc < 0 then return nil end
	local root = math.sqrt(disc)
	local tanHigh = (v2 + root) / (g * d)
	local tanLow  = (v2 - root) / (g * d)
	local theta = math.atan((highArc and tanHigh or tanLow))
	local vxz = math.cos(theta) * speed
	local vy0 = math.sin(theta) * speed
	return dir * vxz + Vector3.yAxis * vy0
end

-- get time of flight from chosen v0 using horizontal motion
local function flightTime(p0: Vector3, pT: Vector3, v0: Vector3, fallbackSpeed: number): number
	local d = (Vector3.new(pT.X, 0, pT.Z) - Vector3.new(p0.X, 0, p0.Z)).Magnitude
	local vxz = Vector3.new(v0.X, 0, v0.Z).Magnitude
	if vxz < 1 then
		return d / math.max(1, fallbackSpeed)
	end
	return d / vxz
end

-- ========= visuals =========

local function explosionVFX(pos: Vector3, splashRadius: number)
	local VIS_MIN, VIS_MAX = 3.5, 6.5
	local vis = math.clamp(splashRadius * 0.35, VIS_MIN, VIS_MAX)

	local effect = Instance.new("Part")
	effect.Anchored = true
	effect.CanCollide = false
	effect.CanQuery = false
	effect.Transparency = 1
	effect.Size = Vector3.new(1,1,1)
	effect.CFrame = CFrame.new(pos)
	effect.Parent = Workspace
	Debris:AddItem(effect, 1.5)

	local smoke = Instance.new("ParticleEmitter")
	smoke.Texture = "rbxassetid://241837157"
	smoke.Color = ColorSequence.new(Color3.fromRGB(255,190,110), Color3.fromRGB(90,70,50))
	smoke.Lifetime = NumberRange.new(0.9, 1.4)
	smoke.Speed = NumberRange.new(12, 18)
	smoke.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, vis * 0.5),
		NumberSequenceKeypoint.new(0.35, vis * 0.9),
		NumberSequenceKeypoint.new(1, vis * 0.35),
	})
	smoke.Rate = 0
	smoke.SpreadAngle = Vector2.new(360, 360)
	smoke.EmissionDirection = Enum.NormalId.Top
	smoke.Drag = 4
	smoke.Parent = effect
	smoke:Emit(math.clamp(math.floor(vis * 10), 25, 70))

	local shock = Instance.new("Part")
	shock.Anchored = true
	shock.CanCollide = false
	shock.CanQuery = false
	shock.Material = Enum.Material.Neon
	shock.Color = Color3.fromRGB(255, 220, 120)
	shock.Shape = Enum.PartType.Ball
	shock.Size = Vector3.new(1,1,1)
	shock.CFrame = CFrame.new(pos)
	shock.Parent = Workspace
	Debris:AddItem(shock, 0.25)

	local light = Instance.new("PointLight")
	light.Brightness = 8
	light.Range = vis * 1.6
	light.Color = Color3.fromRGB(255,200,120)
	light.Parent = shock

	task.spawn(function()
		local t0 = os.clock()
		while shock.Parent do
			local t = os.clock() - t0
			if t > 0.22 then shock:Destroy() break end
			local s = vis * (1.0 + t * 8.0)
			shock.Size = Vector3.new(s, s, s)
			shock.Transparency = math.clamp(t * 4, 0, 1)
			light.Brightness = math.max(0, 8 - t * 40)
			RunService.Heartbeat:Wait()
		end
	end)

	local debrisCount = math.clamp(math.floor(vis * 4), 4, 10)
	for _ = 1, debrisCount do
		local c = Instance.new("Part")
		c.Size = Vector3.new(0.6, 0.6, 0.6)
		c.Material = Enum.Material.Concrete
		c.Color = Color3.fromRGB(112, 100, 90)
		c.Anchored = false
		c.CanCollide = false
		c.CanQuery = false
		c.Massless = true
		c.CFrame = CFrame.new(pos + Vector3.new(0, 0.4, 0))
		c.Parent = Workspace
		local dir = Vector3.new(math.random() - 0.5, math.random() * 0.8 + 0.2, math.random() - 0.5).Unit
		local power = vis * 5
		c.AssemblyLinearVelocity = dir * power
		c.AssemblyAngularVelocity = Vector3.new(math.random(), math.random(), math.random()) * 4
		Debris:AddItem(c, 0.9)
	end
end

-- ========= damage =========

local function splashEnemies(center: Vector3, radius: number, damage: number, attacker: Model, plot: Model)
	local parts = Workspace:GetPartBoundsInRadius(center, radius)
	local hitModels: {[Model]: boolean} = {}
	for _, part in ipairs(parts) do
		local m = part:FindFirstAncestorOfClass("Model")
		if not m or hitModels[m] then continue end
		local op = m:FindFirstChild("OwnerPlot")
		if not op or op.Value ~= plot then continue end
		if not enemyIsAlive(m) then continue end
		if not m:FindFirstChild("Goal") then continue end
		hitModels[m] = true
	end
	for m, _ in pairs(hitModels) do
		pcall(function()
			DamageHandler.dealDamage(attacker, m, damage)
		end)
	end
end

-- ========= mortar projectile =========

local function launchMortarShell(turretModel: Model, fromPos: Vector3, targetModel: Model, cfg: any, plot: Model)
	local speed        = safeNum(cfg.ProjectileSpeed, 120)
	local splashRadius = safeNum(cfg.SplashRadius, 15)
	local damage       = safeNum(cfg.Damage, 100)

	-- fixed prediction at fire time
	local targetRoot = targetModel:FindFirstChild("HumanoidRootPart")
	local tgtPos = targetRoot and targetRoot.Position or targetModel.PrimaryPart.Position
	local tgtVel = targetRoot and targetRoot.AssemblyLinearVelocity or Vector3.zero
	local aimPoint = leadPoint(fromPos, tgtPos, tgtVel, speed)

	-- pick a high arc if possible
	local v0 = solveBallistic(fromPos, aimPoint, speed, true)
		or solveBallistic(fromPos, aimPoint, speed, false)
		or ((aimPoint - fromPos).Unit * (speed * 0.7) + Vector3.yAxis * (speed * 0.5))

	-- compute predicted impact (fixed) from v0
	local tFlight = flightTime(fromPos, aimPoint, v0, speed)
	local g = Vector3.new(0, -Workspace.Gravity, 0)
	local predictedImpact = fromPos + v0 * tFlight + 0.5 * g * (tFlight * tFlight)

	-- shell
	local shell = Instance.new("Part")
	shell.Name = "MortarShell"
	shell.Shape = Enum.PartType.Ball
	shell.Material = Enum.Material.Metal
	shell.Color = Color3.new(0.9, 0.9, 0.9)
	shell.Size = Vector3.new(1.2, 1.2, 1.2)
	shell.CanCollide = false
	shell.CanQuery = false
	shell.CFrame = CFrame.new(fromPos)
	shell.Parent = Workspace

	local a0 = Instance.new("Attachment", shell); a0.Position = Vector3.new(0, -0.5, 0)
	local a1 = Instance.new("Attachment", shell); a1.Position = Vector3.new(0, 0.5, 0)
	local trail = Instance.new("Trail")
	trail.Attachment0 = a0
	trail.Attachment1 = a1
	trail.Lifetime = 0.45
	trail.MinLength = 0.1
	trail.Color = ColorSequence.new(Color3.fromRGB(200,200,200), Color3.fromRGB(255,255,255))
	trail.Transparency = NumberSequence.new(0.05, 1)
	trail.LightEmission = 1
	trail.Parent = shell

	shell.AssemblyLinearVelocity = v0

	-- ignore list for ground checks
	local ignore = {turretModel, plot}
	for _, plr in ipairs(Players:GetPlayers()) do
		if plr.Character then table.insert(ignore, plr.Character) end
	end
	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Exclude
	params.FilterDescendantsInstances = ignore

	local impacted = false
	local minFlight = 0.22
	local startPos = fromPos

	task.spawn(function()
		local t0 = os.clock()
		while shell.Parent and not impacted do
			local age = os.clock() - t0
			if age > 8 then break end

			local pos = shell.Position
			local vel = shell.AssemblyLinearVelocity

			-- detonate near the fixed predicted impact
			local horizToImpact = (Vector3.new(pos.X,0,pos.Z) - Vector3.new(predictedImpact.X,0,predictedImpact.Z)).Magnitude
			local nearImpact = horizToImpact <= math.max(2.5, splashRadius * 0.4)
			local belowImpact = pos.Y <= (predictedImpact.Y + math.max(1.0, splashRadius * 0.15))

			local traveled = (Vector3.new(pos.X,0,pos.Z) - Vector3.new(startPos.X,0,startPos.Z)).Magnitude

			if age > minFlight and nearImpact and belowImpact and traveled >= 10 then
				impacted = true
				explosionVFX(pos, splashRadius)
				splashEnemies(pos, splashRadius, damage, turretModel, plot)
				shell:Destroy()
				break
			end

			-- descending + ground proximity
			if age > minFlight and vel.Y < -2 then
				local down = Workspace:Raycast(pos, Vector3.new(0, -8, 0), params)
				if down and (pos.Y - down.Position.Y) <= 2.1 and traveled >= 10 then
					impacted = true
					explosionVFX(down.Position, splashRadius)
					splashEnemies(down.Position, splashRadius, damage, turretModel, plot)
					shell:Destroy()
					break
				end
			end

			RunService.Heartbeat:Wait()
		end

		if not impacted and shell.Parent then
			impacted = true
			explosionVFX(shell.Position, splashRadius)
			splashEnemies(shell.Position, splashRadius, damage, turretModel, plot)
			shell:Destroy()
		end
	end)
end

-- ========= main loop =========

function TurretController:AddTurret(turretModel: Model, plot: Model)
	local cfg = ItemConfigurations[turretModel.Name]
	if not cfg then
		warn("Missing ItemConfiguration for turret:", turretModel.Name)
		return
	end

	local attachments = {} :: {Attachment}
	for _, d in ipairs(turretModel:GetDescendants()) do
		if d:IsA("Attachment") and d.Name == "Muzzle" then
			table.insert(attachments, d)
		end
	end

	_activeTurrets[turretModel] = {
		config = cfg,
		plot = plot,
		lastFireTime = 0,
		attachments = attachments,
		currentTarget = nil,
		lockOnTime = 0,
	}
end

function TurretController:RemoveTurret(turretModel: Model)
	_activeTurrets[turretModel] = nil
end

function TurretController:Start()
	RunService.Heartbeat:Connect(function()
		local enemiesFolder = Workspace:FindFirstChild("ActiveEnemies")
		if not enemiesFolder then return end
		local now = os.clock()

		for turretModel, data in pairs(_activeTurrets) do
			if not turretModel.Parent or not turretModel.PrimaryPart then
				_activeTurrets[turretModel] = nil
				continue
			end

			local fireRate  = safeNum(data.config.FireRate, 1)
			local range     = safeNum(data.config.Range, 60)
			local damage    = safeNum(data.config.Damage, 10)
			local lockDelay = safeNum(data.config.LockOnDelay, 0.1)
			local minRange  = safeNum(data.config.MinRange, 16) -- mortar dead-zone

			-- nearest target on same plot
			local turretPos = turretModel.PrimaryPart.Position
			local bestTarget: Model? = nil
			local bestDist = range
			for _, enemy in ipairs(enemiesFolder:GetChildren()) do
				local op = enemy:FindFirstChild("OwnerPlot")
				local root = enemy:FindFirstChild("HumanoidRootPart")
				if op and op.Value == data.plot and root and enemyIsAlive(enemy) then
					local dist = (root.Position - turretPos).Magnitude
					if dist < bestDist then
						bestDist = dist
						bestTarget = enemy
					end
				end
			end

			if bestTarget ~= data.currentTarget then
				data.lockOnTime = now
				data.currentTarget = bestTarget
			end

			if now - data.lastFireTime < (1 / fireRate) then continue end
			if not data.currentTarget or now - data.lockOnTime < lockDelay then continue end

			local targetRoot = data.currentTarget:FindFirstChild("HumanoidRootPart")
			if not targetRoot then continue end

			data.lastFireTime = now

			-- pick origins (muzzles or primary)
			local origins: {Vector3} = {}
			if #data.attachments > 0 then
				for _, a in ipairs(data.attachments) do table.insert(origins, a.WorldPosition) end
			else
				table.insert(origins, turretModel.PrimaryPart.Position)
			end

			for _, origin in ipairs(origins) do
				if isMortarTurret(turretModel) then
					local toTarget = (targetRoot.Position - origin)
					-- enforce dead-zone but otherwise allow full Range
					if toTarget.Magnitude < minRange then
						continue
					end
					launchMortarShell(turretModel, origin, data.currentTarget :: Model, data.config, data.plot)
				else
					-- normal hitscan
					local direction = (targetRoot.Position - origin).Unit
					local raycastParams = RaycastParams.new()
					raycastParams.FilterType = Enum.RaycastFilterType.Exclude
					raycastParams.FilterDescendantsInstances = { turretModel, data.plot }
					local result = Workspace:Raycast(origin, direction * range, raycastParams)

					local ownerId = data.plot:GetAttribute("OwnerId")
					local owner = ownerId and Players:GetPlayerByUserId(ownerId)

					if result and result.Instance then
						local hitModel = result.Instance.Parent
						local hum = hitModel and hitModel:FindFirstChildOfClass("Humanoid")
						if hum and hitModel:FindFirstChild("Goal") then
							DamageHandler.dealDamage(turretModel, hitModel, damage)
						end
						--if owner then TurretFiredFX:FireClient(owner, turretModel, origin, result.Position) end
					else
						--if owner then TurretFiredFX:FireClient(owner, turretModel, origin, origin + direction * range) end
					end
				end
			end
		end
	end)
end

return TurretController

---

--- ServerScriptService.Controllers.WeaponsShopController (ModuleScript) ---
--!strict
-- GLOBAL WEAPON SHOP CONTROLLER (global baseline + personal stock; purchases are per-player)

local ReplicatedStorage     = game:GetService("ReplicatedStorage")
local Players               = game:GetService("Players")
local MarketplaceService    = game:GetService("MarketplaceService")
local ServerScriptService   = game:GetService("ServerScriptService")

local Modules               = ReplicatedStorage:WaitForChild("Modules")
local WeaponConfigurations  = require(Modules:WaitForChild("WeaponConfigurations"))
local ItemConfigurations    = require(Modules:WaitForChild("ItemConfigurations"))
local NumberFormatter       = require(Modules:WaitForChild("NumberFormatter"))
local BadgeController       = require(ServerScriptService.Controllers:WaitForChild("BadgeController"))

local PlayerController      : any
local CrateController       : any
local BlocksShopController  : any
local GlobalShopController  : any
local RepairSignController  : any
local LevelUpController     : any

local MAX_CRATES = 3

local ShopController = {}
local pendingSkips: {[Player]: Model} = {}

-- ===== Product ids =====
-- Server luck
local PRODUCT_SERVERLUCK_X2       = 3446300267 -- 2x (299R$)
local PRODUCT_SERVERLUCK_X4       = 3446300425 -- 4x (799R$)
local PRODUCT_SERVERLUCK_X10      = 3446300596 -- 10x (999R$)

-- Level-up & repair
local PRODUCT_LEVELUP_SKIP        = 3445097534 -- level-up skip timer
local PRODUCT_REPAIR_ALL          = 3444162940 -- revive/repair all (if you still use it)

-- Cash dev products
local PRODUCT_CASH_5K             = 3433108028
local PRODUCT_CASH_25K            = 3433108213
local PRODUCT_CASH_100K           = 3433108417
local PRODUCT_CASH_300K           = 3433108573

-- Remotes
local Events = ReplicatedStorage:WaitForChild("Events")
local purchaseItemEvent       = Events:WaitForChild("PurchaseWeaponCrate") :: RemoteEvent
local updateStocksEvent       = Events:WaitForChild("UpdateWeaponStocks") :: RemoteEvent
local showNotificationEvent   = Events:WaitForChild("ShowNotification") :: RemoteEvent
local promptSkipTimerRequest  = Events:WaitForChild("PromptSkipTimerRequest") :: RemoteEvent

local chatAnnouncementEvent   = Events:FindFirstChild("ChatAnnouncement") :: RemoteEvent?
if not chatAnnouncementEvent then
	chatAnnouncementEvent = Instance.new("RemoteEvent")
	chatAnnouncementEvent.Name = "ChatAnnouncement"
	chatAnnouncementEvent.Parent = Events
end

-- Broadcast server luck state to clients (for Shop UI)
local serverLuckStateEvent = Events:FindFirstChild("ServerLuckState") :: RemoteEvent?
if not serverLuckStateEvent then
	serverLuckStateEvent = Instance.new("RemoteEvent")
	serverLuckStateEvent.Name = "ServerLuckState"
	serverLuckStateEvent.Parent = Events
end

local Functions               = ReplicatedStorage:WaitForChild("Functions")
local getResetTime            = Functions:WaitForChild("GetWeaponShopResetTime") :: RemoteFunction
local getStocks               = Functions:WaitForChild("GetWeaponShopStocks") :: RemoteFunction

-- Robux spent signal
local SignalsFolder = ReplicatedStorage:FindFirstChild("Signals")
	or Instance.new("Folder")
SignalsFolder.Name = "Signals"
SignalsFolder.Parent = ReplicatedStorage

local RobuxSpentEvent = SignalsFolder:FindFirstChild("RobuxSpent") or Instance.new("BindableEvent")
RobuxSpentEvent.Name = "RobuxSpent"
RobuxSpentEvent.Parent = SignalsFolder
local RobuxSpent = RobuxSpentEvent :: BindableEvent

-- === Announcements ===
local function announcePurchase(player: Player, productLabel: string)
	if not chatAnnouncementEvent then return end
	local msg = string.format("[SHOP] %s just bought %s ðŸŽ‰", player.DisplayName, productLabel)
	chatAnnouncementEvent:FireAllClients(msg)
end

-- === Price cache helpers ===
local priceCache: {[string]: number} = {}
local processedPurchaseIds: {[string]: boolean} = {}

local function cacheKey(kind: string, id: number): string
	return string.format("%s:%d", kind, id)
end

local function getDevProductPriceR(productId: number): number
	local key = cacheKey("product", productId)
	if priceCache[key] then return priceCache[key] end
	local price = 0
	local ok, info = pcall(function()
		return MarketplaceService:GetProductInfo(productId, Enum.InfoType.Product)
	end)
	if ok and info and typeof(info.PriceInRobux) == "number" then
		price = math.max(0, info.PriceInRobux)
	end
	priceCache[key] = price
	return price
end

local function getGamePassPriceR(gamePassId: number): number
	local key = cacheKey("gamepass", gamePassId)
	if priceCache[key] then return priceCache[key] end
	local price = 0
	local ok, info = pcall(function()
		return MarketplaceService:GetProductInfo(gamePassId, Enum.InfoType.GamePass)
	end)
	if ok and info and typeof(info.PriceInRobux) == "number" then
		price = math.max(0, info.PriceInRobux)
	end
	priceCache[key] = price
	return price
end

-- === Server luck state helpers ===

local function getServerLuckState(): (number, number)
	local multAttr = ReplicatedStorage:GetAttribute("ServerLuckMultiplier")
	local expAttr  = ReplicatedStorage:GetAttribute("ServerLuckExpiresAt")

	local mult = (typeof(multAttr) == "number" and multAttr or 1) :: number
	local expiresAt = (typeof(expAttr) == "number" and expAttr or 0) :: number

	local now = os.time()
	if expiresAt <= now then
		mult = 1
		expiresAt = 0
	end

	return mult, expiresAt
end

-- mode:
--   addIfSame = true  -> if same mult & active, add time, else reset
--   addIfSame = false -> always reset timer
local function setServerLuck(mult: number, durationSeconds: number, addIfSame: boolean)
	if mult < 1 then
		mult = 1
	end

	local now = os.time()
	local currentMult, currentExpires = getServerLuckState()

	local newMult = mult
	local newExpires: number

	if addIfSame and currentMult == mult and currentExpires > now then
		-- extend existing buff
		newExpires = currentExpires + durationSeconds
	else
		-- reset timer & set new mult
		newMult = mult
		newExpires = now + durationSeconds
	end

	ReplicatedStorage:SetAttribute("ServerLuckMultiplier", newMult)
	ReplicatedStorage:SetAttribute("ServerLuckExpiresAt", newExpires)

	local remaining = math.max(0, newExpires - now)
	serverLuckStateEvent:FireAllClients(newMult, remaining)
end

-- === Product mapping ===
local function getProductConfig(productId: number)
	for id, config in pairs(WeaponConfigurations.ShopProducts) do
		if config.ProductID == productId then return id, config, "ShopAction" end
	end
	for id, config in pairs(WeaponConfigurations.CashProducts) do
		if config.ProductID == productId then return id, config, "Cash" end
	end
	for id, config in pairs(WeaponConfigurations.Crates) do
		if config.ProductID == productId or config.SkipTimerProductID == productId then
			return id, config, "Crate"
		end
	end
	for id, config in pairs(ItemConfigurations) do
		if config.ProductID == productId then return id, config, "BlockOrTurret" end
	end
	return nil, nil, nil
end

-- === Receipt processing (ONLY here) ===
local function processReceipt(receiptInfo: {[string]: any})
	local playerId   = receiptInfo.PlayerId
	local productId  = receiptInfo.ProductId
	local purchaseId = tostring(receiptInfo.PurchaseId or "")
	local player     = Players:GetPlayerByUserId(playerId)
	if not player then return Enum.ProductPurchaseDecision.NotProcessedYet end

	local function grantAndCount(
		decision: Enum.ProductPurchaseDecision,
		productLabel: string?
	)
		if decision == Enum.ProductPurchaseDecision.PurchaseGranted and not processedPurchaseIds[purchaseId] then
			processedPurchaseIds[purchaseId] = true
			local robux = getDevProductPriceR(productId)
			if robux > 0 then
				RobuxSpent:Fire(playerId, robux)
				if productLabel then
					announcePurchase(player, productLabel)
				end
			end
		end
		return decision
	end

	-- ===== Server luck products (2x, 4x, 10x) =====
	if productId == PRODUCT_SERVERLUCK_X2 then
		-- Always reset to 15 minutes at 2x
		setServerLuck(2, 15 * 60, false)
		showNotificationEvent:FireClient(player, "Server Luck set to 2x for 15 minutes!", "Success")
		return grantAndCount(Enum.ProductPurchaseDecision.PurchaseGranted, "2x Server Luck")

	elseif productId == PRODUCT_SERVERLUCK_X4 then
		-- Always reset to 15 minutes at 4x
		setServerLuck(4, 15 * 60, false)
		showNotificationEvent:FireClient(player, "Server Luck set to 4x for 15 minutes!", "Success")
		return grantAndCount(Enum.ProductPurchaseDecision.PurchaseGranted, "4x Server Luck")

	elseif productId == PRODUCT_SERVERLUCK_X10 then
		-- If already 10x and active, add 15 minutes; otherwise set 10x and reset to 15
		setServerLuck(10, 15 * 60, true)
		showNotificationEvent:FireClient(player, "MAX Server Luck (10x) extended by 15 minutes!", "Success")
		return grantAndCount(Enum.ProductPurchaseDecision.PurchaseGranted, "MAX Server Luck")
	end

	-- ===== Explicit Cash devproducts (5k / 25k / 100k / 300k) =====
	if
		productId == PRODUCT_CASH_5K
		or productId == PRODUCT_CASH_25K
		or productId == PRODUCT_CASH_100K
		or productId == PRODUCT_CASH_300K
	then
		local amount = 0
		if productId == PRODUCT_CASH_5K then
			amount = 5_000
		elseif productId == PRODUCT_CASH_25K then
			amount = 25_000
		elseif productId == PRODUCT_CASH_100K then
			amount = 100_000
		elseif productId == PRODUCT_CASH_300K then
			amount = 300_000
		end

		if amount > 0 then
			PlayerController.AddCash(player, amount)
			showNotificationEvent:FireClient(
				player,
				`You received ${NumberFormatter.formatNumber(amount)} cash!`,
				"Success"
			)
			local label = NumberFormatter.formatNumber(amount) .. " Cash"
			return grantAndCount(Enum.ProductPurchaseDecision.PurchaseGranted, label)
		end
	end

	-- ===== Level-up skip product =====
	if productId == PRODUCT_LEVELUP_SKIP then
		if LevelUpController then
			local ok = LevelUpController:SkipActiveJob(player)
			if ok then
				return grantAndCount(Enum.ProductPurchaseDecision.PurchaseGranted, "Level-Up Timer Skip")
			end
		end
		-- If we can't skip for some reason, don't consume the purchase.
		return Enum.ProductPurchaseDecision.NotProcessedYet
	end

	-- ===== Config-mapped products =====
	local itemId, config, productType = getProductConfig(productId)
	if not itemId or not config or not productType then
		return Enum.ProductPurchaseDecision.NotProcessedYet
	end

	if productType == "ShopAction" then
		if itemId == "RestockBlocksShop" then
			BlocksShopController:PersonalRestock(player)
			showNotificationEvent:FireClient(player, "Blocks Shop Restocked (Personal)!", "Success")
			return grantAndCount(
				Enum.ProductPurchaseDecision.PurchaseGranted,
				config.DisplayName or "Blocks Shop Restock"
			)

		elseif itemId == "RestockWeaponsShop" then
			GlobalShopController:AddPersonalWeapons(player)
			showNotificationEvent:FireClient(player, "Weapons Shop Restocked (Personal)!", "Success")
			return grantAndCount(
				Enum.ProductPurchaseDecision.PurchaseGranted,
				config.DisplayName or "Weapons Shop Restock"
			)
		end

	elseif productType == "Cash" then
		-- Old config-based cash path (still works if you keep WeaponConfigurations.CashProducts)
		PlayerController.AddCash(player, config.CashAmount)
		showNotificationEvent:FireClient(
			player,
			`You received ${NumberFormatter.formatNumber(config.CashAmount)} cash!`,
			"Success"
		)
		local label = config.DisplayName or (NumberFormatter.formatNumber(config.CashAmount) .. " Cash")
		return grantAndCount(Enum.ProductPurchaseDecision.PurchaseGranted, label)

	elseif productType == "BlockOrTurret" then
		local profile = PlayerController:GetProfile(player)
		if not profile then return Enum.ProductPurchaseDecision.NotProcessedYet end
		local inv = profile.Data.BlockInventory
		inv[itemId] = (inv[itemId] or 0) + 1
		ReplicatedStorage.Events.BlockInventoryUpdated:FireClient(player, inv)
		showNotificationEvent:FireClient(player, `Purchased {config.DisplayName}!`, "Success")
		if config.Type == "Turrets" then
			BadgeController.SyncForNewItem(player, itemId)
		end
		return grantAndCount(
			Enum.ProductPurchaseDecision.PurchaseGranted,
			config.DisplayName or itemId
		)

	elseif productType == "Crate" then
		if productId == WeaponConfigurations.Crates.GoldCrate.ProductID then
			local loot = config.Loot
			local total = 0
			for _, l in ipairs(loot) do total += l.Weight end
			local roll = math.random() * total
			local chosen = loot[#loot].Item
			for _, l in ipairs(loot) do
				if roll <= l.Weight then
					chosen = l.Item
					break
				else
					roll -= l.Weight
				end
			end

			local profile = PlayerController:GetProfile(player)
			if chosen and profile and not table.find(profile.Data.WeaponInventory, chosen) then
				table.insert(profile.Data.WeaponInventory, chosen)
			end
			local wcfg = WeaponConfigurations.Weapons[chosen]
			ReplicatedStorage.Events.ShowModelAward:FireClient(player, wcfg.DisplayName, wcfg.ImageId)
			ReplicatedStorage.Events.WeaponInventoryUpdated:FireClient(player, profile.Data.WeaponInventory)
			return grantAndCount(
				Enum.ProductPurchaseDecision.PurchaseGranted,
				config.DisplayName or "Gold Crate"
			)

		elseif config.SkipTimerProductID and productId == config.SkipTimerProductID then
			local crate = pendingSkips[player]
			if crate and crate.Parent then
				crate:SetAttribute("UnlockTimestamp", 0)
				pendingSkips[player] = nil
				showNotificationEvent:FireClient(player, "Timer Skipped!", "Success")
				return grantAndCount(
					Enum.ProductPurchaseDecision.PurchaseGranted,
					"Crate Timer Skip"
				)
			end

		else
			local profile = PlayerController:GetProfile(player)
			if not profile then return Enum.ProductPurchaseDecision.NotProcessedYet end
			if #profile.Data.Crates >= MAX_CRATES then
				return Enum.ProductPurchaseDecision.NotProcessedYet
			end
			while not CrateController do task.wait() end
			if CrateController:PurchaseCrate(player, itemId, true) then
				showNotificationEvent:FireClient(player, "Purchase Successful!", "Success")
				return grantAndCount(
					Enum.ProductPurchaseDecision.PurchaseGranted,
					config.DisplayName or itemId
				)
			end
		end
	end

	return Enum.ProductPurchaseDecision.NotProcessedYet
end

-- CASH purchase path (per-player stock)
local function onPurchaseRequest(player: Player, itemId: string)
	local profile = PlayerController:GetProfile(player)
	local config = WeaponConfigurations.Crates[itemId]
	if not profile or not config then return end

	local myStock = GlobalShopController:GetPlayerWeapons(player)
	if not config.Unlimited and (myStock[itemId] or 0) <= 0 then
		showNotificationEvent:FireClient(player, "This item is out of stock!", "Error")
		return
	end

	local currentCash = profile.Data.Cash or 0
	if currentCash < config.Price then
		showNotificationEvent:FireClient(player, "Not enough cash!", "Error")
		return
	end

	while not CrateController do task.wait() end
	if CrateController:PurchaseCrate(player, itemId) then
		local ok = PlayerController.RemoveCash(player, config.Price)
		if not ok then
			showNotificationEvent:FireClient(player, "This crate just went out of stock!", "Error")
			return
		end

		if not config.Unlimited then
			local consumed = GlobalShopController:ConsumeWeapons(player, itemId)
			if not consumed then
				showNotificationEvent:FireClient(player, "This crate just went out of stock!", "Error")
			end
		end
	end
end

function ShopController:RequestSkipTimer(player: Player, crateModel: Model)
	local ctype = crateModel:GetAttribute("CrateType")
	if not ctype then return end
	local cfg = WeaponConfigurations.Crates[ctype]
	if not cfg or not cfg.SkipTimerProductID then return end
	pendingSkips[player] = crateModel
	promptSkipTimerRequest:FireClient(player, cfg.SkipTimerProductID)
end

function ShopController:Init(controllers: {[string]: any})
	PlayerController      = controllers.PlayerController
	CrateController       = controllers.CrateController
	BlocksShopController  = controllers.BlocksShopController
	GlobalShopController  = controllers.GlobalShopController
	RepairSignController  = controllers.RepairSignController
	LevelUpController     = controllers.LevelUpController
end

function ShopController:Start()
	-- Initialize server-luck attributes
	if ReplicatedStorage:GetAttribute("ServerLuckMultiplier") == nil then
		ReplicatedStorage:SetAttribute("ServerLuckMultiplier", 1)
	end
	if ReplicatedStorage:GetAttribute("ServerLuckExpiresAt") == nil then
		ReplicatedStorage:SetAttribute("ServerLuckExpiresAt", 0)
	end

	-- Small loop to clear expired server luck and notify clients
	task.spawn(function()
		while true do
			local mult, expiresAt = getServerLuckState()
			local now = os.time()
			if mult > 1 and expiresAt > 0 and expiresAt <= now then
				ReplicatedStorage:SetAttribute("ServerLuckMultiplier", 1)
				ReplicatedStorage:SetAttribute("ServerLuckExpiresAt", 0)
				serverLuckStateEvent:FireAllClients(1, 0)
			end
			task.wait(1)
		end
	end)

	MarketplaceService.ProcessReceipt = processReceipt

	MarketplaceService.PromptGamePassPurchaseFinished:Connect(function(player: Player, id: number, purchased: boolean)
		if not purchased then return end
		local robux = getGamePassPriceR(id)
		if robux > 0 then
			RobuxSpent:Fire(player.UserId, robux)
			announcePurchase(player, "a Game Pass")
		end
	end)

	getResetTime.OnServerInvoke = function()
		while not GlobalShopController do task.wait() end
		return GlobalShopController:GetNextRestock()
	end

	getStocks.OnServerInvoke = function(player)
		while not GlobalShopController do task.wait() end
		return GlobalShopController:GetPlayerWeapons(player)
	end

	purchaseItemEvent.OnServerEvent:Connect(onPurchaseRequest)
end

return ShopController

---

--- ServerScriptService.Controllers.WeaponController (ModuleScript) ---
--!strict
-- This controller securely handles requests to equip, unequip, and select weapons.

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local WEAPONS_FOLDER = ReplicatedStorage:WaitForChild("Weapons")

local WaveController
local PlayerController
local WeaponController = {}

function WeaponController:UnequipWeapon(player: Player)
	local character = player.Character
	if not character then return end
	local existingTool = character:FindFirstChildOfClass("Tool")
	if existingTool then
		existingTool:Destroy()
	end
end

function WeaponController:EquipWeapon(player: Player, weaponName: string)
	local character = player.Character
	local profile = PlayerController:GetProfile(player)
	if not character or not profile then return end

	if not table.find(profile.Data.WeaponInventory, weaponName) then
		-- This can happen if the last equipped weapon was removed from their inventory later.
		-- Silently fail instead of printing a warning.
		return
	end

	self:UnequipWeapon(player)

	local weaponTemplate = WEAPONS_FOLDER:FindFirstChild(weaponName)
	if weaponTemplate then
		local newWeapon = weaponTemplate:Clone()
		newWeapon.Parent = character
		-- ## REMOVED ## No longer setting the attribute here.
	end
end

local function onEquipRequest(player: Player, weaponName: string)
	if WaveController:IsPlayerFighting(player) then return end
	WeaponController:EquipWeapon(player, weaponName)
end

local function onUnequipRequest(player: Player)
	WeaponController:UnequipWeapon(player)
end

local function onEquipLastRequest(player: Player)
	local lastWeapon = player:GetAttribute("LastEquippedWeapon")
	if typeof(lastWeapon) == "string" then
		WeaponController:EquipWeapon(player, lastWeapon)
	end
end

local function onSetSelectedWeapon(player: Player, weaponName: string)
	local profile = PlayerController:GetProfile(player)
	if not profile then return end

	if table.find(profile.Data.WeaponInventory, weaponName) then
		player:SetAttribute("LastEquippedWeapon", weaponName)
		profile.Data.LastEquippedWeapon = weaponName
	end
end

function WeaponController:Init(controllers: {[string]: any})
	WaveController = controllers.WaveController
	PlayerController = controllers.PlayerController
end

function WeaponController:Start()
	ReplicatedStorage.Events.EquipWeaponRequest.OnServerEvent:Connect(onEquipRequest)
	ReplicatedStorage.Events.UnequipWeaponRequest.OnServerEvent:Connect(onUnequipRequest)
	ReplicatedStorage.Events.EquipLastWeaponRequest.OnServerEvent:Connect(onEquipLastRequest)
	ReplicatedStorage.Events.SetSelectedWeaponRequest.OnServerEvent:Connect(onSetSelectedWeapon) -- ## ADDED ##
end

return WeaponController
---

--- ServerScriptService.Controllers.CrateController (ModuleScript) ---
--!strict
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local MarketplaceService = game:GetService("MarketplaceService")

local WeaponConfigurations = require(ReplicatedStorage.Modules.WeaponConfigurations)
local PlayerController
local WeaponsShopController

local CRATE_MODELS = ReplicatedStorage:WaitForChild("Crates")

local BASE_MAX_CRATES = 3
local GAMEPASS_EXTRA_CRATE_SLOTS = 1572988194
local EXTRA_SLOTS = 3

local CrateController = {}
local crateInteractionDebounce: {[Model]: boolean} = {}

local Events = ReplicatedStorage:FindFirstChild("Events") or Instance.new("Folder")
Events.Name = "Events"
Events.Parent = ReplicatedStorage

local function ensureRemoteEvent(name: string): RemoteEvent
	local ev = Events:FindFirstChild(name) :: RemoteEvent?
	if not ev then ev = Instance.new("RemoteEvent") ev.Name = name ev.Parent = Events end
	return ev
end

local UpdateCrateCapacity = ensureRemoteEvent("UpdateCrateCapacity")
local CrateDataUpdated = ensureRemoteEvent("CrateDataUpdated")
local ShowModelAward = ensureRemoteEvent("ShowModelAward")
local WeaponInventoryUpdated = ensureRemoteEvent("WeaponInventoryUpdated")
local ShowNotification = ensureRemoteEvent("ShowNotification")

function CrateController:GetMaxCrates(player: Player): number
	local profile = PlayerController and PlayerController:GetProfile(player)
	local owns = false
	if profile and profile.Data then
		owns = profile.Data.OwnsExtraCrateGP == true
	else
		local attr = player:GetAttribute("HasCrateSlotsPass")
		owns = (typeof(attr) == "boolean" and attr) or false
	end
	return BASE_MAX_CRATES + (owns and EXTRA_SLOTS or 0)
end

local function pushCapacityToClient(player: Player)
	UpdateCrateCapacity:FireClient(player, CrateController:GetMaxCrates(player))
end

MarketplaceService.PromptGamePassPurchaseFinished:Connect(function(player: Player, gamePassId: number, wasPurchased: boolean)
	if gamePassId ~= GAMEPASS_EXTRA_CRATE_SLOTS then return end
	local profile = PlayerController and PlayerController:GetProfile(player)
	if profile and profile.Data then
		profile.Data.OwnsExtraCrateGP = wasPurchased or profile.Data.OwnsExtraCrateGP
	end
	player:SetAttribute("HasCrateSlotsPass", wasPurchased or player:GetAttribute("HasCrateSlotsPass") == true)
	pushCapacityToClient(player)
end)

local function getPlotForPlayer(player: Player): Model?
	local plotNum = player:GetAttribute("PlotNumber")
	if plotNum then
		local plot = Workspace.Plots:FindFirstChild("Plot" .. tostring(plotNum))
		if plot and plot:IsA("Model") then return plot end
	end
	for _, plot in ipairs(Workspace.Plots:GetChildren()) do
		if plot:IsA("Model") and plot:GetAttribute("OwnerId") == player.UserId then return plot end
	end
	return nil
end

local function getAvailableSpawnCount(plot: Model): number
	local folder = plot:FindFirstChild("Crate")
	if not folder then return 0 end
	local n = 0
	for _, ch in ipairs(folder:GetChildren()) do
		if ch:IsA("BasePart") and ch.Name:match("^CrateSpawn%d+$") then n += 1 end
	end
	if n == 0 then
		for i = 1, 12 do
			if folder:FindFirstChild("CrateSpawn" .. i) then n += 1 else break end
		end
	end
	return n
end

local function onOpenCrate(player: Player, crateModel: Model)
	local profile = PlayerController:GetProfile(player)
	if not profile or not crateModel.Parent then return end
	local spawnIndex = crateModel:GetAttribute("SpawnIndex")
	local crateDataIndex = -1
	for i, data in ipairs(profile.Data.Crates) do
		if data.SpawnIndex == spawnIndex then crateDataIndex = i break end
	end
	if crateDataIndex == -1 then return end
	local crateType = profile.Data.Crates[crateDataIndex].Type
	local lootTable = WeaponConfigurations.Crates[crateType].Loot
	local totalWeight = 0
	for _, loot in ipairs(lootTable) do totalWeight += loot.Weight end
	local roll = math.random() * totalWeight
	local chosenWeaponId: string = lootTable[#lootTable].Item
	for _, loot in ipairs(lootTable) do
		if roll <= loot.Weight then chosenWeaponId = loot.Item break else roll -= loot.Weight end
	end
	if chosenWeaponId and not table.find(profile.Data.WeaponInventory, chosenWeaponId) then
		table.insert(profile.Data.WeaponInventory, chosenWeaponId)
	end
	table.remove(profile.Data.Crates, crateDataIndex)
	crateModel:Destroy()
	local weaponConfig = WeaponConfigurations.Weapons[chosenWeaponId]
	ShowModelAward:FireClient(player, weaponConfig.DisplayName, weaponConfig.ImageId)
	WeaponInventoryUpdated:FireClient(player, profile.Data.WeaponInventory)
	CrateDataUpdated:FireClient(player, profile.Data.Crates)
end

function CrateController:SpawnCrateModel(plot: Model, crateData: table)
	local crateTemplate = CRATE_MODELS:FindFirstChild(crateData.Type)
	local crateSpawns = plot:FindFirstChild("Crate")
	if not crateTemplate or not crateSpawns or not crateTemplate.PrimaryPart then return end
	local spawnPart = crateSpawns:FindFirstChild("CrateSpawn" .. crateData.SpawnIndex)
	if not spawnPart then return end
	local newCrate = crateTemplate:Clone()
	newCrate:SetAttribute("OwnerId", plot:GetAttribute("OwnerId"))
	newCrate:SetAttribute("UnlockTimestamp", crateData.UnlockTimestamp)
	newCrate:SetAttribute("SpawnIndex", crateData.SpawnIndex)
	newCrate:SetAttribute("CrateType", crateData.Type)
	newCrate:SetPrimaryPartCFrame(spawnPart.CFrame * CFrame.new(0, 3, 0))
	newCrate.Parent = crateSpawns
	newCrate.PrimaryPart.Touched:Connect(function(hit)
		if crateInteractionDebounce[newCrate] then return end
		local toucher = hit.Parent
		if not toucher then return end
		local player = Players:GetPlayerFromCharacter(toucher)
		if not player or player.UserId ~= newCrate:GetAttribute("OwnerId") then return end
		crateInteractionDebounce[newCrate] = true
		local unlockTime = newCrate:GetAttribute("UnlockTimestamp")
		if os.time() >= unlockTime then
			onOpenCrate(player, newCrate)
			crateInteractionDebounce[newCrate] = nil
		else
			while not WeaponsShopController do task.wait() end
			WeaponsShopController:RequestSkipTimer(player, newCrate)
			task.delay(2, function() crateInteractionDebounce[newCrate] = nil end)
		end
	end)
end

function CrateController:PurchaseCrate(player: Player, crateId: string, isRobuxPurchase: boolean?): boolean
	local profile = PlayerController:GetProfile(player)
	local plot = getPlotForPlayer(player)
	if not profile or not plot then return false end
	local maxByPass = self:GetMaxCrates(player)
	local availableSpawns = getAvailableSpawnCount(plot)
	local capacity = math.max(1, math.min(maxByPass, availableSpawns))
	if #profile.Data.Crates >= capacity then
		if not isRobuxPurchase then ShowNotification:FireClient(player, "All crate slots are full!", "Error") end
		return false
	end
	local usedIndexes: {[number]: true} = {}
	for _, existingCrate in ipairs(profile.Data.Crates) do
		usedIndexes[existingCrate.SpawnIndex] = true
	end
	local spawnIndex = -1
	for i = 1, capacity do
		if not usedIndexes[i] then spawnIndex = i break end
	end
	if spawnIndex == -1 then
		if not isRobuxPurchase then ShowNotification:FireClient(player, "All crate slots are full!", "Error") end
		return false
	end
	local crateConfig = WeaponConfigurations.Crates[crateId]
	if not crateConfig then return false end
	local unlockTimestamp = os.time() + crateConfig.UnlockTime
	local crateData = { Type = crateId, SpawnIndex = spawnIndex, UnlockTimestamp = unlockTimestamp }
	table.insert(profile.Data.Crates, crateData)
	self:SpawnCrateModel(plot, crateData)
	if not isRobuxPurchase then ShowNotification:FireClient(player, "Crate purchased and placed on your plot!", "Success") end
	CrateDataUpdated:FireClient(player, profile.Data.Crates)
	return true
end

function CrateController:LoadPlayerCrates(player: Player, plot: Model)
	local profile = PlayerController:GetProfile(player)
	if not profile then return end
	for _, crateData in ipairs(profile.Data.Crates) do
		self:SpawnCrateModel(plot, crateData)
	end
	pushCapacityToClient(player)
end

function CrateController:Init(controllers: {[string]: any})
	PlayerController = controllers.PlayerController
	WeaponsShopController = controllers.WeaponsShopController
	Players.PlayerAdded:Connect(function(plr)
		task.defer(pushCapacityToClient, plr)
	end)
	Players.PlayerRemoving:Connect(function(plr)
		crateInteractionDebounce = {}
	end)
end

function CrateController:Start() end

return CrateController

---

--- ServerScriptService.Controllers.ShopTimerController (ModuleScript) ---
--!strict
-- GLOBAL SHOP TIMER CONTROLLER

local RunService = game:GetService("RunService")

local GlobalShopController
local Controller = {}
local INTERVAL = 5
local acc = 0

function Controller:Init(controllers: {[string]: any})
	GlobalShopController = controllers.GlobalShopController
end

function Controller:Start()
	RunService.Heartbeat:Connect(function(dt)
		acc += dt
		if acc < INTERVAL then return end
		acc = 0
		if GlobalShopController and GlobalShopController.CheckAndRestockDue then
			GlobalShopController:CheckAndRestockDue()
		end
	end)
end

return Controller

---

--- ServerScriptService.Controllers.GroupRewardController (ModuleScript) ---
--!strict
-- Uses PlayerController profile flag: HasClaimedGroupReward
-- Notifies via ReplicatedStorage.Events.ShowNotification (consumed by your NotificationManager)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local Controller = {} :: any

----------------------------------------------------------------
-- CONFIG
----------------------------------------------------------------
local GROUP_ID = 35962500                 
local TOUCH_MODEL_NAME = "GroupTouch"     
local TOUCH_PART_NAME  = "Touch"          

-- Reward item id as defined in your ItemConfigurations (Type = "Turrets")
local REWARD_ITEM_ID = "RifleGuard"

-- logging level: "debug" | "info" | "warn" | "error"
local LOG_LEVEL = "info"



local LV = {debug=1, info=2, warn=3, error=4}
local CUR = LV[LOG_LEVEL] or LV.info
local function log(level: string, ...)
	if (LV[level] or 9) < CUR then return end
	--print(("[GroupReward][%s] "):format(level:upper()), ...)
end
local function dbg(...)  log("debug", ...) end
local function info(...) log("info",  ...) end
local function warnl(...)log("warn",  ...) end
local function errl(...) log("error", ...) end


local _controllers: {[string]: any}? = nil
local touchCounts: {[Player]: number} = {}  


local EventsFolder: Folder = ReplicatedStorage:WaitForChild("Events")
local ShowNotification: RemoteEvent = EventsFolder:WaitForChild("ShowNotification")
local BlockInventoryUpdated: RemoteEvent = EventsFolder:WaitForChild("BlockInventoryUpdated")

local Modules = ReplicatedStorage:WaitForChild("Modules")
local ItemConfigurations = require(Modules:WaitForChild("ItemConfigurations"))


local function setPadText(model: Model, top: string?, bottom: string?)
	local gui = model:FindFirstChild("DecorGUI")
	if not gui then return end
	local topLbl = gui:FindFirstChild("Text")
	local subLbl = gui:FindFirstChild("Text+") or (function()
		local list = {}
		for _,c in ipairs(gui:GetChildren()) do
			if c:IsA("TextLabel") and c.Name=="Text" then table.insert(list, c) end
		end
		return list[2]
	end)()
	if topLbl and topLbl:IsA("TextLabel") and top then topLbl.Text = top end
	if subLbl and subLbl:IsA("TextLabel") and bottom then subLbl.Text = bottom end
end

local function isInGroup(plr: Player): boolean
	local ok, rank = pcall(function() return plr:GetRankInGroup(GROUP_ID) end)
	if not ok then
		errl("GetRankInGroup failed for", plr.Name)
		return false
	end
	return (rank or 0) > 0
end


local function getProfile(plr: Player)
	if not _controllers then return nil end
	local pc = _controllers.PlayerController
	if not pc then return nil end
	local ok, profile = pcall(function() return pc:GetProfile(plr) end)
	if ok then return profile end
	return nil
end

local function alreadyClaimed(plr: Player): boolean
	local profile = getProfile(plr)
	if profile and profile.Data then
		return profile.Data.HasClaimedGroupReward == true
	end
	return plr:GetAttribute("GroupRewardClaimed") == true
end

local function markClaimed(plr: Player)
	local profile = getProfile(plr)
	if profile and profile.Data then
		profile.Data.HasClaimedGroupReward = true
	end
	plr:SetAttribute("GroupRewardClaimed", true)
end


local function grantInventoryTurret(plr: Player): (boolean, string?)
	local profile = getProfile(plr)
	if not (profile and profile.Data) then
		return false, "Profile not ready"
	end
	local cfg = ItemConfigurations[REWARD_ITEM_ID]
	if not cfg then
		return false, "ItemConfigurations missing entry for "..REWARD_ITEM_ID
	end
	if cfg.Type ~= "Turrets" then
		warnl("Reward item is not Type='Turrets':", REWARD_ITEM_ID, "Type:", tostring(cfg.Type))
	end

	local inv = profile.Data.BlockInventory
	inv[REWARD_ITEM_ID] = (inv[REWARD_ITEM_ID] or 0) + 1


	BlockInventoryUpdated:FireClient(plr, inv)


	if not profile.Data.HasCompletedOnboarding and cfg.Type == "Turrets" then
		local UpdateOnboarding = EventsFolder:FindFirstChild("UpdateOnboardingStep")
		if UpdateOnboarding and UpdateOnboarding:IsA("RemoteEvent") then
			UpdateOnboarding:FireClient(plr, "Step2_PlaceTurret")
		end
	end

	return true
end


local function onEnterPad(model: Model, plr: Player)
	for _ = 1, 50 do
		if getProfile(plr) then break end
		task.wait(0.1)
	end

	if alreadyClaimed(plr) then
		-- One notification per entry only
		ShowNotification:FireClient(plr, "Already claimed", "Normal")
		setPadText(model, "Already claimed", "Enjoy!")
		return
	end

	if not isInGroup(plr) then
		ShowNotification:FireClient(plr, "Join our group first!", "Error")
		setPadText(model, "Join our group!", "Then step on the pad")
		return
	end

	local ok, err = grantInventoryTurret(plr)
	if not ok then
		errl("Grant failed for", plr.Name, err or "?")
		ShowNotification:FireClient(plr, "Reward error, try again", "Error")
		return
	end

	markClaimed(plr)
	ShowNotification:FireClient(plr, "ðŸŽ‰ Rifle Guard added to your inventory!", "Success")
	setPadText(model, "Reward claimed!", "Open Inventory")
	info("Granted RifleGuard (inventory) to", plr.Name, plr.UserId)
end


function Controller:Init(controllers: {[string]: any})
	_controllers = controllers


	Players.PlayerAdded:Connect(function(plr)
		task.spawn(function()
			for _ = 1, 50 do
				local profile = getProfile(plr)
				if profile then
					if profile.Data.HasClaimedGroupReward then
						plr:SetAttribute("GroupRewardClaimed", true)
						dbg("Pre-marked claimed for", plr.Name)
					end
					break
				end
				task.wait(0.1)
			end
		end)
	end)
end

function Controller:Start()
	info("Starting GroupRewardController â€¢ GROUP_ID =", GROUP_ID)

	local model = Workspace:FindFirstChild(TOUCH_MODEL_NAME)
	if not model or not model:IsA("Model") then
		warnl("Workspace."..TOUCH_MODEL_NAME.." not found; waitingâ€¦")
		model = Workspace:WaitForChild(TOUCH_MODEL_NAME, 10) :: any
	end
	if not model or not model:IsA("Model") then
		errl("GroupTouch model missing; aborting")
		return
	end

	local touch = model:FindFirstChild(TOUCH_PART_NAME)
	if not touch or not touch:IsA("BasePart") then
		errl(("GroupTouch.%s missing or not a BasePart"):format(TOUCH_PART_NAME))
		return
	end


	setPadText(model, "Free Turret", "Like game & join group!")


	touch.Touched:Connect(function(hit)
		local char = hit and hit.Parent
		local plr = char and Players:GetPlayerFromCharacter(char)
		if not plr then return end


		local n = (touchCounts[plr] or 0) + 1
		touchCounts[plr] = n
		if n == 1 then
			onEnterPad(model, plr)
		end
	end)


	touch.TouchEnded:Connect(function(hit)
		local char = hit and hit.Parent
		local plr = char and Players:GetPlayerFromCharacter(char)
		if not plr then return end
		local n = (touchCounts[plr] or 0) - 1
		if n < 0 then n = 0 end
		touchCounts[plr] = n
	end)

	info("Pad armed:", model:GetFullName(), "->", touch:GetFullName())
end

return Controller

---

--- ServerScriptService.Controllers.LeaderboardController (Script) ---
--!strict


local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DataStoreService  = game:GetService("DataStoreService")
local Players           = game:GetService("Players")
local Workspace         = game:GetService("Workspace")

local Config = require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("LeaderboardConfig"))

local dsCash   = DataStoreService:GetOrderedDataStore(Config.DataStores.MostCash)
local dsWaves  = DataStoreService:GetOrderedDataStore(Config.DataStores.MostWaves)
local dsTime   = DataStoreService:GetOrderedDataStore(Config.DataStores.MostPlaytime)
local dsSpent  = DataStoreService:GetOrderedDataStore(Config.DataStores.MostRobuxSpent) -- NEW


local function findDescendantByNameCI(root: Instance, name: string): Instance?
	local target = string.lower(name)
	for _, inst in ipairs(root:GetDescendants()) do
		if string.lower(inst.Name) == target then
			return inst
		end
	end
	return nil
end

local function getLeaderboardsFolder(): Instance?
	return findDescendantByNameCI(Workspace, "Leaderboards")
end

local function getBoardPart(modelName: string): BasePart?
	local lbFolder = getLeaderboardsFolder()
	if not lbFolder then return nil end

	local model = findDescendantByNameCI(lbFolder, modelName)
	if not (model and model:IsA("Model")) then return nil end

	local board = model:FindFirstChild(Config.BoardPartName)
	if board and board:IsA("BasePart") then
		return board
	end
	return nil
end

local function ensureGui(part: BasePart, title: string): Frame
	local sg = part:FindFirstChild("BoardGui") :: SurfaceGui
	if not sg then
		sg = Instance.new("SurfaceGui")
		sg.Name = "BoardGui"
		sg.SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud
		sg.PixelsPerStud = Config.UI.PixelsPerStud
		sg.CanvasSize = Config.UI.CanvasSize
		sg.Face = Enum.NormalId.Right 
		sg.Parent = part
	else
		sg.Face = Enum.NormalId.Right
	end

	local root = sg:FindFirstChild("Root") :: Frame
	if not root then
		root = Instance.new("Frame")
		root.Name = "Root"
		root.Size = UDim2.fromScale(1,1)
		root.BackgroundColor3 = Config.UI.Bg
		root.BorderSizePixel = 0
		root.Parent = sg

		local stroke = Instance.new("UIStroke")
		stroke.Color = Config.UI.Stroke
		stroke.Thickness = 8
		stroke.Parent = root

		local pad = Instance.new("UIPadding")
		pad.PaddingTop    = UDim.new(0, 22)
		pad.PaddingBottom = UDim.new(0, 22)
		pad.PaddingLeft   = UDim.new(0, 22)
		pad.PaddingRight  = UDim.new(0, 22)
		pad.Parent = root

		local list = Instance.new("UIListLayout")
		list.Padding = UDim.new(0, Config.UI.RowPad)
		list.FillDirection = Enum.FillDirection.Vertical
		list.SortOrder = Enum.SortOrder.LayoutOrder
		list.HorizontalAlignment = Enum.HorizontalAlignment.Center
		list.Parent = root

		local titleLbl = Instance.new("TextLabel")
		titleLbl.Name = "Title"
		titleLbl.LayoutOrder = 0
		titleLbl.Size = UDim2.new(1, -20, 0, 60)
		titleLbl.BackgroundTransparency = 1
		titleLbl.Font = Enum.Font.GothamBlack
		titleLbl.TextScaled = true
		titleLbl.TextWrapped = true
		titleLbl.TextColor3 = Config.UI.TitleColor
		titleLbl.Text = title
		titleLbl.Parent = root
	end
	(root:FindFirstChild("Title") :: TextLabel).Text = title
	return root
end

local function clearRows(root: Frame)
	for _, c in ipairs(root:GetChildren()) do
		if c:IsA("Frame") and c.Name == "Row" then c:Destroy() end
	end
end

local function makeRow(parent: Instance, rank: number, userId: number, valueText: string)
	local f = Instance.new("Frame")
	f.Name = "Row"
	f.Size = UDim2.new(1, -10, 0, 46)
	f.BackgroundTransparency = 0.2
	f.BackgroundColor3 = (rank % 2 == 0) and Color3.fromRGB(12,60,105) or Color3.fromRGB(10,50,90)
	f.BorderSizePixel = 0
	f.LayoutOrder = rank
	f.Parent = parent

	local ui = Instance.new("UIListLayout")
	ui.FillDirection = Enum.FillDirection.Horizontal
	ui.Padding = UDim.new(0, 10)
	ui.Parent = f

	local rankLbl = Instance.new("TextLabel")
	rankLbl.Size = UDim2.new(0, 60, 1, 0)
	rankLbl.BackgroundTransparency = 1
	rankLbl.Font = Enum.Font.GothamBold
	rankLbl.TextScaled = true
	rankLbl.TextColor3 = Config.UI.TextColor
	rankLbl.Text = "#" .. tostring(rank)
	rankLbl.Parent = f

	local nameLbl = Instance.new("TextLabel")
	nameLbl.Size = UDim2.new(1, -260, 1, 0)
	nameLbl.BackgroundTransparency = 1
	nameLbl.Font = Enum.Font.Gotham
	nameLbl.TextXAlignment = Enum.TextXAlignment.Left
	nameLbl.TextScaled = true
	nameLbl.TextColor3 = Config.UI.TextColor
	nameLbl.Text = ("Player %d"):format(userId)
	nameLbl.Parent = f

	local valueLbl = Instance.new("TextLabel")
	valueLbl.Size = UDim2.new(0, 180, 1, 0)
	valueLbl.BackgroundTransparency = 1
	valueLbl.Font = Enum.Font.GothamBold
	valueLbl.TextScaled = true
	valueLbl.TextXAlignment = Enum.TextXAlignment.Right
	valueLbl.TextColor3 = Config.UI.TextColor
	valueLbl.Text = valueText
	valueLbl.Parent = f

	task.spawn(function()
		local ok, result = pcall(function()
			return Players:GetNameFromUserIdAsync(userId)
		end)
		if ok and result then
			nameLbl.Text = result end
	end)
end

local function secondsToHMS(total: number): string
	total = math.max(0, math.floor(total + 0.5))
	local h = math.floor(total/3600)
	local m = math.floor((total%3600)/60)
	local s = total%60
	if h > 0 then
		return string.format("%dh %dm %ds", h, m, s)
	else
		return string.format("%dm %ds", m, s)
	end
end

local function abbrev(n: number): string
	if n >= 1e12 then return string.format("%.2fT", n/1e12)
	elseif n >= 1e9 then return string.format("%.2fB", n/1e9)
	elseif n >= 1e6 then return string.format("%.2fM", n/1e6)
	elseif n >= 1e3 then return string.format("%.2fk", n/1e3)
	else return tostring(n) end
end

local function pullTop(ds: OrderedDataStore, limit: number)
	for i=1,3 do
		local ok, result = pcall(function()
			return ds:GetSortedAsync(false, limit) -- false = descending
		end)
		if ok then
			return (result :: DataStorePages):GetCurrentPage()
		end
		task.wait(0.75 * i)
	end
	warn("[LeaderboardController] GetSortedAsync failed")
	return {}
end

local function isStudioDummyName(name: string): boolean
	name = tostring(name)
	-- Matches Player -1, Player -2, Player 1, Player 2, Player1, etc.
	return name:match("^Player%s*%-?%d+$") ~= nil
end

local function render(part: BasePart, title: string, ds: OrderedDataStore, valueFmt: (number)->string)
	local root = ensureGui(part, title)
	clearRows(root)

	local data = pullTop(ds, Config.Limit)
	local shown = 0

	for _, entry in ipairs(data) do
		local uid = tonumber(entry.key) or 0
		local val = tonumber(entry.value) or 0

		-- Try to resolve the username
		local ok, name = pcall(function()
			return Players:GetNameFromUserIdAsync(uid)
		end)

		-- âœ… Skip fake studio users (Player -1, Player -2, etc.)
		if ok and name and not isStudioDummyName(name) then
			shown += 1
			makeRow(root, shown, uid, valueFmt(val))
		end
	end
end


task.spawn(function()
	local cashPart  = getBoardPart(Config.ModelNames.Cash)
	local wavesPart = getBoardPart(Config.ModelNames.Waves)
	local timePart  = getBoardPart(Config.ModelNames.Playtime)
	local spentPart = getBoardPart(Config.ModelNames.Robux) -- NEW

	-- immediate render
	if cashPart  then render(cashPart,  "Most Cash",        dsCash,  function(n) return "$"..abbrev(n) end) end
	if wavesPart then render(wavesPart, "Most Waves",       dsWaves, function(n) return "Wave "..tostring(n) end) end
	if timePart  then render(timePart,  "Most Playtime",    dsTime,  function(n) return secondsToHMS(n) end) end
	if spentPart then render(spentPart, "Most Robux Spent", dsSpent, function(n) return "R$ "..abbrev(n) end) end

	while true do
		if cashPart  then render(cashPart,  "Most Cash",        dsCash,  function(n) return "$"..abbrev(n) end) end
		if wavesPart then render(wavesPart, "Most Waves",       dsWaves, function(n) return "Wave "..tostring(n) end) end
		if timePart  then render(timePart,  "Most Playtime",    dsTime,  function(n) return secondsToHMS(n) end) end
		if spentPart then render(spentPart, "Most Robux Spent", dsSpent, function(n) return "R$ "..abbrev(n) end) end
		task.wait(Config.PullInterval)
	end
end)

---

--- ServerScriptService.Controllers.LeaderboardWriter (Script) ---
--!strict


local Players            = game:GetService("Players")
local DataStoreService   = game:GetService("DataStoreService")
local ReplicatedStorage  = game:GetService("ReplicatedStorage")

local Config = require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("LeaderboardConfig"))

local dsCash   = DataStoreService:GetOrderedDataStore(Config.DataStores.MostCash)
local dsWaves  = DataStoreService:GetOrderedDataStore(Config.DataStores.MostWaves)
local dsTime   = DataStoreService:GetOrderedDataStore(Config.DataStores.MostPlaytime)
local dsSpent  = DataStoreService:GetOrderedDataStore(Config.DataStores.MostRobuxSpent) -- NEW

local sessionStart: {[number]: number} = {}
local lastWrite: {[string]: number} = {}


local SignalsFolder = ReplicatedStorage:FindFirstChild("Signals") or Instance.new("Folder")
SignalsFolder.Name = "Signals"
SignalsFolder.Parent = ReplicatedStorage

local RobuxSpentEvent = SignalsFolder:FindFirstChild("RobuxSpent")
if not RobuxSpentEvent then
	RobuxSpentEvent = Instance.new("BindableEvent")
	RobuxSpentEvent.Name = "RobuxSpent"
	RobuxSpentEvent.Parent = SignalsFolder
end
local RobuxSpentBindable = RobuxSpentEvent :: BindableEvent

local function now() return os.time() end

local function throttle(key: string, seconds: number): boolean
	local t = now()
	local last = lastWrite[key]
	if not last or t - last >= seconds then
		lastWrite[key] = t
		return true
	end
	return false
end

local function safeSet(ds: OrderedDataStore, key: string, value: number)
	for i=1,3 do
		local ok = pcall(function() ds:SetAsync(key, value) end)
		if ok then return end
		task.wait(0.75 * i)
	end
	warn("[LeaderboardWriter] SetAsync failed for", key, value)
end

local function addNumber(ds: OrderedDataStore, userKey: string, addAmount: number)
	if addAmount == 0 then return end
	for i=1,3 do
		local ok = pcall(function()
			ds:UpdateAsync(userKey, function(old)
				old = typeof(old) == "number" and old or 0
				return math.max(0, old + addAmount)
			end)
		end)
		if ok then return end
		task.wait(0.75 * i)
	end
	warn("[LeaderboardWriter] UpdateAsync failed for", userKey, addAmount)
end

local function addPlaytime(userKey: string, addSeconds: number)
	if addSeconds <= 0 then return end
	addNumber(dsTime, userKey, addSeconds)
end

local function addRobuxSpent(userKey: string, addRobux: number)
	if addRobux <= 0 then return end
	addNumber(dsSpent, userKey, addRobux)
end

local function pushCash(plr: Player, value: number)
	local key = tostring(plr.UserId)
	if throttle("cash"..key, 10) then
		safeSet(dsCash, key, value)
	end
end

local function pushWaves(plr: Player, value: number)
	local key = tostring(plr.UserId)
	if throttle("wave"..key, 10) then
		safeSet(dsWaves, key, value)
	end
end


RobuxSpentBindable.Event:Connect(function(userId: number, amountRobux: number)
	if typeof(userId) ~= "number" or typeof(amountRobux) ~= "number" then return end
	if amountRobux <= 0 then return end
	addRobuxSpent(tostring(userId), amountRobux)
end)



Players.PlayerAdded:Connect(function(plr)
	sessionStart[plr.UserId] = now()

	task.defer(function()
		local ls = plr:WaitForChild("leaderstats", 15)
		if not ls then return end

		local cash = ls:FindFirstChild("Cash")
		if cash and cash:IsA("IntValue") then
			pushCash(plr, cash.Value)
			cash:GetPropertyChangedSignal("Value"):Connect(function()
				pushCash(plr, cash.Value)
			end)
		end

		local waves = ls:FindFirstChild("Highest Wave")
		if waves and waves:IsA("IntValue") then
			pushWaves(plr, waves.Value)
			waves:GetPropertyChangedSignal("Value"):Connect(function()
				pushWaves(plr, waves.Value)
			end)
		end
	end)
end)

Players.PlayerRemoving:Connect(function(plr)
	local start = sessionStart[plr.UserId]
	if start then
		addPlaytime(tostring(plr.UserId), now() - start)
		sessionStart[plr.UserId] = nil
	end

	local ls = plr:FindFirstChild("leaderstats")
	if ls then
		local c = ls:FindFirstChild("Cash")
		if c and c:IsA("IntValue") then pushCash(plr, c.Value) end
		local w = ls:FindFirstChild("Highest Wave")
		if w and w:IsA("IntValue") then pushWaves(plr, w.Value) end
	end
end)

---

--- ServerScriptService.Controllers.GlobalShopController (ModuleScript) ---
--!strict
-- GLOBAL SHOP CONTROLLER (Deterministic, Cross-Server Identical + Per-Player Persistent Stock)

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local Modules = ReplicatedStorage:WaitForChild("Modules")
local ItemConfigurations = require(Modules:WaitForChild("ItemConfigurations"))
local WeaponConfigurations = require(Modules:WaitForChild("WeaponConfigurations"))

local GlobalShop = {}

-- ===== CONFIG =====
local RESTOCK_INTERVAL = 300 -- 5 minutes aligned to wall clock
local GUARANTEED_BLOCK_ITEMS = { "WoodenFence", "RevolverGuard" }

-- ===== STATE =====
local _baseline = {
	Blocks  = {} :: {[string]: number},
	Weapons = {} :: {[string]: number},
}
local _nextRestock = 0
local _currentBucket = 0

-- Per-player, in-memory counters for the current bucket
local _pStocks = {
	Blocks  = {} :: {[Player]: {[string]: number}},
	Weapons = {} :: {[Player]: {[string]: number}},
}

-- Optional injected controller for profile persistence
local PlayerController: any? = nil

-- ===== REMOTES =====
local Events = ReplicatedStorage:FindFirstChild("Events") or Instance.new("Folder")
Events.Name = "Events"
Events.Parent = ReplicatedStorage

local Functions = ReplicatedStorage:FindFirstChild("Functions") or Instance.new("Folder")
Functions.Name = "Functions"
Functions.Parent = ReplicatedStorage

local function ensureRemoteEvent(name: string): RemoteEvent
	local ev = Events:FindFirstChild(name) :: RemoteEvent?
	if not ev then ev = Instance.new("RemoteEvent"); ev.Name = name; ev.Parent = Events end
	return ev
end

local function ensureRemoteFunction(name: string): RemoteFunction
	local fn = Functions:FindFirstChild(name) :: RemoteFunction?
	if not fn then fn = Instance.new("RemoteFunction"); fn.Name = name; fn.Parent = Functions end
	return fn
end

local UpdateBlockStocks       = ensureRemoteEvent("UpdateBlockStocks")
local UpdateWeaponStocks      = ensureRemoteEvent("UpdateWeaponStocks")
local ShowNotification        = ensureRemoteEvent("ShowNotification")
local GetBlockShopStocks      = ensureRemoteFunction("GetBlockShopStocks")
local GetWeaponShopStocks     = ensureRemoteFunction("GetWeaponShopStocks")
local GetBlockShopResetTime   = ensureRemoteFunction("GetBlockShopResetTime")
local GetWeaponShopResetTime  = ensureRemoteFunction("GetWeaponShopResetTime")

-- ===== UTIL =====
local bit = bit32

local function cloneMap(m: {[string]: number})
	local out: {[string]: number} = {}
	for k, v in pairs(m) do out[k] = v end
	return out
end

local function addInto(dst: {[string]: number}, src: {[string]: number}?)
	if not src then return end
	for k, v in pairs(src) do
		dst[k] = (dst[k] or 0) + v
	end
end

local function nextAligned(now: number, interval: number): number
	local base = math.floor(now / interval) * interval
	return base + interval
end

local function currentBucket(now: number): number
	return math.floor(now / RESTOCK_INTERVAL)
end

-- FNV-1a 32-bit deterministic hash
local function fnv1a32(str: string): number
	local h = 2166136261
	for i = 1, #str do
		h = bit.band(bit.bxor(h, string.byte(str, i)), 0xFFFFFFFF)
		h = bit.band((h * 16777619) % 2^32, 0xFFFFFFFF)
	end
	return h
end

local function makeSeed(shopType: string, bucket: number): number
	local s = string.format("%s:%d", shopType, bucket)
	local seed = fnv1a32(s) % 0x7FFFFFFF
	if seed == 0 then seed = 1 end -- avoid 0 seed edge case
	return seed
end

local function sortedKeys(t: {[string]: any}): {string}
	local keys = {}
	for k in pairs(t) do table.insert(keys, k) end
	table.sort(keys) -- stable cross-server iteration order
	return keys
end

-- Deterministic roll driven by provided Random
local function rollFromConfigDet(
	configs: {[string]: any},
	rnd: Random,
	filter: (string, any)->boolean?
): {[string]: number}
	local res: {[string]: number} = {}
	local keys = sortedKeys(configs)
	for _, id in ipairs(keys) do
		local cfg = configs[id]
		if filter and not filter(id, cfg) then
			continue
		end
		if cfg.Unlimited then
			continue
		end
		if type(cfg.Chance) == "number" then
			local hit = (rnd:NextNumber() * 100) <= cfg.Chance
			if hit then
				local min = (cfg.StockAmount and cfg.StockAmount.Min) or 1
				local max = (cfg.StockAmount and cfg.StockAmount.Max) or min
				res[id] = rnd:NextInteger(min, max)
			else
				res[id] = 0
			end
		end
	end
	return res
end

-- ===== DETERMINISTIC BASELINES =====
local function rollBlocksBaseline(bucket: number): {[string]: number}
	local rnd = Random.new(makeSeed("Blocks", bucket))
	local stock: {[string]: number} = {}

	-- Guaranteed items first
	for _, id in ipairs(GUARANTEED_BLOCK_ITEMS) do
		local cfg = ItemConfigurations[id]
		if cfg and not cfg.Unlimited then
			local min = (cfg.StockAmount and cfg.StockAmount.Min) or 1
			local max = (cfg.StockAmount and cfg.StockAmount.Max) or min
			stock[id] = rnd:NextInteger(min, max)
		end
	end

	-- Other blocks/turrets
	local rolled = rollFromConfigDet(ItemConfigurations, rnd, function(_, cfg)
		return (cfg.Type == "Blocks" or cfg.Type == "Turrets")
	end)

	for id, v in pairs(rolled) do
		if stock[id] == nil then stock[id] = v end
	end

	return stock
end

local function rollWeaponsBaseline(bucket: number): {[string]: number}
	local rnd = Random.new(makeSeed("Weapons", bucket))
	return rollFromConfigDet(WeaponConfigurations.Crates, rnd, function(_, cfg)
		return not cfg.Unlimited and cfg.Price ~= nil
	end)
end

-- ===== PROFILE ACCESS / PERSIST =====
local function getProfile(player: Player)
	return PlayerController and PlayerController:GetProfile(player) or nil
end

local function savePlayerStocks(player: Player)
	local prof = getProfile(player)
	if not prof then return end
	prof.Data.ShopState = prof.Data.ShopState or {}
	prof.Data.ShopState.Bucket = _currentBucket
	prof.Data.ShopState.Blocks = cloneMap(_pStocks.Blocks[player] or {})
	prof.Data.ShopState.Weapons = cloneMap(_pStocks.Weapons[player] or {})
end

-- Ensure in-memory stocks exist, restoring from Profile if same bucket
local function ensurePlayerStocks(player: Player)
	if _pStocks.Blocks[player] and _pStocks.Weapons[player] then return end

	-- Wait for profile instead of bailing
	local prof = getProfile(player)
	while not prof do
		task.wait()
		prof = getProfile(player)
	end

	if prof.Data and prof.Data.ShopState then
		local ss = prof.Data.ShopState
		if ss.Bucket == _currentBucket
			and typeof(ss.Blocks) == "table"
			and typeof(ss.Weapons) == "table" then
			_pStocks.Blocks[player]  = cloneMap(ss.Blocks)
			_pStocks.Weapons[player] = cloneMap(ss.Weapons)
			return
		end
	end

	-- No saved state for this bucket â†’ seed from baseline and persist
	_pStocks.Blocks[player]  = cloneMap(_baseline.Blocks)
	_pStocks.Weapons[player] = cloneMap(_baseline.Weapons)
	savePlayerStocks(player)
end


-- ===== GLOBAL RESTOCK =====
local function doGlobalRestockFor(bucket: number)
	_baseline.Blocks  = rollBlocksBaseline(bucket)
	_baseline.Weapons = rollWeaponsBaseline(bucket)
	_currentBucket    = bucket
	_nextRestock      = nextAligned(os.time(), RESTOCK_INTERVAL)

	-- Reset each player's personal stocks to the new baseline, persist, and push
	for _, plr in ipairs(Players:GetPlayers()) do
		_pStocks.Blocks[plr]  = cloneMap(_baseline.Blocks)
		_pStocks.Weapons[plr] = cloneMap(_baseline.Weapons)

		savePlayerStocks(plr)

		UpdateBlockStocks:FireClient(plr, cloneMap(_pStocks.Blocks[plr]), _nextRestock)
		UpdateWeaponStocks:FireClient(plr, cloneMap(_pStocks.Weapons[plr]), _nextRestock)
	end

	ShowNotification:FireAllClients("The Shops have been restocked!", "Normal")
end

-- ===== PUBLIC: DEV PRODUCT PERSONAL RESTOCK =====
function GlobalShop:AddPersonalBlocks(player: Player)
	ensurePlayerStocks(player)
	local rnd = Random.new(makeSeed(("Blocks:add:%d"):format(player.UserId), _currentBucket))
	local add = rollFromConfigDet(ItemConfigurations, rnd, function(_, cfg)
		return (cfg.Type == "Blocks" or cfg.Type == "Turrets") and not cfg.Unlimited
	end)
	addInto(_pStocks.Blocks[player], add)
	savePlayerStocks(player)
	UpdateBlockStocks:FireClient(player, cloneMap(_pStocks.Blocks[player]), _nextRestock)
end

function GlobalShop:AddPersonalWeapons(player: Player)
	ensurePlayerStocks(player)
	local rnd = Random.new(makeSeed(("Weapons:add:%d"):format(player.UserId), _currentBucket))
	local add = rollFromConfigDet(WeaponConfigurations.Crates, rnd, function(_, cfg)
		return not cfg.Unlimited and cfg.Price ~= nil
	end)
	addInto(_pStocks.Weapons[player], add)
	savePlayerStocks(player)
	UpdateWeaponStocks:FireClient(player, cloneMap(_pStocks.Weapons[player]), _nextRestock)
end

-- ===== PUBLIC QUERIES =====
function GlobalShop:GetPlayerBlocks(player: Player): {[string]: number}
	ensurePlayerStocks(player)
	return _pStocks.Blocks[player]
end

function GlobalShop:GetPlayerWeapons(player: Player): {[string]: number}
	ensurePlayerStocks(player)
	return _pStocks.Weapons[player]
end

function GlobalShop:ConsumeBlocks(player: Player, itemId: string): boolean
	ensurePlayerStocks(player)
	local m = _pStocks.Blocks[player]
	if (m[itemId] or 0) > 0 then
		m[itemId] -= 1
		savePlayerStocks(player)
		UpdateBlockStocks:FireClient(player, cloneMap(m), _nextRestock)
		return true
	end
	return false
end

function GlobalShop:ConsumeWeapons(player: Player, itemId: string): boolean
	ensurePlayerStocks(player)
	local m = _pStocks.Weapons[player]
	if (m[itemId] or 0) > 0 then
		m[itemId] -= 1
		savePlayerStocks(player)
		UpdateWeaponStocks:FireClient(player, cloneMap(m), _nextRestock)
		return true
	end
	return false
end

function GlobalShop:GetNextRestock(): number
	return _nextRestock
end

-- ===== REMOTES & PLAYER LIFECYCLE =====
function GlobalShop:BindRemotes()
	GetBlockShopStocks.OnServerInvoke  = function(player)
		ensurePlayerStocks(player)
		return _pStocks.Blocks[player]
	end

	GetWeaponShopStocks.OnServerInvoke = function(player)
		ensurePlayerStocks(player)
		return _pStocks.Weapons[player]
	end

	GetBlockShopResetTime.OnServerInvoke  = function() return _nextRestock end
	GetWeaponShopResetTime.OnServerInvoke = function() return _nextRestock end

	Players.PlayerAdded:Connect(function(plr)
		-- Wait until PlayerController created the profile, then seed/persist
		while PlayerController and (getProfile(plr) == nil) do task.wait() end
		ensurePlayerStocks(plr)
	end)

	Players.PlayerRemoving:Connect(function(plr)
		_pStocks.Blocks[plr]  = nil
		_pStocks.Weapons[plr] = nil
	end)
end

-- ===== BOOT =====
function GlobalShop:Init(controllers: {[string]: any}?)
	if controllers and controllers.PlayerController then
		PlayerController = controllers.PlayerController
	end

	local now = os.time() -- UTC
	_currentBucket = currentBucket(now)
	_nextRestock   = nextAligned(now, RESTOCK_INTERVAL)

	doGlobalRestockFor(_currentBucket)
	self:BindRemotes()
end

-- Called by ShopTimerController every few seconds
function GlobalShop:CheckAndRestockDue()
	local nowBucket = currentBucket(os.time())
	if nowBucket ~= _currentBucket then
		doGlobalRestockFor(nowBucket)
	end
end

return GlobalShop

---

--- ServerScriptService.Controllers.BadgeController (ModuleScript) ---
--!strict

local Players = game:GetService("Players")
local BadgeService = game:GetService("BadgeService")

-- Use WaitForChild so require never gets nil.
local BadgeCatalog = require(game.ReplicatedStorage.Modules:WaitForChild("BadgeConfigurations"))

-- Explicit key type (Luau doesn't support `keyof typeof` in type positions)
type BadgeKey =
	"You played!" |
"Acquired Revolver Cowboy" |
"Acquired Akimbo Cowboy" |
"Acquired Uzi Cowboy" |
"Acquired Shotgun Cowboy" |
"Acquired Heavy Gunner" |
"Acquired Rifle Cowboy" |
"Acquired Mortar Cowboy" |
"First Mutation"

type AwardCache = {[number]: {[number]: boolean}} -- [userId][badgeId] = true
type Self = {
	_has: AwardCache,
	_next: {[number]: number},
	CD: number,
}

local BadgeController: Self = {
	_has = {},
	_next = {},
	CD = 0.2,
}

local function mark(self: Self, userId: number, badgeId: number, val: boolean)
	self._has[userId] = self._has[userId] or {}
	self._has[userId][badgeId] = val
end

local function cached(self: Self, userId: number, badgeId: number): boolean?
	local m = self._has[userId]
	return m and m[badgeId] or nil
end

local function hasBadge(userId: number, badgeId: number): boolean
	local ok, res = pcall(function()
		return BadgeService:UserHasBadgeAsync(userId, badgeId)
	end)
	if not ok then
		warn(("[Badge] UserHasBadgeAsync %d/%d failed: %s"):format(userId, badgeId, tostring(res)))
		return false
	end
	return res
end

local function give(userId: number, badgeId: number): boolean
	local ok, err = pcall(function()
		BadgeService:AwardBadge(userId, badgeId)
	end)
	if not ok then
		warn(("[Badge] AwardBadge %d/%d failed: %s"):format(userId, badgeId, tostring(err)))
		return false
	end
	return true
end

local function award(player: Player, key: BadgeKey): boolean
	local badgeId = BadgeCatalog[key]
	if not badgeId then return false end
	local userId = player.UserId
	if userId <= 0 then return false end

	local now = time()
	local nextOk = BadgeController._next[userId]
	if nextOk and now < nextOk then return false end
	BadgeController._next[userId] = now + BadgeController.CD

	local c = cached(BadgeController, userId, badgeId)
	if c == true then return false end

	local owns = c == true and true or hasBadge(userId, badgeId)
	if owns then
		mark(BadgeController, userId, badgeId, true)
		return false
	end

	if give(userId, badgeId) then
		mark(BadgeController, userId, badgeId, true)
		return true
	end
	return false
end

-- ---------- AUTO-DETECTION LOGIC ----------

-- Look inside likely inventory buckets and collect item names (strings)
local POSSIBLE_INV_KEYS = {
	"BlockInventory",
	-- add more buckets if needed, e.g. "GuardsInventory", "OwnedCowboys"
}

local function collectNames(profileData: any): {string}
	local out = {} :: {string}
	if type(profileData) ~= "table" then return out end
	for _, key in ipairs(POSSIBLE_INV_KEYS) do
		local bucket = profileData[key]
		if type(bucket) == "table" then
			for _, v in pairs(bucket) do
				if typeof(v) == "string" then
					table.insert(out, v)
				elseif type(v) == "table" then
					local n = (v :: any).Name or (v :: any).id or (v :: any).name
					if typeof(n) == "string" then
						table.insert(out, n)
					end
				end
			end
		end
	end
	return out
end

local function hasName(names: {string}, needles: {string}): boolean
	for _, raw in ipairs(names) do
		local s = string.lower(raw)
		for _, n in ipairs(needles) do
			if string.find(s, string.lower(n), 1, true) then -- plain find
				return true
			end
		end
	end
	return false
end

local function anyMutation(names: {string}): boolean
	for _, raw in ipairs(names) do
		local s = string.lower(raw)
		-- Accepts Name_M1 / _M2 / _M3 / _M4 (pattern match)
		if string.find(s, "_m[1-4]") then
			return true
		end
	end
	return false
end

-- Map badge keys -> substrings that qualify
local BADGE_RULES: {[BadgeKey]: {string}} = {
	["Acquired Revolver Cowboy"] = { "revolver", "revolverguard" },
	["Acquired Akimbo Cowboy"]   = { "akimbo", "dualrevolver" },
	["Acquired Uzi Cowboy"]      = { "uzi" },
	["Acquired Shotgun Cowboy"]  = { "shotgun" },
	["Acquired Heavy Gunner"]    = { "heavygunner", "heavy" },
	["Acquired Rifle Cowboy"]    = { "rifle", "rifleguard" },
	["Acquired Mortar Cowboy"]   = { "mortar", "mortarguard" },
	-- "First Mutation" is handled separately by anyMutation()
}

local function syncCowboyBadges(player: Player, names: {string})
	for key, needles in pairs(BADGE_RULES) do
		if hasName(names, needles) then
			award(player, key)
		end
	end
end

local function syncFirstMutation(player: Player, names: {string})
	if anyMutation(names) then
		award(player, "First Mutation")
	end
end

-- Public: run a full pass using the given data table (your profile.Data)
function BadgeController.SyncFor(player: Player, profileData: any)
	local names = collectNames(profileData)
	if #names == 0 then return end
	syncCowboyBadges(player, names)
	syncFirstMutation(player, names)
end

-- Call this right after you add a single new item name (string) to inventory.
function BadgeController.SyncForNewItem(player: Player, itemName: string)
	if typeof(itemName) ~= "string" then return end
	local names = { itemName }
	syncCowboyBadges(player, names)
	syncFirstMutation(player, names)
end

-- Boot: grant "You played!" on first join
Players.PlayerAdded:Connect(function(plr: Player)
	task.delay(2, function()
		award(plr, "You played!")
	end)
end)

Players.PlayerRemoving:Connect(function(plr: Player)
	BadgeController._has[plr.UserId] = nil
	BadgeController._next[plr.UserId] = nil
end)

return BadgeController

---

--- ServerScriptService.Controllers.PlotSignagneController (ModuleScript) ---
--!strict
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local PlotSignageController = {}


local PLOT_FOLDER_NAME: string? = "Plots" 
local SIGN_MODEL_NAME = "PlotSignage"
local SIGN_PART_NAME  = "Screen"
local GUI_NAME        = "SignGui"

-- SurfaceGui sizing
local CANVAS_SIZE = Vector2.new(900, 400)
local PIXELS_PER_STUD = 75

-- Visual style
local BG_TRANSPARENCY = 1
local TEXT_COLOR      = Color3.fromRGB(255,255,255)
local TEXT_STROKE     = Color3.fromRGB(0,0,0)
local TEXT_STROKE_T   = 0
local TEXT_STROKE_Size = 3
local FONT            = Enum.Font.FredokaOne
local AVATAR_SIZE     = UDim2.fromScale(0.28, 0.8)
local AVATAR_ASPECT   = 1.0




local function possessive(name: string): string
	local last = name:sub(-1):lower()
	if last == "s" then
		return name .. "â€™"
	else
		return name .. "'s"
	end
end

local function getOwnerUserId(plot: Instance): number?
	for _, key in ipairs({ "OwnerId", "OwnerUserId" }) do
		local attr = plot:GetAttribute(key)
		if typeof(attr) == "number" then
			return attr
		end
	end
	for _, key in ipairs({ "OwnerId", "OwnerUserId" }) do
		local iv = plot:FindFirstChild(key)
		if iv and iv:IsA("IntValue") then
			return iv.Value
		end
	end
	return nil
end

local function getNameAndThumb(userId: number): (string, string)
	local okName, playerName = pcall(Players.GetNameFromUserIdAsync, Players, userId)
	if not okName then
		playerName = ("User %d"):format(userId)
	end
	local thumbUrl = ""
	local okThumb, url = pcall(Players.GetUserThumbnailAsync, Players, userId,
		Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size420x420)
	if okThumb then
		thumbUrl = url
	end
	return playerName, thumbUrl
end

local function clearOldGui(screen: BasePart)
	for _, child in ipairs(screen:GetChildren()) do
		if child:IsA("SurfaceGui") and child.Name == GUI_NAME then
			child:Destroy()
		end
	end
end

local function makeGui(screen: BasePart, titleText: string, thumbUrl: string)
	clearOldGui(screen)

	local gui = Instance.new("SurfaceGui")
	gui.Name = GUI_NAME
	gui.SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud
	gui.PixelsPerStud = PIXELS_PER_STUD
	gui.CanvasSize = CANVAS_SIZE
	gui.Adornee = screen
	gui.Face = Enum.NormalId.Front
	gui.AlwaysOnTop = false
	gui.Parent = screen

	local bg = Instance.new("Frame")
	bg.Name = "BG"
	bg.Size = UDim2.fromScale(1,1)
	bg.BackgroundTransparency = BG_TRANSPARENCY
	bg.Parent = gui

	local avatar = Instance.new("ImageLabel")
	avatar.Name = "Avatar"
	avatar.Size = AVATAR_SIZE
	avatar.Position = UDim2.fromScale(0.05, 0.1)
	avatar.BackgroundTransparency = 1
	avatar.Image = (thumbUrl ~= "" and thumbUrl) or "rbxassetid://0"
	avatar.Parent = bg
	local uic = Instance.new("UICorner")
	uic.CornerRadius = UDim.new(0, 30)
	uic.Parent = avatar
	local uiAspect = Instance.new("UIAspectRatioConstraint")
	uiAspect.AspectRatio = AVATAR_ASPECT
	uiAspect.Parent = avatar

	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.AnchorPoint = Vector2.new(0, 0.5)
	title.Position   = UDim2.fromScale(0.36, 0.5)
	title.Size       = UDim2.fromScale(0.6, 0.8)
	title.BackgroundTransparency = 1
	title.Text = titleText
	title.TextColor3 = TEXT_COLOR
	title.Font = FONT
	title.TextScaled = true
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.Parent = bg

	local stroke = Instance.new("UIStroke")
	stroke.Thickness = TEXT_STROKE_Size
	stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual
	stroke.Color = TEXT_STROKE
	stroke.Transparency = TEXT_STROKE_T
	stroke.Parent = title
end

local function isPlotModel(inst: Instance): boolean
	if not inst:IsA("Model") then return false end
	local signage = inst:FindFirstChild(SIGN_MODEL_NAME)
	if not (signage and signage:IsA("Model")) then return false end
	local screen = signage:FindFirstChild(SIGN_PART_NAME)
	return (screen ~= nil) and screen:IsA("BasePart")
end

local function updatePlotSign(plot: Instance)
	local signage = plot:FindFirstChild(SIGN_MODEL_NAME)
	if not signage or not signage:IsA("Model") then
		warn(("[Signage] Missing %s in %s"):format(SIGN_MODEL_NAME, plot:GetFullName()))
		return
	end
	local screen = signage:FindFirstChild(SIGN_PART_NAME) :: BasePart?
	if not screen or not screen:IsA("BasePart") then
		warn(("[Signage] Missing %s part under %s"):format(SIGN_PART_NAME, signage:GetFullName()))
		return
	end

	local userId = getOwnerUserId(plot)
	if not userId then
		clearOldGui(screen)
		return
	end

	local playerName, thumbUrl = getNameAndThumb(userId)
	local title = ("%s Base"):format(possessive(playerName))
	makeGui(screen, title, thumbUrl)
	--print(("[Signage] Updated %s -> %s (%d)"):format(plot.Name, playerName, userId))
end

local function hookOwnerChanges(plot: Instance)
	for _, key in ipairs({ "OwnerId", "OwnerUserId" }) do
		plot:GetAttributeChangedSignal(key):Connect(function()
			updatePlotSign(plot)
		end)
	end

	local function watch(iv: IntValue)
		iv.Changed:Connect(function()
			updatePlotSign(plot)
		end)
	end
	for _, key in ipairs({ "OwnerId", "OwnerUserId" }) do
		local iv = plot:FindFirstChild(key)
		if iv and iv:IsA("IntValue") then
			watch(iv)
		end
	end
	plot.ChildAdded:Connect(function(ch)
		if ch:IsA("IntValue") and (ch.Name == "OwnerId" or ch.Name == "OwnerUserId") then
			watch(ch)
			updatePlotSign(plot)
		end
	end)
end



function PlotSignageController:Init()
	-- nothing to wire from other controllers
end

function PlotSignageController:Start()
	local container: Instance = Workspace
	if PLOT_FOLDER_NAME then
		local f = Workspace:FindFirstChild(PLOT_FOLDER_NAME)
		if f then container = f end
	end


	for _, inst in ipairs(container:GetDescendants()) do
		if isPlotModel(inst) then
			updatePlotSign(inst)
			hookOwnerChanges(inst)
		end
	end

	-- React to new plots added
	container.DescendantAdded:Connect(function(inst)
		if isPlotModel(inst) then
			task.defer(function()
				updatePlotSign(inst)
				hookOwnerChanges(inst)
			end)
		end
	end)

--	print("[Signage] Controller started")
end

return PlotSignageController

---

--- ServerScriptService.Controllers.MoveModelsController (ModuleScript) ---
--!strict
local RunService    = game:GetService("RunService")
local Workspace     = game:GetService("Workspace")
local ServerStorage = game:GetService("ServerStorage")

local TARGET_NAME = "STUDIO_MODELS"

local function move(inst: Instance)
	if not inst or not inst.Parent or inst.Parent == ServerStorage then return end
	if RunService:IsClient() then return end
	inst.Parent = ServerStorage
	--print(("[STUDIO_MODELS] Moved to ServerStorage: %s"):format(inst:GetFullName()))
end

local function sweep()
	local direct = Workspace:FindFirstChild(TARGET_NAME)
	if direct then move(direct) end
	for _, d in ipairs(Workspace:GetDescendants()) do
		if d.Name == TARGET_NAME and (d:IsA("Folder") or d:IsA("Model")) then
			move(d)
		end
	end
end

local MoveStudioModelsController = {}

function MoveStudioModelsController:Init(_controllers) end

function MoveStudioModelsController:Start()
	if RunService:IsClient() then return end
	sweep()
	Workspace.ChildAdded:Connect(function(child)
		if child.Name == TARGET_NAME and (child:IsA("Folder") or child:IsA("Model")) then
			move(child)
		end
	end)
	Workspace.DescendantAdded:Connect(function(inst)
		if inst.Name == TARGET_NAME and (inst:IsA("Folder") or inst:IsA("Model")) then
			task.defer(function()
				if inst and inst.Parent and inst.Parent ~= ServerStorage then
					move(inst)
				end
			end)
		end
	end)
end

return MoveStudioModelsController

---

--- ServerScriptService.Controllers.SettingsController (ModuleScript) ---
--!strict
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local SettingsController = {}

local DEFAULTS = {
	WeaponSounds = true,
	Music = true,
	Performance = false,
}

local _pc: any
local _events: Folder
local _rfGet: RemoteFunction
local _reSave: RemoteEvent
local _conns: { RBXScriptConnection } = {}

local function copy(t: {[string]: any})
	local n: {[string]: any} = {}
	for k, v in pairs(t) do n[k] = v end
	return n
end

local function sanitize(payload: any): ({[string]: any}?)
	if typeof(payload) ~= "table" then return nil end
	local ws = payload.WeaponSounds
	local mu = payload.Music
	local pf = payload.Performance
	if typeof(ws) ~= "boolean" or typeof(mu) ~= "boolean" or typeof(pf) ~= "boolean" then
		return nil
	end
	return { WeaponSounds = ws, Music = mu, Performance = pf }
end

local function normalizeOrDefaults(t: any): {[string]: any}
	if typeof(t) ~= "table" then return copy(DEFAULTS) end
	local out = copy(DEFAULTS)
	for k, v in pairs(DEFAULTS) do
		if typeof(t[k]) == typeof(v) then out[k] = t[k] end
	end
	return out
end

local function applyAttrs(plr: Player, s: {[string]: any})
	plr:SetAttribute("Setting_WeaponSounds", s.WeaponSounds)
	plr:SetAttribute("Setting_Music", s.Music)
	plr:SetAttribute("Setting_PerformanceMode", s.Performance)
end

local function ensureRemotes()
	_events = ReplicatedStorage:FindFirstChild("Events") :: Folder
	if not _events then
		_events = Instance.new("Folder")
		_events.Name = "Events"
		_events.Parent = ReplicatedStorage
	end

	_rfGet = _events:FindFirstChild("GetPlayerSettings") :: RemoteFunction
	if not _rfGet then
		_rfGet = Instance.new("RemoteFunction")
		_rfGet.Name = "GetPlayerSettings"
		_rfGet.Parent = _events
	end

	_reSave = _events:FindFirstChild("SavePlayerSettings") :: RemoteEvent
	if not _reSave then
		_reSave = Instance.new("RemoteEvent")
		_reSave.Name = "SavePlayerSettings"
		_reSave.Parent = _events
	end
end

function SettingsController:Init(controllers: {[string]: any})
	_pc = controllers.PlayerController
	if not _pc or not _pc.GetProfile then
		warn("[SettingsController] PlayerController manquant ou incomplet (GetProfile).")
	end

	ensureRemotes()

	_rfGet.OnServerInvoke = function(plr: Player)
		local prof = _pc and _pc:GetProfile(plr) or nil
		if not prof then
			return copy(DEFAULTS)
		end
		prof.Data.Settings = normalizeOrDefaults(prof.Data.Settings)
		return copy(prof.Data.Settings)
	end

	_conns[#_conns+1] = _reSave.OnServerEvent:Connect(function(plr: Player, payload: any)
		local prof = _pc and _pc:GetProfile(plr) or nil
		if not prof then return end
		local v = sanitize(payload)
		if not v then return end
		prof.Data.Settings = v
		applyAttrs(plr, v)
	end)

	_conns[#_conns+1] = Players.PlayerAdded:Connect(function(plr)
		local prof = _pc and _pc:GetProfile(plr) or nil
		if prof then
			prof.Data.Settings = normalizeOrDefaults(prof.Data.Settings)
			applyAttrs(plr, prof.Data.Settings)
		else
			applyAttrs(plr, DEFAULTS)
		end
	end)

	_conns[#_conns+1] = Players.PlayerRemoving:Connect(function(plr) end)
end

function SettingsController:Start(_controllers: {[string]: any})
	for _, plr in ipairs(Players:GetPlayers()) do
		local prof = _pc and _pc:GetProfile(plr) or nil
		if prof then
			prof.Data.Settings = normalizeOrDefaults(prof.Data.Settings)
			applyAttrs(plr, prof.Data.Settings)
		else
			applyAttrs(plr, DEFAULTS)
		end
	end
end

return SettingsController

---

--- ServerScriptService.Controllers.LevelUpController (ModuleScript) ---
--!strict
local Players            = game:GetService("Players")
local ReplicatedStorage  = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

local PlayerController = require(ServerScriptService.Controllers:WaitForChild("PlayerController"))
local Config           = require(ReplicatedStorage.Modules:WaitForChild("LevelUpConfiguration"))

local LevelUpController = {}
LevelUpController._started = false

local SKIP_PRODUCT_ID  = 3445097534
local SKIP_TOKENS_KEY  = "LevelUpSkipTokens"

-- ===== Remotes =====
local function ensureEvents()
	local events = ReplicatedStorage:FindFirstChild("Events")
	if not events then
		events = Instance.new("Folder")
		events.Name = "Events"
		events.Parent = ReplicatedStorage
	end

	local function rf(name: string)
		local x = events:FindFirstChild(name) :: RemoteFunction?
		if not x then
			x = Instance.new("RemoteFunction")
			x.Name = name
			x.Parent = events
		end
		return x
	end

	local function re(name: string)
		local x = events:FindFirstChild(name) :: RemoteEvent?
		if not x then
			x = Instance.new("RemoteEvent")
			x.Name = name
			x.Parent = events
		end
		return x
	end

	-- ðŸ”¹ make sure we have BlockInventoryUpdated here too
	local blockInvUpdated = events:FindFirstChild("BlockInventoryUpdated") :: RemoteEvent?
	if not blockInvUpdated then
		blockInvUpdated = Instance.new("RemoteEvent")
		blockInvUpdated.Name = "BlockInventoryUpdated"
		blockInvUpdated.Parent = events
	end

	return {
		List               = rf("LevelUp_List"),
		Start              = re("LevelUp_Start"),
		Claim              = rf("LevelUp_Claim"),
		JobPush            = re("LevelUp_JobUpdated"),
		PromptSkip         = re("PromptLevelUpSkipPurchase"),
		ShowNotification   = events:FindFirstChild("ShowNotification") :: RemoteEvent?,
		PromptAnyProduct   = events:WaitForChild("PromptSkipTimerRequest") :: RemoteEvent,
		BlockInventoryUpdated = blockInvUpdated, -- ðŸ”¹ expose it
	}
end

local Events = ensureEvents()

local function now()
	return os.time()
end

local function getProfile(p: Player)
	local prof = PlayerController:GetProfile(p)
	while not prof do
		task.wait()
		prof = PlayerController:GetProfile(p)
	end
	return prof
end

local function getCost(baseId: string, tier: number)
	local rules = Config.RULES[baseId]
	if not rules then return nil, "No rules" end
	tier = tonumber(tier) or 1
	local r = rules[tier]
	if not r then return nil, "Invalid tier" end

	local consumeId = (tier > 1) and Config.ResultId(baseId, tier - 1) or baseId
	local seconds   = Config.TIER_SECONDS[math.clamp(tier,1,#Config.TIER_SECONDS)] or 0

	return {
		consumeId = consumeId,
		units     = r.units,
		cash      = r.cash or 0,
		seconds   = seconds,
	}, nil
end

-- ===== Payload =====
local function buildList(player: Player)
	local d = getProfile(player).Data
	d[Config.PROFILE_KEYS.UNITS] = d[Config.PROFILE_KEYS.UNITS] or {}
	d[SKIP_TOKENS_KEY]           = d[SKIP_TOKENS_KEY]           or 0

	local units = {}
	for _, id in ipairs(Config.MUTABLE) do
		table.insert(units, {
			id    = id,
			count = tonumber(d[Config.PROFILE_KEYS.UNITS][id] or 0) or 0,
		})
	end

	local cash = tonumber(d.Cash or 0) or 0

	return {
		cash       = cash,
		units      = units,
		job        = d[Config.PROFILE_KEYS.JOB],
		inv        = d[Config.PROFILE_KEYS.UNITS],
		skipTokens = d[SKIP_TOKENS_KEY],
	}
end

-- ===== Core ops =====
local function claimJob(player: Player)
	local d = getProfile(player).Data
	local job = d[Config.PROFILE_KEYS.JOB]
	if not job then return false, "No active level-up." end
	if now() < (job.finishesAt or 0) then return false, "Still leveling." end

	d[Config.PROFILE_KEYS.JOB] = nil
	d[Config.PROFILE_KEYS.UNITS] = d[Config.PROFILE_KEYS.UNITS] or {}
	d[Config.PROFILE_KEYS.UNITS][job.output] =
		(d[Config.PROFILE_KEYS.UNITS][job.output] or 0) + 1

	-- ðŸ”¹ notify client inventory changed
	if Events.BlockInventoryUpdated then
		Events.BlockInventoryUpdated:FireClient(player, d[Config.PROFILE_KEYS.UNITS])
	end

	Events.JobPush:FireClient(player, { claimed = true, output = job.output })
	return true, job.output
end

local function fastFinishIfAny(player: Player): boolean
	local d = getProfile(player).Data
	d[SKIP_TOKENS_KEY] = d[SKIP_TOKENS_KEY] or 0
	local job = d[Config.PROFILE_KEYS.JOB]
	if not job then return false end

	if (d[SKIP_TOKENS_KEY] or 0) > 0 then
		d[SKIP_TOKENS_KEY] -= 1
	end

	job.finishesAt = now()
	local ok = select(1, claimJob(player))
	if ok and Events.ShowNotification then
		Events.ShowNotification:FireClient(player, "Level up skipped! New unit claimed.", "Success")
	end
	return ok
end

local function startJob(player: Player, baseId: string, tier: number?)
	tier = tonumber(tier) or 1
	local d = getProfile(player).Data
	if d[Config.PROFILE_KEYS.JOB] then return false, "Level up already running." end

	local cost, err = getCost(baseId, tier)
	if not cost then return false, err end

	local inv = d[Config.PROFILE_KEYS.UNITS]
	inv = inv or {}
	d[Config.PROFILE_KEYS.UNITS] = inv

	local haveUnits = tonumber(inv[cost.consumeId] or 0) or 0
	local cash = tonumber(d.Cash or 0) or 0

	if haveUnits < cost.units then return false, "Not enough units." end
	if cash < (cost.cash or 0) then return false, "Not enough cash." end

	-- spend units
	inv[cost.consumeId] = haveUnits - cost.units

	-- ðŸ”¹ notify client inventory changed after spending input units
	if Events.BlockInventoryUpdated then
		Events.BlockInventoryUpdated:FireClient(player, inv)
	end

	if cost.cash and cost.cash > 0 then
		if not PlayerController.RemoveCash(player, cost.cash) then
			return false, "Not enough cash."
		end
	end

	local job = {
		input      = baseId,
		tier       = tier,
		output     = Config.ResultId(baseId, tier),
		startedAt  = now(),
		finishesAt = now() + cost.seconds,
	}

	d[Config.PROFILE_KEYS.JOB] = job
	Events.JobPush:FireClient(player, job)

	d[SKIP_TOKENS_KEY] = d[SKIP_TOKENS_KEY] or 0
	if d[SKIP_TOKENS_KEY] > 0 then
		fastFinishIfAny(player)
	end

	return true, job
end

function LevelUpController:SkipActiveJob(player: Player)
	local d = getProfile(player).Data
	local job = d[Config.PROFILE_KEYS.JOB]
	if not job then
		if Events.ShowNotification then
			Events.ShowNotification:FireClient(player, "No active level up to skip.", "Warning")
		end
		return false
	end

	job.finishesAt = now()
	local ok = select(1, claimJob(player))
	if ok and Events.ShowNotification then
		Events.ShowNotification:FireClient(player, "Level up skipped! New unit claimed.", "Success")
	end
	return ok
end

function LevelUpController:Init(_controllers: {[string]: any}?) end

function LevelUpController:Start()
	if self._started then return end
	self._started = true

	local E = Events

	E.PromptSkip.OnServerEvent:Connect(function(player: Player)
		local d = getProfile(player).Data
		if d[Config.PROFILE_KEYS.JOB] then
			E.PromptAnyProduct:FireClient(player, SKIP_PRODUCT_ID)
		else
			if E.ShowNotification then
				E.ShowNotification:FireClient(player, "No active level up to skip.", "Warning")
			end
		end
	end)

	E.List.OnServerInvoke = function(p: Player)
		return buildList(p)
	end

	E.Start.OnServerEvent:Connect(function(p: Player, baseId: string, tier: number?)
		local ok, msg = startJob(p, baseId, tier)
		if not ok then
			E.JobPush:FireClient(p, { error = msg })
		end
	end)

	E.Claim.OnServerInvoke = function(p: Player)
		return claimJob(p)
	end
end

return LevelUpController

---

--- ServerScriptService.Controllers.RewardController (ModuleScript) ---
--!strict
-- ServerScriptService/Controllers/RewardsController

local Players            = game:GetService("Players")
local ReplicatedStorage  = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

local PlayerController    = require(ServerScriptService.Controllers:WaitForChild("PlayerController"))
local RewardConfiguration = require(ReplicatedStorage.Modules:WaitForChild("RewardConfiguration"))

local RewardsController = {}
local _remotes: {[string]: RemoteFunction} = {}

local function getFunctionsFolder(): Folder
	local f = ReplicatedStorage:FindFirstChild("Functions")
	if not f then
		f = Instance.new("Folder")
		f.Name = "Functions"
		f.Parent = ReplicatedStorage
	end
	return f
end

local function ensureRemoteFunction(name: string): RemoteFunction
	local parent = getFunctionsFolder()
	local fn = parent:FindFirstChild(name)
	if not fn then
		fn = Instance.new("RemoteFunction")
		fn.Name = name
		fn.Parent = parent
	end
	_remotes[name] = fn :: RemoteFunction
	return fn :: RemoteFunction
end

----------------------------------------------------------------
-- DAILY HELPERS
----------------------------------------------------------------

local function getDayId(unixTime: number): number
	return math.floor(unixTime / 86400)
end

local function getDailyStateTable(profileData: any)
	profileData.DailyRewards = profileData.DailyRewards or {
		CurrentDay = 1,
		LastClaimDayId = 0,
	}
	local daily = profileData.DailyRewards
	daily.CurrentDay = daily.CurrentDay or 1
	daily.LastClaimDayId = daily.LastClaimDayId or 0
	return daily
end

local function buildDailyInfo(profileData: any)
	local daily = getDailyStateTable(profileData)
	local now = os.time()
	local todayId = getDayId(now)

	local currentDay = math.clamp(daily.CurrentDay, 1, RewardConfiguration.MaxDailyDay)
	local alreadyClaimedToday = (daily.LastClaimDayId == todayId)

	local secondsUntilNextClaim = 0
	if alreadyClaimedToday then
		local nextDayStart = (todayId + 1) * 86400
		secondsUntilNextClaim = math.max(0, nextDayStart - now)
	end

	return {
		currentDay = currentDay,
		alreadyClaimedToday = alreadyClaimedToday,
		secondsUntilNextClaim = secondsUntilNextClaim,
	}
end

local function applyDailyReward(player: Player, profileData: any, dayIndex: number): string
	local def = RewardConfiguration.DailyRewards[dayIndex]
	if not def then
		return "No reward configured."
	end

	if def.Type == "Cash" then
		PlayerController.AddCash(player, def.Amount or 0)
		return def.Label or ("You received " .. tostring(def.Amount) .. " Cash!")
	end

	-- Everything else is TODO later; just text for now.
	return def.Label or "Reward claimed."
end

----------------------------------------------------------------
-- REMOTE HANDLERS
----------------------------------------------------------------

local function waitForProfile(player: Player)
	local profile = PlayerController:GetProfile(player)
	while not profile do
		task.wait()
		profile = PlayerController:GetProfile(player)
	end
	return profile
end

local function onGetDailyRewardsState(player: Player)
	local profile = waitForProfile(player)
	return buildDailyInfo(profile.Data)
end


local function onClaimDailyReward(player: Player)
	local profile = PlayerController:GetProfile(player)
	if not profile then
		return false, "No profile.", {
			currentDay = 1,
			alreadyClaimedToday = false,
			secondsUntilNextClaim = 0,
		}
	end

	local data = profile.Data
	local daily = getDailyStateTable(data)

	local now = os.time()
	local todayId = getDayId(now)

	local infoBefore = buildDailyInfo(data)

	if infoBefore.alreadyClaimedToday then
		return false, "You already claimed today's reward.", infoBefore
	end

	local dayIndex = infoBefore.currentDay
	local msg = applyDailyReward(player, data, dayIndex)

	-- progress to next day
	daily.LastClaimDayId = todayId
	if daily.CurrentDay < RewardConfiguration.MaxDailyDay then
		daily.CurrentDay += 1
	end

	local infoAfter = buildDailyInfo(data)
	return true, msg, infoAfter
end

----------------------------------------------------------------
-- STANDARD CONTROLLER API
----------------------------------------------------------------

function RewardsController:Init()
	local getStateFn = ensureRemoteFunction("GetDailyRewardsState")
	getStateFn.OnServerInvoke = onGetDailyRewardsState

	local claimFn = ensureRemoteFunction("ClaimDailyReward")
	claimFn.OnServerInvoke = onClaimDailyReward
end

function RewardsController:Start()
	-- nothing
end

return RewardsController

---

--- ServerScriptService.Controllers.CageController (ModuleScript) ---
--!strict

local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace         = game:GetService("Workspace")
local RunService        = game:GetService("RunService")

local Modules                = ReplicatedStorage:WaitForChild("Modules")
local EnemyConfigurations    = require(Modules:WaitForChild("EnemyConfigurations"))
local MutationConfigurations = require(Modules:WaitForChild("MutationConfigurations"))

local CageController = {}

local PlayerController
local PlotController

local _collectDebounce: {[BasePart]: {[Player]: number}} = {}

local MAX_CAGES = 9
local MAX_PROMPT_DISTANCE = 20

local CAGE_COSTS: {[number]: number} = {}
for i = 1, MAX_CAGES do
	CAGE_COSTS[i] = 100_000
end

local ToolsFolder = ReplicatedStorage:FindFirstChild("Tools")

local eventsFolder = ReplicatedStorage:FindFirstChild("Events")
if not eventsFolder then
	eventsFolder = Instance.new("Folder")
	eventsFolder.Name = "Events"
	eventsFolder.Parent = ReplicatedStorage
end

local PromptCageUnlock = eventsFolder:FindFirstChild("PromptCageUnlock") :: RemoteEvent?
if not PromptCageUnlock then
	PromptCageUnlock = Instance.new("RemoteEvent")
	PromptCageUnlock.Name = "PromptCageUnlock"
	PromptCageUnlock.Parent = eventsFolder
end

local ConfirmCageUnlock = eventsFolder:FindFirstChild("ConfirmCageUnlock") :: RemoteEvent?
if not ConfirmCageUnlock then
	ConfirmCageUnlock = Instance.new("RemoteEvent")
	ConfirmCageUnlock.Name = "ConfirmCageUnlock"
	ConfirmCageUnlock.Parent = eventsFolder
end

local function getPlotsFolder(): Instance?
	return Workspace:FindFirstChild("Plots")
end

local function getPlotForPlayer(player: Player): Model?
	local plotsFolder = getPlotsFolder()
	if not plotsFolder then return nil end

	local plotNum = player:GetAttribute("PlotNumber")
	if plotNum then
		local plot = plotsFolder:FindFirstChild("Plot" .. tostring(plotNum))
		if plot and plot:IsA("Model") then return plot end
	end

	for _, plot in ipairs(plotsFolder:GetChildren()) do
		if plot:IsA("Model") and plot:GetAttribute("OwnerId") == player.UserId then
			return plot
		end
	end
	return nil
end

local function getCageSystem(plot: Model): Instance?
	return plot:FindFirstChild("CageSystem")
end

local function getCageIndexFromName(name: string): number?
	local numStr = string.match(name, "^Cage(%d+)$")
	if not numStr then return nil end
	return tonumber(numStr)
end

local function getCageByIndex(plot: Model, index: number): Model?
	local cageSystem = getCageSystem(plot)
	if not cageSystem then return nil end
	local cage = cageSystem:FindFirstChild("Cage" .. tostring(index))
	if cage and cage:IsA("Model") then
		return cage
	end
	return nil
end

local function clearDisplayModel(cage: Model)
	local existing = cage:FindFirstChild("DisplayEnemy")
	if existing then
		existing:Destroy()
	end
end

local function getMutationMultiplier(mutation: string?): number
	if not mutation or mutation == "" then return 1 end
	local cfg = MutationConfigurations[mutation]
	if not cfg then return 1 end
	return cfg.Multiplier or 1
end

local function getRebirthMoneyMultiplierFromProfile(profile: any?): number
	if not profile then return 1 end
	local data = profile.Data
	if not data then return 1 end
	local mult = data.RebirthMoneyMultiplier
	if typeof(mult) == "number" and mult > 0 then
		return mult
	end
	return 1
end

----------------------------------------------------------------
-- ProximityPrompt helpers (text + enabled state)
----------------------------------------------------------------

local function getPlatformMainPart(cage: Model): BasePart?
	local base = cage:FindFirstChild("EnemyPlacementBase", true)
	if base and base:IsA("BasePart") then
		return base
	end

	local platform = cage:FindFirstChild("Platform")
	if platform and platform:IsA("BasePart") then
		return platform
	end

	if platform and platform:IsA("Model") then
		if platform.PrimaryPart then
			return platform.PrimaryPart
		end
		for _, d in ipairs(platform:GetChildren()) do
			if d:IsA("BasePart") then
				return d
			end
		end
	end

	return cage:FindFirstChildWhichIsA("BasePart")
end

local function getCagePrompt(cage: Model): ProximityPrompt?
	local platformPart = getPlatformMainPart(cage)
	if not platformPart then return nil end
	local prompt = platformPart:FindFirstChild("CagePrompt")
	if prompt and prompt:IsA("ProximityPrompt") then
		return prompt
	end
	return nil
end

local function updatePromptTextForCage(cage: Model)
	local prompt = getCagePrompt(cage)
	if not prompt then return end

	local enemyId = cage:GetAttribute("EnemyId") :: string?
	local display = cage:GetAttribute("DisplayName") :: string?

	if enemyId and enemyId ~= "" then
		local nameText = (typeof(display) == "string" and display ~= "" and display) or enemyId
		prompt.ActionText = ("Remove %s"):format(nameText)
	else
		prompt.ActionText = "Place Enemy"
	end

	prompt.ObjectText = ""
end

local function updatePromptEnabledForCage(cage: Model, unlocked: boolean)
	local prompt = getCagePrompt(cage)
	if not prompt then return end
	prompt.Enabled = unlocked
end

----------------------------------------------------------------

local function updateCageAttributes(cage: Model, slotData: any?, profile: any?)
	if not slotData or not slotData.EnemyId then
		cage:SetAttribute("EnemyId", nil)
		cage:SetAttribute("DisplayName", nil)
		cage:SetAttribute("Rarity", nil)
		cage:SetAttribute("Mutation", nil)
		cage:SetAttribute("BaseValuePerSecond", 0)
		cage:SetAttribute("VpsMultiplier", 1)
		cage:SetAttribute("ValuePerSecond", 0)
		cage:SetAttribute("Banked", 0)
		cage:SetAttribute("LastOffline", 0)

		updatePromptTextForCage(cage)
		return
	end

	local enemyId  = slotData.EnemyId :: string
	local mutation = slotData.Mutation :: string?
	local cfg      = EnemyConfigurations[enemyId]

	local displayName = (cfg and cfg.DisplayName) or enemyId
	local rarity      = (cfg and cfg.Rarity) or "Common"
	local baseVps     = (cfg and tonumber(cfg.ValuePerSecond)) or 0

	local mutationMult = getMutationMultiplier(mutation)
	local rebirthMult  = getRebirthMoneyMultiplierFromProfile(profile)
	local vpsMult      = mutationMult * rebirthMult
	local vps          = baseVps * vpsMult

	local banked  = math.floor(slotData.Banked or 0)
	local lastOff = math.floor(slotData.LastOfflineEarned or 0)

	cage:SetAttribute("EnemyId", enemyId)
	cage:SetAttribute("DisplayName", displayName)
	cage:SetAttribute("Rarity", rarity)
	cage:SetAttribute("Mutation", mutation or "")

	cage:SetAttribute("BaseValuePerSecond", baseVps)
	cage:SetAttribute("VpsMultiplier", vpsMult)
	cage:SetAttribute("ValuePerSecond", vps)

	cage:SetAttribute("Banked", banked)
	cage:SetAttribute("LastOffline", lastOff)

	updatePromptTextForCage(cage)
end

local function setCageVisual(cage: Model, unlocked: boolean)
	local targetScale = unlocked and 1 or 0.01
	local currentScale = cage:GetScale()
	if math.abs(currentScale - targetScale) > 1e-4 then
		cage:ScaleTo(targetScale)
	end

	local bars = cage:FindFirstChild("Bars")

	for _, d in ipairs(cage:GetDescendants()) do
		if d:IsA("BasePart") then
			if unlocked then
				d.Transparency = 0

				-- bars are non-collidable so players can walk in
				if bars and d:IsDescendantOf(bars) then
					d.CanCollide = false
					d.CanQuery = false
				else
					d.CanCollide = true
					d.CanQuery = true
				end
			else
				d.Transparency = 1
				d.CanCollide = false
				d.CanQuery = false
			end
		end
	end

	cage:SetAttribute("Unlocked", unlocked)
	updatePromptEnabledForCage(cage, unlocked)
end

local function setButtonVisual(buttonPart: BasePart, unlocked: boolean)
	local container = buttonPart.Parent
	if container and container:IsA("Model") and container.Name:match("^Button%d+$") then
		for _, d in ipairs(container:GetDescendants()) do
			if d:IsA("BasePart") then
				if unlocked then
					d.Transparency = 1
					d.CanCollide = false
					d.CanTouch = false
				else
					d.Transparency = 0
					d.CanCollide = true
					d.CanTouch = true
				end
			elseif d:IsA("SurfaceGui") then
				d.Enabled = not unlocked
			elseif d:IsA("TextLabel") then
				d.Visible = not unlocked
			end
		end
	else
		if unlocked then
			buttonPart.Transparency = 1
			buttonPart.CanCollide = false
			buttonPart.CanTouch = false
		else
			buttonPart.Transparency = 0
			buttonPart.CanCollide = true
			buttonPart.CanTouch = true
		end
	end
end

local function getButtonPart(cp: Model, index: number): BasePart?
	local inst = cp:FindFirstChild("Button" .. index)
	if not inst then return nil end

	if inst:IsA("BasePart") then
		return inst
	elseif inst:IsA("Model") then
		if inst.PrimaryPart then
			return inst.PrimaryPart
		end
		for _, d in ipairs(inst:GetDescendants()) do
			if d:IsA("BasePart") then
				return d
			end
		end
	end

	return nil
end

local function clearPlacerTools(player: Player)
	local function clear(container: Instance?)
		if not container then return end
		for _, inst in ipairs(container:GetChildren()) do
			if inst:IsA("Tool") and inst:GetAttribute("IsEnemyPlacer") == true then
				inst:Destroy()
			end
		end
	end

	clear(player:FindFirstChildOfClass("Backpack"))
	if player.Character then
		clear(player.Character)
	end
end

local function createDisplayModel(cage: Model, enemyId: string)
	clearDisplayModel(cage)

	local enemiesFolder = ReplicatedStorage:FindFirstChild("Enemies")
	if not enemiesFolder then return end
	local template = enemiesFolder:FindFirstChild(enemyId)
	if not template or not template:IsA("Model") then return end

	local clone = template:Clone()
	clone.Name = "DisplayEnemy"

	for _, d in ipairs(clone:GetDescendants()) do
		if d:IsA("BasePart") then
			d.Anchored = true
			d.CanCollide = false
		end
	end

	local basePart = cage:FindFirstChild("EnemyPlacementBase", true)
	if not (basePart and basePart:IsA("BasePart")) then
		basePart = getPlatformMainPart(cage)
	end
	if not basePart then return end

	local idx = getCageIndexFromName(cage.Name) or 1
	local yawDeg = 0
	if idx >= 1 and idx <= 3 then
		yawDeg = 180
	elseif idx >= 4 and idx <= 6 then
		yawDeg = 90
	else
		yawDeg = 0
	end

	local targetCFrame = basePart.CFrame * CFrame.Angles(0, math.rad(yawDeg), 0)
	clone:PivotTo(targetCFrame)

	clone.Parent = cage
end


function CageController:_OnCagePrompt(player: Player, cage: Model)
	local plot = getPlotForPlayer(player)
	if not plot then return end
	if not cage:IsDescendantOf(plot) then return end
	if not (cage:GetAttribute("Unlocked") == true) then return end

	local profile = PlayerController:GetProfile(player)
	if not profile then return end

	profile.Data.CageSlots = profile.Data.CageSlots or {}
	local slots = profile.Data.CageSlots

	local idx = getCageIndexFromName(cage.Name)
	if not idx then return end

	local slot = slots[idx]
	local selectedEnemy = player:GetAttribute("SelectedEnemyId")
	if typeof(selectedEnemy) ~= "string" then
		selectedEnemy = nil
	end

	if slot and slot.EnemyId and (not selectedEnemy or selectedEnemy == "") then
		local enemyId = slot.EnemyId
		slots[idx] = nil
		clearDisplayModel(cage)
		updateCageAttributes(cage, nil, profile)
		PlayerController.AddCapturedEnemy(player, enemyId)
		return
	end

	if not slot or not slot.EnemyId then
		if not selectedEnemy or selectedEnemy == "" then
			return
		end

		if not PlayerController.TryConsumeEnemy(player, selectedEnemy) then
			return
		end

		local now = os.time()
		slots[idx] = {
			EnemyId = selectedEnemy,
			Banked = 0,
			LastTick = now,
			LastOfflineEarned = 0,
		}

		createDisplayModel(cage, selectedEnemy)
		updateCageAttributes(cage, slots[idx], profile)

		player:SetAttribute("SelectedEnemyId", nil)
		player:SetAttribute("SelectedEnemyDisplayName", nil)

		clearPlacerTools(player)
	end
end

function CageController:_OnCollect(player: Player, cage: Model)
	local plot = getPlotForPlayer(player)
	if not plot then return end
	if not cage:IsDescendantOf(plot) then return end
	if not (cage:GetAttribute("Unlocked") == true) then return end

	local profile = PlayerController:GetProfile(player)
	if not profile then return end

	profile.Data.CageSlots = profile.Data.CageSlots or {}
	local slots = profile.Data.CageSlots

	local idx = getCageIndexFromName(cage.Name)
	if not idx then return end

	local slot = slots[idx]
	if not slot or not slot.EnemyId then return end

	local amount = math.floor(slot.Banked or 0)
	if amount <= 0 then return end

	slot.Banked = (slot.Banked or 0) - amount
	slot.LastOfflineEarned = 0

	PlayerController.AddCash(player, amount)
	updateCageAttributes(cage, slot, profile)
end

local function setupCageInteractions(cage: Model)
	if cage:GetAttribute("PromptSetup") then return end

	local platformPart = getPlatformMainPart(cage)
	if not platformPart then return end

	if not _collectDebounce[platformPart] then
		_collectDebounce[platformPart] = {}
	end

	local prompt = platformPart:FindFirstChild("CagePrompt") :: ProximityPrompt?
	if not prompt then
		prompt = Instance.new("ProximityPrompt")
		prompt.Name = "CagePrompt"
		prompt.HoldDuration = 0
		prompt.RequiresLineOfSight = false
		prompt.Parent = platformPart
	end

	prompt.MaxActivationDistance = MAX_PROMPT_DISTANCE
	if not prompt:GetAttribute("ClampDistHooked") then
		prompt:GetPropertyChangedSignal("MaxActivationDistance"):Connect(function()
			if prompt.MaxActivationDistance > MAX_PROMPT_DISTANCE then
				prompt.MaxActivationDistance = MAX_PROMPT_DISTANCE
			end
		end)
		prompt:SetAttribute("ClampDistHooked", true)
	end

	-- text will be set based on current attributes
	updatePromptTextForCage(cage)

	if not prompt:GetAttribute("Hooked") then
		prompt.Triggered:Connect(function(p: Player)
			CageController:_OnCagePrompt(p, cage)
		end)
		prompt:SetAttribute("Hooked", true)
	end

	if not platformPart:GetAttribute("CollectHooked") then
		platformPart.Touched:Connect(function(hit: BasePart)
			local character = hit:FindFirstAncestorOfClass("Model")
			if not character then return end
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if not humanoid then return end

			local p = Players:GetPlayerFromCharacter(character)
			if not p then return end

			local now = os.clock()
			local debounces = _collectDebounce[platformPart]
			local last = debounces[p] or 0
			if now - last < 0.5 then return end
			debounces[p] = now

			CageController:_OnCollect(p, cage)
		end)

		platformPart:SetAttribute("CollectHooked", true)
	end

	cage:SetAttribute("PromptSetup", true)
end

local function handleUnlockTouch(button: BasePart, plot: Model, index: number, player: Player)
	local ownerPlot = getPlotForPlayer(player)
	if ownerPlot and ownerPlot ~= plot then
		return
	end

	button.CanTouch = true

	local cost = CAGE_COSTS[index] or 100_000
	if PromptCageUnlock then
		PromptCageUnlock:FireClient(player, index, cost)
	end
end

local function setupUnlockButtonsForPlot(plot: Model)
	local cageSystem = getCageSystem(plot)
	if not cageSystem then return end

	for index = 1, MAX_CAGES do
		local cp = cageSystem:FindFirstChild("CagePlatform" .. index)
		if cp and cp:IsA("Model") then
			local buttonPart = getButtonPart(cp, index)
			if buttonPart and not buttonPart:GetAttribute("UnlockHooked") then
				buttonPart.CanTouch = true

				buttonPart.Touched:Connect(function(hit: BasePart)
					local character = hit:FindFirstAncestorOfClass("Model")
					if not character then return end
					local humanoid = character:FindFirstChildOfClass("Humanoid")
					if not humanoid then return end

					local plr = Players:GetPlayerFromCharacter(character)
					if not plr then return end

					handleUnlockTouch(buttonPart, plot, index, plr)
				end)

				buttonPart:SetAttribute("UnlockHooked", true)
			end
		end
	end
end

local function applyUnlockStateForPlayer(player: Player, plot: Model)
	local profile = PlayerController:GetProfile(player)
	if not profile then return end

	profile.Data.CageUnlocks = profile.Data.CageUnlocks or {}
	local unlocks = profile.Data.CageUnlocks

	local cageSystem = getCageSystem(plot)
	if not cageSystem then return end

	for index = 1, MAX_CAGES do
		local cage = cageSystem:FindFirstChild("Cage" .. index)
		local cp   = cageSystem:FindFirstChild("CagePlatform" .. index)

		local unlocked = unlocks[index] == true

		if cage and cage:IsA("Model") then
			setupCageInteractions(cage)
			setCageVisual(cage, unlocked)
		end

		if cp and cp:IsA("Model") then
			local buttonPart = getButtonPart(cp, index)
			if buttonPart then
				local prevUnlocked = (index == 1) or (unlocks[index - 1] == true)
				local active = (not unlocked) and prevUnlocked
				setButtonVisual(buttonPart, unlocked or (not active))
			end
		end
	end
end

function CageController:OnPlayerProfileLoaded(player: Player)
	local plot = getPlotForPlayer(player)
	if not plot then return end

	setupUnlockButtonsForPlot(plot)

	local profile = PlayerController:GetProfile(player)
	if not profile then return end

	applyUnlockStateForPlayer(player, plot)

	profile.Data.CageSlots = profile.Data.CageSlots or {}
	local slots = profile.Data.CageSlots

	local now = os.time()
	local rebirthMult = getRebirthMoneyMultiplierFromProfile(profile)

	for idx, slot in pairs(slots) do
		if typeof(idx) == "number" and type(slot) == "table" and slot.EnemyId then
			local cage = getCageByIndex(plot, idx)
			if cage then
				createDisplayModel(cage, slot.EnemyId)

				local cfg  = EnemyConfigurations[slot.EnemyId]
				local base = (cfg and tonumber(cfg.ValuePerSecond)) or 0
				local mut  = getMutationMultiplier(slot.Mutation)
				local vps  = base * mut * rebirthMult

				local lastTick = slot.LastTick or now
				local dtOffline = math.max(0, now - lastTick)
				local offlineEarned = math.floor(vps * dtOffline + 0.5)

				slot.Banked = math.max(0, math.floor((slot.Banked or 0) + offlineEarned))
				slot.LastOfflineEarned = offlineEarned
				slot.LastTick = now

				updateCageAttributes(cage, slot, profile)
			end
		end
	end
end

local function heartbeatTick()
	local now = os.time()

	for _, player in ipairs(Players:GetPlayers()) do
		local profile = PlayerController:GetProfile(player)
		if not profile then continue end

		local slots = profile.Data.CageSlots
		if not slots then continue end

		local plot = getPlotForPlayer(player)
		if not plot then continue end

		local rebirthMult = getRebirthMoneyMultiplierFromProfile(profile)

		for idx, slot in pairs(slots) do
			if type(slot) == "table" and slot.EnemyId then
				local cfg  = EnemyConfigurations[slot.EnemyId]
				local base = (cfg and tonumber(cfg.ValuePerSecond)) or 0
				local mut  = getMutationMultiplier(slot.Mutation)
				local vps  = base * mut * rebirthMult

				local lastTick = slot.LastTick or now
				local dt = math.max(0, now - lastTick)
				if dt > 0 and vps > 0 then
					local inc = vps * dt
					slot.Banked = math.max(0, (slot.Banked or 0) + inc)
				end
				slot.LastTick = now

				local plotModel = getPlotForPlayer(player)
				if plotModel then
					local cage = getCageByIndex(plotModel, idx)
					if cage then
						updateCageAttributes(cage, slot, profile)
					end
				end
			end
		end
	end
end

function CageController:GivePlacementTool(player: Player, enemyId: string)
	if not enemyId or enemyId == "" then return end

	local cfg = EnemyConfigurations[enemyId]
	if not cfg then return end

	local backpack = player:FindFirstChildOfClass("Backpack")
	if not backpack then return end

	local function clearOldPlacers(container: Instance)
		for _, inst in ipairs(container:GetChildren()) do
			if inst:IsA("Tool") and inst:GetAttribute("IsEnemyPlacer") == true then
				inst:Destroy()
			end
		end
	end

	clearOldPlacers(backpack)
	if player.Character then
		clearOldPlacers(player.Character)
	end

	local tool: Tool

	local template: Tool? = nil
	if ToolsFolder then
		local byName = ToolsFolder:FindFirstChild(enemyId .. " Placer")
		if byName and byName:IsA("Tool") then
			template = byName
		else
			local stub = ToolsFolder:FindFirstChild("EnemyPlacerStub")
			if stub and stub:IsA("Tool") then
				template = stub
			end
		end
	end

	if template then
		tool = template:Clone()
	else
		tool = Instance.new("Tool")
		tool.Name = enemyId .. " Placer"
		tool.RequiresHandle = true
		tool.CanBeDropped = false

		local handle = Instance.new("Part")
		handle.Name = "Handle"
		handle.Shape = Enum.PartType.Cylinder
		handle.Size = Vector3.new(1, 0.4, 1)
		handle.Color = Color3.fromRGB(255, 204, 77)
		handle.Material = Enum.Material.Plastic
		handle.TopSurface = Enum.SurfaceType.Smooth
		handle.BottomSurface = Enum.SurfaceType.Smooth
		handle.Transparency = 0
		handle.CanCollide = false
		handle.Parent = tool
	end

	tool:SetAttribute("IsEnemyPlacer", true)
	tool:SetAttribute("EnemyId", enemyId)
	tool:SetAttribute("DisplayName", (cfg and cfg.DisplayName) or enemyId)

	if not tool:GetAttribute("Hooked") then
		tool.Equipped:Connect(function()
			local eid  = tool:GetAttribute("EnemyId")
			local disp = tool:GetAttribute("DisplayName")
			if type(eid) == "string" then
				player:SetAttribute("SelectedEnemyId", eid)
				player:SetAttribute("SelectedEnemyDisplayName", disp or eid)
			end
		end)

		tool.Unequipped:Connect(function()
			player:SetAttribute("SelectedEnemyId", nil)
			player:SetAttribute("SelectedEnemyDisplayName", nil)
		end)

		tool:SetAttribute("Hooked", true)
	end

	tool.Parent = backpack

	local char = player.Character
	local humanoid = char and char:FindFirstChildOfClass("Humanoid")
	if humanoid then
		humanoid:EquipTool(tool)
	end
end

function CageController:ApplyUnlockStateForPlayer(player: Player)
	local plot = getPlotForPlayer(player)
	if not plot then return end
	applyUnlockStateForPlayer(player, plot)
end

function CageController:Init(controllers: {[string]: any})
	PlayerController = controllers.PlayerController
	PlotController   = controllers.PlotController

	if ConfirmCageUnlock then
		ConfirmCageUnlock.OnServerEvent:Connect(function(player: Player, index: number)
			index = tonumber(index) or 0
			if index < 1 or index > MAX_CAGES then return end

			local plot = getPlotForPlayer(player)
			if not plot then return end

			local profile = PlayerController:GetProfile(player)
			if not profile then return end

			profile.Data.CageUnlocks = profile.Data.CageUnlocks or {}
			local unlocks = profile.Data.CageUnlocks

			for i = 1, index - 1 do
				if not unlocks[i] then
					local notify = eventsFolder:FindFirstChild("ShowNotification") :: RemoteEvent?
					if notify then
						notify:FireClient(player, "Unlock previous cages first.", "Warning")
					end
					return
				end
			end

			if unlocks[index] then
				return
			end

			local cost = CAGE_COSTS[index] or 100_000
			if not PlayerController.RemoveCash(player, cost) then
				local notify = eventsFolder:FindFirstChild("ShowNotification") :: RemoteEvent?
				if notify then
					notify:FireClient(player, "Not enough cash!", "Error")
				end
				return
			end

			unlocks[index] = true
			profile.Data.CageUnlocks = unlocks

			applyUnlockStateForPlayer(player, plot)

			local notify = eventsFolder:FindFirstChild("ShowNotification") :: RemoteEvent?
			if notify then
				notify:FireClient(player, ("Unlocked Cage %d!"):format(index), "Success")
			end
		end)
	end

	local plotsFolder = getPlotsFolder()
	if plotsFolder then
		for _, plot in ipairs(plotsFolder:GetChildren()) do
			if plot:IsA("Model") then
				setupUnlockButtonsForPlot(plot)
			end
		end
	end
end

function CageController:Start()
	RunService.Heartbeat:Connect(heartbeatTick)

	Players.PlayerRemoving:Connect(function(player)
		for _, debounces in pairs(_collectDebounce) do
			debounces[player] = nil
		end
	end)
end

return CageController

---

--- ServerScriptService.Controllers.TipBroadcaster (Script) ---
--!strict
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players           = game:GetService("Players")

local eventsFolder = ReplicatedStorage:FindFirstChild("Events")
if not eventsFolder then
	eventsFolder = Instance.new("Folder")
	eventsFolder.Name = "Events"
	eventsFolder.Parent = ReplicatedStorage
end

local ChatHint = eventsFolder:FindFirstChild("ChatHint") :: RemoteEvent?
if not ChatHint then
	ChatHint = Instance.new("RemoteEvent")
	ChatHint.Name = "ChatHint"
	ChatHint.Parent = eventsFolder
end

local HINTS: {string} = {
	"Walk into your cages to collect the money your captured enemies made ! ",
	"You can place captured enemies into cages to earn money over time.",
	"Unlock more cages to generate more money ! ",
	"Your captured enemies make money offline zzZ",
	"Use your rebirths to unlock more cages and earn more.",
}

task.spawn(function()
	while true do
		task.wait(300) -- every 300s 
		if #Players:GetPlayers() > 0 and #HINTS > 0 then
			local msg = HINTS[math.random(1, #HINTS)]
			ChatHint:FireAllClients(msg)
		end
	end
end)

---

--- ServerScriptService.Controllers.RebirthController (ModuleScript) ---
--!strict

local Players             = game:GetService("Players")
local ReplicatedStorage   = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

local Modules         = ReplicatedStorage:WaitForChild("Modules")
local NumberFormatter = require(Modules:WaitForChild("NumberFormatter"))
local RebirthConfig   = require(Modules:WaitForChild("RebirthConfig"))

local PlayerController  = require(ServerScriptService.Controllers:WaitForChild("PlayerController"))
local CageController    = require(ServerScriptService.Controllers:WaitForChild("CageController"))

local EventsFolder = ReplicatedStorage:FindFirstChild("Events")
if not EventsFolder then
	EventsFolder = Instance.new("Folder")
	EventsFolder.Name = "Events"
	EventsFolder.Parent = ReplicatedStorage
end

local FunctionsFolder = ReplicatedStorage:FindFirstChild("Functions")
if not FunctionsFolder then
	FunctionsFolder = Instance.new("Folder")
	FunctionsFolder.Name = "Functions"
	FunctionsFolder.Parent = ReplicatedStorage
end

local ShowNotification = EventsFolder:WaitForChild("ShowNotification") :: RemoteEvent

local RebirthRequested = EventsFolder:FindFirstChild("RebirthRequested") :: RemoteEvent?
if not RebirthRequested then
	RebirthRequested = Instance.new("RemoteEvent")
	RebirthRequested.Name = "RebirthRequested"
	RebirthRequested.Parent = EventsFolder
end

local GetRebirthStateFn = FunctionsFolder:FindFirstChild("GetRebirthState") :: RemoteFunction?
if not GetRebirthStateFn then
	GetRebirthStateFn = Instance.new("RemoteFunction")
	GetRebirthStateFn.Name = "GetRebirthState"
	GetRebirthStateFn.Parent = FunctionsFolder
end

export type RebirthCfg = {
	RequiredCash: number,
	MoneyBonusPercent: number,
	LuckBonusPercent: number,
	UnlockCages: {number}?,
}

local MAX_REBIRTH = RebirthConfig.MaxRebirth

local RebirthController = {}

local function computeRebirthMultipliers(rebirths: number): (number, number)
	local money = 1
	local luck  = 1
	for i = 1, rebirths do
		local cfg = RebirthConfig[i]
		if cfg then
			money += (cfg.MoneyBonusPercent or 0) / 100
			luck  += (cfg.LuckBonusPercent or 0) / 100
		end
	end
	return money, luck
end

local function initPlayerRebirth(player: Player)
	local profile = PlayerController:GetProfile(player)
	while not profile do
		if not player.Parent then return end
		task.wait(0.5)
		profile = PlayerController:GetProfile(player)
	end

	local data = profile.Data
	data.Rebirths = data.Rebirths or 0

	local moneyMult, luckMult = computeRebirthMultipliers(data.Rebirths)
	data.RebirthMoneyMultiplier = moneyMult
	data.RebirthLuckMultiplier  = luckMult

	player:SetAttribute("Rebirths", data.Rebirths)
	player:SetAttribute("RebirthMoneyMultiplier", moneyMult)
	player:SetAttribute("RebirthLuckMultiplier", luckMult)
end

function RebirthController:GetRebirthState(player: Player)
	local profile = PlayerController:GetProfile(player)
	if not profile then return nil end

	local data     = profile.Data
	local rebirths = data.Rebirths or 0
	local cash     = data.Cash or 0

	local nextIndex = rebirths + 1
	local cfg       = RebirthConfig[nextIndex]

	local moneyMult, luckMult = computeRebirthMultipliers(rebirths)

	local requiredCash = cfg and cfg.RequiredCash or 0
	local canRebirth = cfg ~= nil and rebirths < MAX_REBIRTH and cash >= requiredCash

	return {
		CurrentRebirth  = rebirths,
		MaxRebirth      = MAX_REBIRTH,
		Cash            = cash,
		RequiredCash    = requiredCash,
		MoneyMultiplier = moneyMult,
		LuckMultiplier  = luckMult,

		CanRebirth = canRebirth,
		NextIndex  = nextIndex,
		NextConfig = cfg,
	}
end

function RebirthController:TryRebirth(player: Player): (boolean, string?)
	local profile = PlayerController:GetProfile(player)
	if not profile then
		return false, "Profile not loaded."
	end

	local data      = profile.Data
	local rebirths  = data.Rebirths or 0
	local nextIndex = rebirths + 1
	local cfg       = RebirthConfig[nextIndex]

	if not cfg then
		return false, "You reached the max Rebirth."
	end

	local cash = data.Cash or 0
	if cash < cfg.RequiredCash then
		return false, ("You need %s cash to Rebirth.")
			:format(NumberFormatter.formatNumber(cfg.RequiredCash))
	end

	-- wipe cash (set to 0)
	if cash > 0 then
		PlayerController.RemoveCash(player, cash)
	end

	-- increase rebirth count
	data.Rebirths = rebirths + 1

	-- recompute multipliers
	local moneyMult, luckMult = computeRebirthMultipliers(data.Rebirths)
	data.RebirthMoneyMultiplier = moneyMult
	data.RebirthLuckMultiplier  = luckMult

	player:SetAttribute("Rebirths", data.Rebirths)
	player:SetAttribute("RebirthMoneyMultiplier", moneyMult)
	player:SetAttribute("RebirthLuckMultiplier", luckMult)

	-- auto-unlock cages from this rebirth config, if any
	data.CageUnlocks = data.CageUnlocks or {}
	if cfg.UnlockCages then
		for _, cageIdx in ipairs(cfg.UnlockCages) do
			data.CageUnlocks[cageIdx] = true
		end
	end

	-- refresh cage visuals & buttons
	if CageController and CageController.ApplyUnlockStateForPlayer then
		CageController:ApplyUnlockStateForPlayer(player)
	end

	return true, nil
end

function RebirthController:Start()
	Players.PlayerAdded:Connect(initPlayerRebirth)
	for _, plr in ipairs(Players:GetPlayers()) do
		task.spawn(initPlayerRebirth, plr)
	end

	RebirthRequested.OnServerEvent:Connect(function(player: Player)
		local ok, err = RebirthController:TryRebirth(player)
		if ok then
			ShowNotification:FireClient(player, "Rebirth successful!", "Success")
		else
			if err then
				ShowNotification:FireClient(player, err, "Error")
			end
		end
	end)

	GetRebirthStateFn.OnServerInvoke = function(player: Player)
		return RebirthController:GetRebirthState(player)
	end
end

return RebirthController

---

--- ReplicatedStorage.Modules.NumberFormatter (ModuleScript) ---
--!strict

local NumberFormatter = {}

local suffixes: {string} = {"", "K", "M", "B", "T", "Q"}

-- ## MODIFIED ## Changed to a more generic function that accepts an optional prefix.
function NumberFormatter.formatNumber(number: number, prefix: string?): string
	-- Use the provided prefix, or an empty string if none is given.
	local formattedString: string = prefix or ""
	local i: number = 1

	while number >= 1000 and i < #suffixes do
		number /= 1000
		i += 1
	end

	local suffix: string = suffixes[i]
	if suffix == "" then
		formattedString ..= tostring(math.floor(number))
	else
		formattedString ..= string.format("%.2f", number) .. suffix
	end

	return formattedString
end

return NumberFormatter
---

--- ReplicatedStorage.Modules.NotificationManager (ModuleScript) ---
--!strict
-- ReplicatedStorage.Modules.NotificationManager.lua (Client-only module)

local CollectionService = game:GetService("CollectionService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SoundService = game:GetService("SoundService")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting") -- ## ADDED ##

local NotificationManager = {}

local playerGui: PlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
local notificationFrame: Frame = playerGui:WaitForChild("GUI"):WaitForChild("Frames"):WaitForChild("Notifications")
local notificationTemplate: TextLabel = ReplicatedStorage:WaitForChild("Templates"):WaitForChild("NotificationTemplate")

local TWEEN_INFO_FADE: TweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
local NOTIFICATION_LIFETIME: number = 5

-- ## ADDED ## Variables for the time shift effect
local ORIGINAL_CLOCK_TIME = 14.5
local isTimeShifted = false

-- Color definitions
local successStrokeColor = Color3.fromRGB(33, 100, 0)
local successGradient = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 0)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 0))
})

local errorStrokeColor = Color3.fromRGB(145, 0, 0)
local errorGradient = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 85, 127))
})

local normalStrokeColor = Color3.fromRGB(145, 97, 0)
local normalGradient = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 170, 0)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 0))
})

-- ## ADDED ## New styles for Legendary and Mythical
local legendaryStrokeColor = Color3.fromRGB(125, 0, 0)
local legendaryGradient = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 0))
})

local mythicalStrokeColor = Color3.fromRGB(100, 33, 50)
local mythicalGradient = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 127)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 170, 127))
})


-- ## NEW FUNCTION ## Handles the entire day-to-night-to-day animation
local function triggerTimeShift()
	if isTimeShifted then return end
	isTimeShifted = true

	local tweenInfo = TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)

	-- Transition to night
	local toNightTween = TweenService:Create(Lighting, tweenInfo, {ClockTime = 0})
	toNightTween:Play()
	toNightTween.Completed:Wait()

	-- Hold for 5 seconds
	task.wait(5)

	-- Transition back to day
	local toDayTween = TweenService:Create(Lighting, tweenInfo, {ClockTime = ORIGINAL_CLOCK_TIME})
	toDayTween:Play()
	toDayTween.Completed:Wait()

	isTimeShifted = false
end


function NotificationManager.show(message: string, messageType: string?)
	local newNotification: TextLabel = notificationTemplate:Clone()
	newNotification.Text = message

	local stroke: UIStroke? = newNotification:FindFirstChild("Stroke")
	local gradient: UIGradient? = newNotification:FindFirstChild("Gradient")
	local lifetime = NOTIFICATION_LIFETIME

	if not stroke or not gradient then
		if messageType == "Success" then
			newNotification.TextColor3 = successStrokeColor -- âœ… FIX APPLIED HERE
		elseif messageType == "Error" then
			newNotification.TextColor3 = errorStrokeColor -- âœ… FIX APPLIED HERE
		end
	else
		if messageType == "Success" then
			stroke.Color = successStrokeColor
			gradient.Color = successGradient
		elseif messageType == "Error" then
			stroke.Color = errorStrokeColor
			gradient.Color = errorGradient
		elseif messageType == "Legendary" then
			stroke.Color = legendaryStrokeColor
			gradient.Color = legendaryGradient
			lifetime = 7
			task.spawn(triggerTimeShift) -- ## ADDED ##
		elseif messageType == "Mythical" then
			stroke.Color = mythicalStrokeColor
			gradient.Color = mythicalGradient
			lifetime = 10
			task.spawn(triggerTimeShift) -- ## ADDED ##
		elseif messageType == "Normal" then
			stroke.Color = normalStrokeColor
			gradient.Color = normalGradient
		else
			stroke.Color = normalStrokeColor
			gradient.Color = normalGradient
		end
	end

	newNotification.Parent = notificationFrame

	newNotification.TextTransparency = 1
	if stroke then stroke.Transparency = 1 end

	local textFadeIn: Tween = TweenService:Create(newNotification, TWEEN_INFO_FADE, {TextTransparency = 0})
	local strokeFadeIn: Tween? = stroke and TweenService:Create(stroke, TWEEN_INFO_FADE, {Transparency = 0})

	textFadeIn:Play()
	if strokeFadeIn then strokeFadeIn:Play() end

	if messageType and messageType ~= "NotNormal" then
		local sound: Sound? = Workspace.Sounds:FindFirstChild(messageType)
		if sound then
			SoundService:PlayLocalSound(sound)
		end
	end

	task.wait(lifetime)

	local textFadeOut: Tween = TweenService:Create(newNotification, TWEEN_INFO_FADE, {TextTransparency = 1})
	local strokeFadeOut: Tween? = stroke and TweenService:Create(stroke, TWEEN_INFO_FADE, {Transparency = 1})

	textFadeOut:Play()
	if strokeFadeOut then strokeFadeOut:Play() end

	textFadeOut.Completed:Wait()
	newNotification:Destroy()
end

return NotificationManager
---

--- ReplicatedStorage.Modules.FrameManager (ModuleScript) ---
--!strict

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local FrameManager = {}

-- Event system to broadcast frame state changes
local frameOpenedCallbacks = {}
local frameClosedCallbacks = {}

function FrameManager.onFrameOpened(callback: (frameName: string) -> ())
	table.insert(frameOpenedCallbacks, callback)
end

function FrameManager.onFrameClosed(callback: (frameName: string) -> ())
	table.insert(frameClosedCallbacks, callback)
end

local playerGui: PlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
local framesContainer: Folder = playerGui:WaitForChild("GUI"):WaitForChild("Frames")
local TWEEN_INFO: TweenInfo = TweenInfo.new(0.4, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)

local currentlyOpenFrame: Frame? = nil
local framePositions: {[Frame]: UDim2} = {}
local activeTweens: {[Frame]: {Animation: Tween, CleanupThread: thread?}} = {} -- ## ADDED ##

-- ## NEW FUNCTION ## Safely cancels any ongoing tween and its cleanup task for a given frame.
local function cancelActiveTween(frame: Frame)
	local activeTweenInfo = activeTweens[frame]
	if activeTweenInfo then
		activeTweenInfo.Animation:Cancel()
		if activeTweenInfo.CleanupThread then
			task.cancel(activeTweenInfo.CleanupThread)
		end
		activeTweens[frame] = nil
	end
end

function FrameManager.getOpenFrameName()
	if currentlyOpenFrame and currentlyOpenFrame.Parent then
		return currentlyOpenFrame.Name
	end
	return nil
end

local function initializeFrame(frame: Frame)
	if not framePositions[frame] then
		framePositions[frame] = frame.Position
		local hiddenPosition: UDim2 = UDim2.new(framePositions[frame].X.Scale, framePositions[frame].X.Offset, 1.5, 0)
		frame.Position = hiddenPosition
		frame.Visible = false
	end
end

function FrameManager.close(frameName: string)
	local targetFrame: Frame? = framesContainer:FindFirstChild(frameName)
	if not targetFrame then return end

	-- Do nothing if it's already invisible and not the open frame (avoids closing an already closed frame)
	if not targetFrame.Visible and currentlyOpenFrame ~= targetFrame then return end

	cancelActiveTween(targetFrame) -- Cancel any other tweens on this frame

	if currentlyOpenFrame == targetFrame then
		currentlyOpenFrame = nil
	end

	for _, callback in ipairs(frameClosedCallbacks) do
		task.spawn(callback, frameName)
	end

	initializeFrame(targetFrame)
	local hiddenPosition: UDim2 = UDim2.new(framePositions[targetFrame].X.Scale, framePositions[targetFrame].X.Offset, 1.5, 0)
	local slideOutTween: Tween = TweenService:Create(targetFrame, TWEEN_INFO, {Position = hiddenPosition})

	-- Create a cleanup thread that will run after the animation
	local cleanupThread = task.spawn(function()
		slideOutTween.Completed:Wait()
		targetFrame.Visible = false
		activeTweens[targetFrame] = nil -- Remove from active list once done
	end)

	-- Track the new animation and its cleanup thread
	activeTweens[targetFrame] = {Animation = slideOutTween, CleanupThread = cleanupThread}
	slideOutTween:Play()
end

function FrameManager.open(frameName: string)
	local targetFrame: Frame? = framesContainer:FindFirstChild(frameName)
	if not targetFrame or currentlyOpenFrame == targetFrame then return end

	cancelActiveTween(targetFrame) -- Cancel any other tweens on this frame

	initializeFrame(targetFrame)
	if currentlyOpenFrame then
		FrameManager.close(currentlyOpenFrame.Name)
	end
	targetFrame.Visible = true
	local originalPosition: UDim2 = framePositions[targetFrame]
	local slideInTween: Tween = TweenService:Create(targetFrame, TWEEN_INFO, {Position = originalPosition})

	-- Track the new animation
	activeTweens[targetFrame] = {Animation = slideInTween}
	slideInTween:Play()

	currentlyOpenFrame = targetFrame

	for _, callback in ipairs(frameOpenedCallbacks) do
		task.spawn(callback, frameName)
	end
end

function FrameManager.connect(button: TextButton | ImageButton, frameName: string, action: "Toggle" | "Open" | "Close"?)
	local targetFrame: Frame? = framesContainer:FindFirstChild(frameName)
	if not button or not targetFrame then return end
	action = action or "Toggle"
	initializeFrame(targetFrame)
	button.MouseButton1Click:Connect(function()
		if action == "Close" then
			FrameManager.close(frameName)
		elseif action == "Open" then
			FrameManager.open(frameName)
		else -- Toggle
			if currentlyOpenFrame == targetFrame then
				FrameManager.close(frameName)
			else
				FrameManager.open(frameName)
			end
		end
	end)
end

return FrameManager
---

--- ReplicatedStorage.Modules.HitboxClass (ModuleScript) ---
--!strict

-----------------------------------------------------------------------
--                         HitboxClass v1.1A                         --
-----------------------------------------------------------------------
-- License:                                                          --
--   Licensed under the MIT license.                                 --
--                                                                   --
-- Author:                                                           --
--   RedTrio (VulkanAPI) - January 12, 2024 - Created the module.    --
--                                                                   --
-- Uses Signal by sleitnick.                                         --
-----------------------------------------------------------------------

-- Let me know if you come across any bugs or errors!

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterPlayer = game:GetService("StarterPlayer")
local Players = game:GetService("Players")

local moduleSettings = script.Settings

-- Initial error checking

assert(moduleSettings:FindFirstChild("Alive Folder"), "No Alive Folder setting found in HitboxClass settings! Make an object value and name it 'Alive Folder' and parent it there!")

local aliveFolder = moduleSettings["Alive Folder"].Value

assert(moduleSettings:FindFirstChild("Projectile Folder"), "No Projectile Folder setting found in HitboxClass settings! Make an object value and name it 'Projectile Folder' and parent it there!")

local projectileFolder = moduleSettings["Projectile Folder"].Value

local velocityConstant = moduleSettings:FindFirstChild("Velocity Prediction Constant")

if not velocityConstant then
	warn("Velocity Constant Setting has been deleted! 6 will be used as a default. (HitboxClass)")
end

assert(aliveFolder ~= nil, "Set the alive characters folder in the HitboxClass settings!")
assert(projectileFolder ~= nil, "Set the projectiles folder in the HitboxClass settings!")
assert(aliveFolder:IsDescendantOf(workspace), "The alive folder must be a descendant of workspace! (HitboxClass)")
assert(projectileFolder:IsDescendantOf(workspace), "The projectile folder must be a descendant of workspace! (HitboxClass)")

-- now we initialize the class
local Types = require(script.Types)
local signal = require(script.Signal)
local Timer = require(script.Timer)

local overlapParamsHumanoid = OverlapParams.new()
overlapParamsHumanoid.FilterDescendantsInstances = {aliveFolder}
overlapParamsHumanoid.FilterType = Enum.RaycastFilterType.Include

local overlapParamsObject = OverlapParams.new()
overlapParamsObject.FilterDescendantsInstances = {projectileFolder}
overlapParamsObject.FilterType =  Enum.RaycastFilterType.Exclude

local CFrameZero = CFrame.new(Vector3.zero)

local RunService = game:GetService("RunService")

local HitboxRemote = nil

local function SetupClients()
	local newRemoteEvent = Instance.new("RemoteEvent")
	newRemoteEvent.Name = "HitboxClassRemote"
	newRemoteEvent.Parent = ReplicatedStorage
	HitboxRemote = newRemoteEvent

	local newLocalScript = script.HitboxClassLocal:Clone()
	local newSignalModule = script.Signal:Clone()
	
	local newReference = Instance.new("ObjectValue")
	newReference.Value = script
	newReference.Name = "HitboxClass Module"
	newReference.Parent = newLocalScript

	newSignalModule.Parent = newLocalScript

	newLocalScript.Parent = StarterPlayer:FindFirstChildOfClass("StarterPlayerScripts")

	task.spawn(function()
		for i, Player : Player in pairs(Players:GetChildren()) do

			local ScreenGUI = Instance.new("ScreenGui")
			ScreenGUI.Name = "HitboxClassContainer"
			ScreenGUI.ResetOnSpawn = false

			local newScriptClone = newLocalScript:Clone()
			newScriptClone.Parent = ScreenGUI
			newScriptClone.Enabled = true

			ScreenGUI.Parent = Player:WaitForChild("PlayerGui")

		end
	end)

	newLocalScript.Enabled = true

end

if RunService:IsServer() then
	SetupClients()
else
	HitboxRemote = ReplicatedStorage:FindFirstChild("HitboxClassRemote")
	if not HitboxRemote then
		warn("HitboxClass must be initialized on the server before using it on the client! Waiting for RemoteEvent!")
		HitboxRemote = ReplicatedStorage:WaitForChild("HitboxClassRemote")
	end
end

local Hitbox = {} :: Types.Hitbox

local HitboxCache = {} :: {Types.Hitbox}

local function DeepCopyTable(tableToCopy : {})
	local copy = {}	

	for key, value in pairs(tableToCopy) do	
		if type(value) == "table" then		
			copy[key] = DeepCopyTable(value)		
		else	
			copy[key] = value	
		end
	end

	return copy
end

function Hitbox.new(HitboxParams : Types.HitboxParams)
	local self = (setmetatable({}, {__index = Hitbox}) :: unknown) :: Types.Hitbox

	self.TaggedChars = {}
	self.TaggedObjects = {}
	self.SendingChars = {}
	self.SendingObjects = {}
	self.DelayThreads = {}

	if RunService:IsClient() and HitboxParams._Tick then
		self.TickVal = HitboxParams._Tick
	else
		self.TickVal = workspace:GetServerTimeNow()
	end

	if HitboxParams.ID then
		self.ID = HitboxParams.ID
	end

	self.Blacklist = HitboxParams.Blacklist

	self.HitSomeone = signal.new()
	self.HitObject = signal.new()

	self.DebugMode = HitboxParams.Debug or false
	
	self.Lifetime = HitboxParams.Debris or 0
	
	self.LookingFor = HitboxParams.LookingFor or "Humanoid"

	if HitboxParams.UseClient then

		self.Client = HitboxParams.UseClient

		-- copy the params
		local newDictionary  = DeepCopyTable(HitboxParams) :: Types.HitboxParams

		-- get rid of the UseClient parameter
		newDictionary.UseClient = nil

		-- set the tickval to be the same as the hitbox's tickval
		newDictionary._Tick = self.TickVal

		-- fire to the client and wait for a response to ensure they got their hitbox set up
		local readyToGo = false

		local tempWaitEvent : RBXScriptConnection

		tempWaitEvent = HitboxRemote.OnServerEvent:Connect(function(player, tickVal)
			if player ~= self.Client then return end
			if tickVal ~= self.TickVal then return end

			readyToGo = true

		end)

		assert(self.Client)

		local startWaitTime = workspace:GetServerTimeNow()

		HitboxRemote:FireClient(self.Client, "New", newDictionary)

		repeat task.wait() until readyToGo or workspace:GetServerTimeNow() - startWaitTime >= 1.5

		tempWaitEvent:Disconnect()

		if not readyToGo then return self, false end

	else
		self.Position = HitboxParams.InitialPosition or CFrameZero
		self.DebounceTime = HitboxParams.DebounceTime or 0
		self.VelocityPrediction = HitboxParams.VelocityPrediction

		if self.VelocityPrediction == nil then
			self.VelocityPrediction = true
		end

		self.DotProductRequirement = HitboxParams.DotProductRequirement

		self.DebugMode = HitboxParams.Debug or false

		if typeof(HitboxParams.SizeOrPart) == "Vector3" then

			self.SpatialOption = HitboxParams.SpatialOption or "InBox"

			assert(self.SpatialOption ~= "InRadius", "You can't use InRadius as the SpatialOption if a Vector3 is passed! Only InPart and InBox! (HitboxClass)")

			self.Mode =  "Part"
			self.Size = HitboxParams.SizeOrPart

			if self.SpatialOption == "InPart" then
				self:_GeneratePart()
			end

		elseif type(HitboxParams.SizeOrPart) == "number" then

			self.SpatialOption = HitboxParams.SpatialOption or "Magnitude"

			if self.SpatialOption == "InRadius" then
				self.Mode = "Part"
				self.Size = HitboxParams.SizeOrPart
			elseif self.SpatialOption == "InPart" then
				self.Mode = "Part"
				self.Size = Vector3.new(HitboxParams.SizeOrPart, HitboxParams.SizeOrPart, HitboxParams.SizeOrPart)
				self:_GeneratePart()
			elseif self.SpatialOption == "InBox" then
				self.Mode = "Part"
				self.Size = Vector3.new(HitboxParams.SizeOrPart, HitboxParams.SizeOrPart, HitboxParams.SizeOrPart)
			else
				self.Mode =  "Magnitude"
				self.Size = HitboxParams.SizeOrPart
			end

		else 
			self.Mode =  "Part"
			self.Size = HitboxParams.SizeOrPart.Size
			self.Part = HitboxParams.SizeOrPart:Clone()


			self.SpatialOption = "InPart"

			assert(self.Part, "No part provided?")

			assert(self.Part and self.Part:IsA("Part"))

			self.Part.Color = Color3.new(1,0,0)
			self.Part.Name = "Hitbox"..self.TickVal
		end	

		if self.DebugMode then
			self:SetDebug(true)
		end

	end

	table.insert(HitboxCache, self)

	return self, true

end

function Hitbox:ClearTaggedChars()
	if self.Client then
		HitboxRemote:FireClient(self.Client, "ClrTag", {_Tick = self.TickVal})
	else
		table.clear(self.TaggedChars)
	end

end

function Hitbox:Start()
	
	-- if the lifetime is greater than 0
	if self.Lifetime > 0 then
		-- check to see if there's a timer, if there is one, then start it
		if not self.Timer then
			-- make a new timer
			self.Timer = Timer.new(0.1, function()
				self.Lifetime -= 0.1
				if self.Lifetime <= 0 then
					self:Destroy()
				end
			end)
			
		else
			self.Timer:On()
		end
		
	end

	if self.Client then

		self.ClientConnection = HitboxRemote.OnServerEvent:Connect(function(player : Player, tickVal : number, HitTable)
			if HitTable == nil then return end
			if player ~= self.Client then return end
			if tickVal ~= self.TickVal then return end	
			if type(HitTable) ~= "table" then return end
			
			if self.LookingFor == "Humanoid" then
				-- remove all HitTable that isn't a model, isn't a descendant of the alive folder, or doesn't have a humanoid, or is nil entirely
				for i = #HitTable, 1, -1 do
					if (not HitTable[i]) or (typeof(HitTable[i]) ~= "Instance") or (not HitTable[i]:IsDescendantOf(aliveFolder)) or (not HitTable[i]:FindFirstChildOfClass("Humanoid")) or (not HitTable[i]:IsA("Model")) then
						table.remove(HitTable, i)
					end

					-- if everything else is valid, double check to make sure the model passed in is not in the hitbox's blacklist
					if self.Blacklist then
						if table.find(self.Blacklist, HitTable[i]) then
							table.remove(HitTable, i)
						end
					end

				end

				-- if after everything is said and done there's nothing left, don't fire the signal
				if #HitTable <= 0 then return end

				self.HitSomeone:Fire(HitTable)
			elseif self.LookingFor == "Object" then
				for i = #HitTable, 1, -1 do
					if (not HitTable[i]) or (typeof(HitTable[i]) ~= "Instance") or (not HitTable[i]:IsA("BasePart")) then
						table.remove(HitTable, i)
						continue
					end

					-- if everything else is valid, double check to make sure the model passed in is not in the hitbox's blacklist
					if self.Blacklist then
						for _, blacklisted in pairs(self.Blacklist) do
							if HitTable[i] == blacklisted or HitTable[i]:IsDescendantOf(blacklisted) then
								table.remove(HitTable, i)
							end
						end
					end

				end
				
				-- if after everything is said and done there's nothing left, don't fire the signal
				if #HitTable <= 0 then return end
				
				self.HitObject:Fire(HitTable)
			end
			
		end)

		HitboxRemote:FireClient(self.Client, "Start", {_Tick = self.TickVal})

	elseif self.Mode == "Magnitude" then

		assert(typeof(self.Size) == "number", "Magnitude hitbox wasn't given a number! Type given: "..typeof(self.Size))

		if self.Part and self.DebugMode then

			self.Part.Parent = projectileFolder
		end

		self.RunServiceConnection = RunService.Heartbeat:Connect(function(DT)

			if self.PartWeld then
				self:SetPosition(self.PartWeld.CFrame * (self.PartWeldOffset or CFrameZero))
			end

			-- go through the alive folder
			for i, Character : Instance in pairs(aliveFolder:GetChildren()) do

				-- check to see if it's a model with a primary part that also has a humanoid
				if Character:IsA("Model") and Character.PrimaryPart ~= nil and Character:FindFirstChildOfClass("Humanoid") then
					local magnitude = (self.Position.Position - Character.PrimaryPart.Position).Magnitude

					-- if they're greater than the distance of the hitbox, skip them
					if magnitude > self.Size then continue end

					-- if they're in the blacklist, skip them
					if self.Blacklist then
						if table.find(self.Blacklist, Character) then
							continue
						end
					end

					-- check the dot product if one is given
					if self.DotProductRequirement then
						local VectorToCompare = (Character.PrimaryPart.CFrame.Position - self.DotProductRequirement.PartForVector.CFrame.Position).Unit

						local VectorOfUser : Vector3

						-- changed to a long if statement block cause strict mode was throwing a hissy fit
						-- "attempting a dynamic property access on type 'CFrame' is unsafe and may cause exceptions at runtime"

						if self.DotProductRequirement.VectorType then
							if self.DotProductRequirement.VectorType == "LookVector" then
								VectorOfUser = self.DotProductRequirement.PartForVector.CFrame.LookVector
							elseif self.DotProductRequirement.VectorType == "UpVector" then
								VectorOfUser = self.DotProductRequirement.PartForVector.CFrame.UpVector
							elseif self.DotProductRequirement.VectorType == "RightVector" then
								VectorOfUser = self.DotProductRequirement.PartForVector.CFrame.RightVector
							end
						else
							VectorOfUser = self.DotProductRequirement.PartForVector.CFrame.LookVector
						end

						if self.DotProductRequirement.Negative then
							VectorOfUser *= -1
						end

						if VectorToCompare:Dot(VectorOfUser) < self.DotProductRequirement.DotProduct then
							continue
						end

					end

					-- if they've already been tagged, skip them
					if self.TaggedChars[Character] then continue end

					if magnitude <= self.Size then
						table.insert(self.SendingChars, Character)
					end

				end

			end


			self:_SiftThroughSendingCharsAndFire()

		end)	
		
	else

		if (self.SpatialOption == "InPart") or (self.Part and self.DebugMode == true) then
			self.Part.Parent = projectileFolder
		end

		self.RunServiceConnection = RunService.Heartbeat:Connect(function(DT)

			if self.PartWeld then
				self:SetPosition(self.PartWeld.CFrame * (self.PartWeldOffset or CFrameZero))
			end

			local results

			if self.SpatialOption == "InBox" then
				if self.LookingFor == "Humanoid" then
					results = workspace:GetPartBoundsInBox(self.Position, self.Size, overlapParamsHumanoid)
				else
					results = workspace:GetPartBoundsInBox(self.Position, self.Size, overlapParamsObject)
				end
			elseif self.SpatialOption == "InRadius" then
				if self.LookingFor == "Humanoid" then
					results = workspace:GetPartBoundsInRadius(self.Position.Position, self.Size, overlapParamsHumanoid)
				else
					results = workspace:GetPartBoundsInRadius(self.Position.Position, self.Size, overlapParamsObject)
				end
			else
				if self.LookingFor == "Humanoid" then
					results = workspace:GetPartsInPart(self.Part, overlapParamsHumanoid)
				else
					results = workspace:GetPartsInPart(self.Part, overlapParamsObject)
				end
			end

			for i, Part : BasePart in pairs(results) do

				if not Part.Parent then continue end
				
				if self.LookingFor == "Humanoid" then
					local Character = Part.Parent

					if not Character:IsA("Model") then continue end

					if Character.PrimaryPart == nil or not Character:FindFirstChildOfClass("Humanoid") then continue end

					if self.Blacklist then
						if table.find(self.Blacklist, Character) then
							continue
						end
					end


					if not table.find(self.SendingChars, Character) and not self.TaggedChars[Character] then	

						table.insert(self.SendingChars, Character)

					end
				else
					
					local BlacklistFound = false
					
					if self.Blacklist then
						-- go through the blacklist and flip the bool and break if the part is found
						-- in the blacklist
						for i = #self.Blacklist, 1, -1 do

							local checkingPart = self.Blacklist[i]
							
							if Part == checkingPart or Part:IsDescendantOf(checkingPart) then
								BlacklistFound = true
								break
							end
						end
					end
					

					if not table.find(self.SendingObjects, Part) and not self.TaggedObjects[Part] and not BlacklistFound then

						table.insert(self.SendingObjects, Part)

					end
				end
				
				
			end

			if self.LookingFor == "Humanoid" then
				self:_SiftThroughSendingCharsAndFire()
			elseif self.LookingFor == "Object" then
				self:_SiftThroughSendingObjectsAndFire()
			end
			

		end)
		
	end
	
end

function Hitbox:Stop()
	
	if self.Timer then
		self.Timer:Off()
	end
	
	if self.Client then
		if self.ClientConnection then
			self.ClientConnection:Disconnect()
			self.ClientConnection = nil
		end
		HitboxRemote:FireClient(self.Client, "Stop", {_Tick = self.TickVal})
	else
		if self.Part then
			self.Part:Remove()
		end

		if self.RunServiceConnection then
			self.RunServiceConnection:Disconnect()
			self.RunServiceConnection = nil
		end
	end

end

function Hitbox:SetPosition(newPosition : CFrame)

	if self.Client then
		HitboxRemote:FireClient(self.Client, "PosCh", {_Tick = self.TickVal, Position = newPosition})
	end

	local constant

	if velocityConstant then
		constant = velocityConstant.Value or 6
	else
		constant = 6
	end

	if RunService:IsServer() and self.PartWeld and self.VelocityPrediction then
		local velocityVector =  newPosition:VectorToObjectSpace(self.PartWeld.AssemblyLinearVelocity) / constant
		newPosition = newPosition * CFrame.new(velocityVector)
	end


	self.Position = newPosition

	if self.Part then
		self.Part.CFrame = newPosition
	end
end

function Hitbox:WeldTo(PartToWeldTo : BasePart, OffsetCFrame : CFrame?)

	if self.Client then
		HitboxRemote:FireClient(self.Client, "Weld", {_Tick = self.TickVal, WeldTo = PartToWeldTo, Offset = OffsetCFrame})
	end

	self.PartWeld = PartToWeldTo
	self.PartWeldOffset = OffsetCFrame

end

function Hitbox:Unweld()
	if self.Client then
		HitboxRemote:FireClient(self.Client, "Unweld", {_Tick = self.TickVal})
	end

	self.PartWeld = nil
	self.PartWeldOffset = nil

end

function Hitbox:ChangeWeldOffset(OffsetCFrame : CFrame)

	if self.Client then
		HitboxRemote:FireClient(self.Client, "WeldOfs", {_Tick = self.TickVal, Offset = OffsetCFrame})
	end

	self.PartWeldOffset = OffsetCFrame
end

function Hitbox:SetVelocityPrediction(state : boolean)
	self.VelocityPrediction = state
end

function Hitbox:SetDebug(state : boolean)
	self.DebugMode = state

	if self.Client then
		HitboxRemote:FireClient(self.Client, "Dbg", {_Tick = self.TickVal, Debug = state})
		return
	end

	if self.DebugMode then
		if not self.Part then
			self:_GeneratePart()
			assert(self.Part, "Part wasn't generated after the GeneratePart method?")
			
			if self.RunServiceConnection then
				self.Part.Parent = projectileFolder
			end

		else
			self.Part.Transparency = 0.45

			if self.SpatialOption ~= "InPart" and self.RunServiceConnection then
				self.Part.Parent = projectileFolder
			end

		end
	else
		if self.Part then

			if self.SpatialOption ~= "InPart" then
				self.Part:Remove()
			end

			self.Part.Transparency = 1
		end
	end
end

function Hitbox.ClearHitboxesWithID(ID : number | string)
	if RunService:IsClient() then return end

	-- go through the cache and destroy any hitboxes with the ID provided
	for i = #HitboxCache, 1, -1 do

		local checkingHitbox = HitboxCache[i]

		if checkingHitbox.ID and checkingHitbox.ID == ID then
			pcall(function()
				checkingHitbox:Destroy()
			end)
		end
	end

end

function Hitbox.ClearClientHitboxes(client : Player)

	if RunService:IsClient() then return end

	-- go through the cache and destroy any hitboxes associated with the client
	for i = #HitboxCache, 1, -1 do

		local checkingHitbox = HitboxCache[i]

		if checkingHitbox.Client and checkingHitbox.Client == client then
			pcall(function()
				checkingHitbox:Destroy()
			end)
		end
	end

	-- make sure everything is cleared on the client
	HitboxRemote:FireClient(client, "Clr")
end

function Hitbox.GetHitboxCache()
	return HitboxCache
end

function Hitbox:_SiftThroughSendingObjectsAndFire()
	if #self.SendingObjects <= 0 then return end

	local shallowObjectTable = {}

	for i, Object in pairs(self.SendingObjects) do
		table.insert(shallowObjectTable, Object)

		self.TaggedObjects[Object] = true

		if self.DebounceTime > 0 then
			local newThread = task.delay(self.DebounceTime, function()

				self.TaggedObjects[Object] = nil

			end)

			table.insert(self.DelayThreads, newThread)

		end

	end


	if #shallowObjectTable > 0 then
		if RunService:IsClient() then
			HitboxRemote:FireServer(self.TickVal, shallowObjectTable)
		end

		self.HitObject:Fire(shallowObjectTable)
	end

	if self.SendingObjects then
		table.clear(self.SendingObjects)
	end
end

function Hitbox:_SiftThroughSendingCharsAndFire()
	
	if #self.SendingChars <= 0 then return end
	
	local shallowObjectTable = {}
	
	for i, Object : Model in pairs(self.SendingChars) do
		table.insert(shallowObjectTable, Object)
		
		self.TaggedChars[Object] = true

		if self.DebounceTime > 0 then
			local newThread = task.delay(self.DebounceTime, function()
				
				self.TaggedChars[Object] = nil
				
			end)
			
			table.insert(self.DelayThreads, newThread)

		end

	end


	if #shallowObjectTable > 0 then
		if RunService:IsClient() then
			HitboxRemote:FireServer(self.TickVal, shallowObjectTable)
		end

		self.HitSomeone:Fire(shallowObjectTable)

	end

	if self.SendingChars then
		table.clear(self.SendingChars)
	end

end

function Hitbox:_GeneratePart()

	if self.Part then return end

	if typeof(self.Size) == "Vector3" then
		self.Mode =  "Part"
		self.Part = Instance.new("Part")


		assert(self.Part, "Part was nil!")
		assert(typeof(self.Size) == "Vector3", "self.Size wasn't a vector3 when making a part!") -- you shouldn't get here, but just in case

		self.Part.Color = Color3.new(1, 0, 0)

		if self.DebugMode then
			self.Part.Transparency = 0.45
		else
			self.Part.Transparency = 1
		end

		self.Part.Anchored = true
		self.Part.Massless = true
		self.Part.CanCollide = false

		self.Part.Size = self.Size
		self.Part.CFrame = self.Position

		self.Part.Name = "Hitbox"..self.TickVal
	elseif type(self.Size) == "number" then
		self.Part = Instance.new("Part")

		assert(self.Part and self.Part:IsA("Part"))
		assert(typeof(self.Size) == "number", "self.Size wasn't a number when making a sphere part!") -- you shouldn't get here, but just in case

		self.Part.Shape = Enum.PartType.Ball
		self.Part.Anchored = true
		self.Part.Massless = true
		self.Part.CanCollide = false
		self.Part.Size = Vector3.new(self.Size * 2, self.Size * 2, self.Size * 2)
		self.Part.Transparency = 0.45
		self.Part.Color = Color3.new(1, 0, 0)
		self.Part.CFrame = self.Position
		self.Part.Name = "Hitbox"..self.TickVal
	end
end

function Hitbox:Destroy()

	-- remove the hitbox from the cache
	table.remove(HitboxCache, table.find(HitboxCache, self))

	-- tell the client to destroy the hitbox on their end
	if self.Client then
		HitboxRemote:FireClient(self.Client, "Des", {_Tick = self.TickVal})
	end

	-- stop the hitbox
	if self.Client then
		if self.ClientConnection then
			self.ClientConnection:Disconnect()
			self.ClientConnection = nil
		end
	else
		if self.Part then
			self.Part:Remove()
		end

		if self.RunServiceConnection then
			self.RunServiceConnection:Disconnect()
			self.RunServiceConnection = nil
		end
	end

	-- disconnect all connections to the HitSomeone signal
	pcall(function()
		self.HitSomeone:Destroy()
	end)
	
	-- disconnect all connections to the HitObject signal
	pcall(function()
		self.HitObject:Destroy()
	end)
	
	-- if there's a timer, destroy it
	pcall(function()
		if self.Timer then
			self.Timer:Destroy()
		end
	end)

	-- cancel all debounce threads
	if self.DelayThreads then
		for i, thread in pairs(self.DelayThreads) do
			pcall(function()
				task.cancel(thread)
			end)
		end
	end
	
	-- if there's a part, destroy it
	if self.Part then
		self.Part:Destroy()
	end

	-- clear out all tables
	pcall(function()
		table.clear(self.TaggedChars)
	end)

	pcall(function()
		table.clear(self.SendingChars)
	end)

	pcall(function()
		table.clear(self)
	end)

end

return Hitbox
---

--- ReplicatedStorage.Modules.HitboxClass.HitboxClassLocal (LocalScript) ---
--!strict

local require = require
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local signal = require(script:WaitForChild("Signal"))
local HitboxClassRemote = ReplicatedStorage:WaitForChild("HitboxClassRemote") :: RemoteEvent
local HitboxClass = require(script["HitboxClass Module"].Value)

local currentHitboxes = {}

HitboxClassRemote.OnClientEvent:Connect(function(mode, packet)
	
	if mode == "Clr" then
		for i, Hitbox in pairs(currentHitboxes) do
			Hitbox:Destroy()
			currentHitboxes[i] = nil
		end
		return
	end
	
	if mode ~= "New" and not currentHitboxes[packet._Tick] then warn("No hitbox found on the client for tick value sent. Don't change the tick value manually, change the ID instead. (HitboxClass)") return end
	
	if mode == "New" then
		local newHitbox = HitboxClass.new(packet)
		currentHitboxes[packet._Tick] = newHitbox
		HitboxClassRemote:FireServer(packet._Tick)
	end
	
	if mode == "Start" then
		currentHitboxes[packet._Tick]:Start()
	end
	
	if mode == "Stop" then
		currentHitboxes[packet._Tick]:Stop()
	end
	
	if mode == "ClrTag" then
		currentHitboxes[packet._Tick]:ClearTaggedChars()
	end
	
	if mode == "Weld" then
		currentHitboxes[packet._Tick]:WeldTo(packet.WeldTo, packet.Offset)
	end
	
	if mode == "WeldOfs" then
		currentHitboxes[packet._Tick]:ChangeWeldOffset(packet.Offset)
	end
	
	if mode == "Unweld" then
		currentHitboxes[packet._Tick]:Unweld()
	end
	
	if mode == "PosCh" then
		currentHitboxes[packet._Tick]:SetPosition(packet.Position)
	end
	
	if mode == "Dbg" then
		currentHitboxes[packet._Tick]:SetDebug(packet.Debug)
	end
	
	if mode == "Des" then
		currentHitboxes[packet._Tick]:Destroy()
		currentHitboxes[packet._Tick] = nil
	end
	
end)
---

--- ReplicatedStorage.Modules.HitboxClass.Types (ModuleScript) ---
local Types = {}

-- temp signal to make the types
local signal = require(script.Parent.Signal)
local timer = require(script.Parent.Timer)
local newSignal = signal.new()

export type SignalType<T...> = typeof(newSignal)

export type SignalConnection = typeof(newSignal:Connect())

export type DotProductRequirement = {
	DotProduct : number,
	PartForVector : BasePart,
	VectorType : ("LookVector" | "UpVector" | "RightVector")?,
	Negative : boolean?
}

export type HitboxParams = {
	SizeOrPart : Vector3 | number | BasePart,
	SpatialOption : ("InBox" | "InRadius" | "InPart")?,
	InitialPosition : CFrame?,
	Blacklist : {Model}?,
	DebounceTime : number?,
	DotProductRequirement : DotProductRequirement?,
	UseClient : Player?,
	ID : (string | number)?,
	VelocityPrediction : boolean?,
	Debug : boolean?,
	Debris : number?,
	LookingFor : ("Humanoid" | "Object")?,
	
	-- Private fields
	_Tick : number?
}

export type Hitbox = {

	-- Fields

	Size : Vector3 | number,
	Mode : "Magnitude" | "Part",
	SpatialOption : "InBox" | "InRadius" | "InPart" | "Magnitude",
	LookingFor : "Humanoid" | "Object",
	DebounceTime : number,
	Part : BasePart?,
	Position : CFrame,
	DotProductRequirement : DotProductRequirement?,
	TaggedChars : {[Model] : boolean},
	TaggedObjects : {[BasePart] : boolean},
	ID : (string | number)?,
	TickVal : number,
	Blacklist : {}?,
	SendingChars : {Model},
	SendingObjects : {BasePart},
	DelayThreads : {thread},
	HitSomeone : signal.Signal<{Model}>,
	HitObject : signal.Signal<{BasePart}>,
	RunServiceConnection : RBXScriptConnection?,
	ClientConnection : RBXScriptConnection?,
	PartWeld : BasePart?,
	PartWeldOffset : CFrame?,
	Client : Player?,
	VelocityPrediction : boolean?,
	DebugMode : boolean,
	Lifetime : number,
	

	-- Methods

	new : (HitboxParams) -> (Hitbox, boolean),
	ClearClientHitboxes : (Client : Player) -> (),
	ClearHitboxesWithID : (ID : string | number) -> (),
	GetHitboxCache : () -> {Hitbox},
	ClearTaggedChars : (self : Hitbox) -> (),
	Start : (self : Hitbox) -> (),
	Stop : (self : Hitbox) -> (),
	SetPosition : (self : Hitbox, Position : CFrame) -> (),
	Destroy : (self : Hitbox) -> (),
	WeldTo : (self : Hitbox , PartToWeldTo : BasePart, OffsetCFrame : CFrame?) -> (),
	Unweld : (self : Hitbox) -> (),
	ChangeWeldOffset : (self : Hitbox, OffsetCFrame : CFrame) -> (),
	SetVelocityPrediction : (self : Hitbox, state : boolean) -> (),
	SetDebug : (self : Hitbox, state : boolean) -> (),

	-- Private Methods (Don't touch unless you know what you're doing!)

	_SiftThroughSendingCharsAndFire : (self : Hitbox) -> (),
	_SiftThroughSendingObjectsAndFire : (self : Hitbox) -> (),
	_GeneratePart : (self : Hitbox) -> (),
	
	-- Private Fields (Don't touch unless you know what you're doing!)
	Timer : timer.IntervalTimer?,
	
}

return Types

---

--- ReplicatedStorage.Modules.HitboxClass.Signal (ModuleScript) ---
-- -----------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- License:                                                                   --
--   Licensed under the MIT license.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--   sleitnick - August 3rd, 2021 - Modified for Knit.                        --
-- -----------------------------------------------------------------------------

-- Signal types
export type Connection = {
	Disconnect: (self: Connection) -> (),
	Destroy: (self: Connection) -> (),
	Connected: boolean,
}

export type Signal<T...> = {
	Fire: (self: Signal<T...>, T...) -> (),
	FireDeferred: (self: Signal<T...>, T...) -> (),
	Connect: (self: Signal<T...>, fn: (T...) -> ()) -> Connection,
	Once: (self: Signal<T...>, fn: (T...) -> ()) -> Connection,
	DisconnectAll: (self: Signal<T...>) -> (),
	GetConnections: (self: Signal<T...>) -> { Connection },
	Destroy: (self: Signal<T...>) -> (),
	Wait: (self: Signal<T...>) -> T...,
}

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread(...)
	acquireRunnerThreadAndCallEventHandler(...)
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

--[=[
	@within Signal
	@interface SignalConnection
	.Connected boolean
	.Disconnect (SignalConnection) -> ()

	Represents a connection to a signal.
	```lua
	local connection = signal:Connect(function() end)
	print(connection.Connected) --> true
	connection:Disconnect()
	print(connection.Connected) --> false
	```
]=]

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection:Disconnect()
	if not self.Connected then
		return
	end
	self.Connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end

Connection.Destroy = Connection.Disconnect

-- Make Connection strict
setmetatable(Connection, {
	__index = function(_tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

--[=[
	@within Signal
	@type ConnectionFn (...any) -> ()

	A function connected to a signal.
]=]

--[=[
	@class Signal

	A Signal is a data structure that allows events to be dispatched
	and observed.

	This implementation is a direct copy of the de facto standard, [GoodSignal](https://devforum.roblox.com/t/lua-signal-class-comparison-optimal-goodsignal-class/1387063),
	with some added methods and typings.

	For example:
	```lua
	local signal = Signal.new()

	-- Subscribe to a signal:
	signal:Connect(function(msg)
		print("Got message:", msg)
	end)

	-- Dispatch an event:
	signal:Fire("Hello world!")
	```
]=]
local Signal = {}
Signal.__index = Signal

--[=[
	Constructs a new Signal

	@return Signal
]=]
function Signal.new<T...>(): Signal<T...>
	local self = setmetatable({
		_handlerListHead = false,
		_proxyHandler = nil,
		_yieldedThreads = nil,
	}, Signal)

	return self
end

--[=[
	Constructs a new Signal that wraps around an RBXScriptSignal.

	@param rbxScriptSignal RBXScriptSignal -- Existing RBXScriptSignal to wrap
	@return Signal

	For example:
	```lua
	local signal = Signal.Wrap(workspace.ChildAdded)
	signal:Connect(function(part) print(part.Name .. " added") end)
	Instance.new("Part").Parent = workspace
	```
]=]
function Signal.Wrap<T...>(rbxScriptSignal: RBXScriptSignal): Signal<T...>
	assert(
		typeof(rbxScriptSignal) == "RBXScriptSignal",
		"Argument #1 to Signal.Wrap must be a RBXScriptSignal; got " .. typeof(rbxScriptSignal)
	)

	local signal = Signal.new()
	signal._proxyHandler = rbxScriptSignal:Connect(function(...)
		signal:Fire(...)
	end)

	return signal
end

--[=[
	Checks if the given object is a Signal.

	@param obj any -- Object to check
	@return boolean -- `true` if the object is a Signal.
]=]
function Signal.Is(obj: any): boolean
	return type(obj) == "table" and getmetatable(obj) == Signal
end

--[=[
	@param fn ConnectionFn
	@return SignalConnection

	Connects a function to the signal, which will be called anytime the signal is fired.
	```lua
	signal:Connect(function(msg, num)
		print(msg, num)
	end)

	signal:Fire("Hello", 25)
	```
]=]
function Signal:Connect(fn)
	local connection = setmetatable({
		Connected = true,
		_signal = self,
		_fn = fn,
		_next = false,
	}, Connection)

	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end

	return connection
end

--[=[
	@deprecated v1.3.0 -- Use `Signal:Once` instead.
	@param fn ConnectionFn
	@return SignalConnection
]=]
function Signal:ConnectOnce(fn)
	return self:Once(fn)
end

--[=[
	@param fn ConnectionFn
	@return SignalConnection

	Connects a function to the signal, which will be called the next time the signal fires. Once
	the connection is triggered, it will disconnect itself.
	```lua
	signal:Once(function(msg, num)
		print(msg, num)
	end)

	signal:Fire("Hello", 25)
	signal:Fire("This message will not go through", 10)
	```
]=]
function Signal:Once(fn)
	local connection
	local done = false

	connection = self:Connect(function(...)
		if done then
			return
		end

		done = true
		connection:Disconnect()
		fn(...)
	end)

	return connection
end

function Signal:GetConnections()
	local items = {}

	local item = self._handlerListHead
	while item do
		table.insert(items, item)
		item = item._next
	end

	return items
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
--[=[
	Disconnects all connections from the signal.
	```lua
	signal:DisconnectAll()
	```
]=]
function Signal:DisconnectAll()
	local item = self._handlerListHead
	while item do
		item.Connected = false
		item = item._next
	end
	self._handlerListHead = false

	local yieldedThreads = rawget(self, "_yieldedThreads")
	if yieldedThreads then
		for thread in yieldedThreads do
			if coroutine.status(thread) == "suspended" then
				warn(debug.traceback(thread, "signal disconnected; yielded thread cancelled", 2))
				task.cancel(thread)
			end
		end
		table.clear(self._yieldedThreads)
	end
end

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
--[=[
	@param ... any

	Fire the signal, which will call all of the connected functions with the given arguments.
	```lua
	signal:Fire("Hello")

	-- Any number of arguments can be fired:
	signal:Fire("Hello", 32, {Test = "Test"}, true)
	```
]=]
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item.Connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

--[=[
	@param ... any

	Same as `Fire`, but uses `task.defer` internally & doesn't take advantage of thread reuse.
	```lua
	signal:FireDeferred("Hello")
	```
]=]
function Signal:FireDeferred(...)
	local item = self._handlerListHead
	while item do
		local conn = item
		task.defer(function(...)
			if conn.Connected then
				conn._fn(...)
			end
		end, ...)
		item = item._next
	end
end

--[=[
	@return ... any
	@yields

	Yields the current thread until the signal is fired, and returns the arguments fired from the signal.
	Yielding the current thread is not always desirable. If the desire is to only capture the next event
	fired, using `Once` might be a better solution.
	```lua
	task.spawn(function()
		local msg, num = signal:Wait()
		print(msg, num) --> "Hello", 32
	end)
	signal:Fire("Hello", 32)
	```
]=]
function Signal:Wait()
	local yieldedThreads = rawget(self, "_yieldedThreads")
	if not yieldedThreads then
		yieldedThreads = {}
		rawset(self, "_yieldedThreads", yieldedThreads)
	end

	local thread = coroutine.running()
	yieldedThreads[thread] = true

	self:Once(function(...)
		yieldedThreads[thread] = nil
		task.spawn(thread, ...)
	end)

	return coroutine.yield()
end

--[=[
	Cleans up the signal.

	Technically, this is only necessary if the signal is created using
	`Signal.Wrap`. Connections should be properly GC'd once the signal
	is no longer referenced anywhere. However, it is still good practice
	to include ways to strictly clean up resources. Calling `Destroy`
	on a signal will also disconnect all connections immediately.
	```lua
	signal:Destroy()
	```
]=]
function Signal:Destroy()
	self:DisconnectAll()

	local proxyHandler = rawget(self, "_proxyHandler")
	if proxyHandler then
		proxyHandler:Disconnect()
	end
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(_tb, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

return table.freeze({
	new = Signal.new,
	Wrap = Signal.Wrap,
	Is = Signal.Is,
})

---

--- ReplicatedStorage.Modules.HitboxClass.Timer (ModuleScript) ---
--!strict

local RunService = game:GetService("RunService")
local Signal = require(script.Parent.Signal)

export type IntervalTimer = {
	
	-- fields
	TimeOut : number,
	TimeElapsed : number,
	Callback : (number) -> (),
	HeartbeatConnection :  RBXScriptConnection,
	Elapsed : Signal.Signal<>,
	
	-- methods
	new : (timeOut : number, callback : () -> ()) -> IntervalTimer,
	On : (self : IntervalTimer) -> (),
	Off : (self : IntervalTimer) -> (),
	Destroy : (self : IntervalTimer) -> (),
	
	-- private methods
	_Interval : (self : IntervalTimer, deltaTime : number) -> (),
}

local Timer = {}

-- this timer is only reliable on 0.1 timeout threshold or above
function Timer.new(TimeOut : number, Callback : () -> ())
	local self = (setmetatable({}, {__index = Timer}) :: unknown) :: IntervalTimer
	
	-- set up fields
	self.TimeOut = TimeOut
	self.Callback = Callback
	self.TimeElapsed = 0
	self.Elapsed = Signal.new()
	
	self.Elapsed:Connect(Callback)
	
	-- set up connection to heartbeat
	self.HeartbeatConnection = RunService.Heartbeat:Connect(function(DT)
		self:_Interval(DT)
	end)
	
	return self
end

function Timer._Interval(self : IntervalTimer, deltaTime : number)

	-- add the elapsed time to the timer
	self.TimeElapsed += deltaTime

	-- if there's something crazy going on and this hasn't been called in over 10 times the timeout threshold
	-- we want to reset the time elapsed field to prevent the timer from running the callback over 10 times in a row
	if self.TimeElapsed >= self.TimeOut * 10 then
		-- get the amount of timeouts skipped and then multiply by the timeout threshold
		-- subtract this from time elapsed
		self.TimeElapsed -= math.floor(self.TimeElapsed / self.TimeOut) * self.TimeOut

		return
	end

	-- if the elapsed time meets the threshold for the timeout
	-- then get rid of the elapsed time and run the callback
	if self.TimeElapsed >= self.TimeOut then
		self.TimeElapsed -= self.TimeOut
		self.Elapsed:Fire()
	end

end

function Timer.On(self : IntervalTimer)
	-- if connection exists and is connected, don't do anything
	if self.HeartbeatConnection and self.HeartbeatConnection.Connected then return end
	
	-- make a new connection to heartbeat
	self.HeartbeatConnection = RunService.Heartbeat:Connect(function(DT)
		self:_Interval(DT)
	end)
	
end

function Timer.Off(self : IntervalTimer)
	-- if there's not connection, don't do anything
	if not self.HeartbeatConnection then return end

	-- disconnect the connection
	self.HeartbeatConnection:Disconnect()
end

function Timer.Destroy(self : IntervalTimer)
	
	-- disconnect the connection
	self:Off()
	
	-- destroy the signal
	self.Elapsed:Destroy()
	
	-- clear self
	table.clear(self)
	
end

return Timer
---

--- ReplicatedStorage.Modules.Maid (ModuleScript) ---
--!strict
-- A class for managing the cleanup of events and other objects.

local Maid = {}
Maid.__index = Maid

function Maid.new()
	local self = setmetatable({}, Maid)
	self._tasks = {}
	return self
end

function Maid:GiveTask(task: RBXScriptConnection | Instance | (() -> ()))
	if not task then
		return
	end

	local index = #self._tasks + 1
	self._tasks[index] = task
	return index
end

function Maid:DoCleaning()
	for _, task in ipairs(self._tasks) do
		if typeof(task) == "function" then
			task()
		elseif typeof(task) == "RBXScriptConnection" then
			task:Disconnect()
		elseif typeof(task) == "Instance" then
			task:Destroy()
		end
	end
	table.clear(self._tasks)
end

function Maid:Destroy()
	self:DoCleaning()
	table.clear(self)
end

return Maid
---

--- ReplicatedStorage.Modules.ItemConfigurations (ModuleScript) ---
--[[
	ItemConfigurations Module
	
	Description: Contains all data for purchasable items in the BlocksShop,
	including their type, price, stock chance, and appearance.
	
	Location: ReplicatedStorage/Modules
]]
--!strict

local ItemConfigurations = {
	-- == BLOCKS ==
	WoodenFence = {
		DisplayName = "Wooden Fence",
		Type = "Blocks",
		Price = 50,
		ImageId = "rbxassetid://129846047182862",
		ProductID = 3433103620,
		Unlimited = false,
		Chance = 60,
		StockAmount = {Min = 1, Max = 5},
		Health = 50,
	},

	Crate = {
		DisplayName = "Crate",
		Type = "Blocks",
		Price = 250,
		ImageId = "rbxassetid://120065601385140",
		ProductID = 3433103879,
		Unlimited = false,
		Chance = 47,
		StockAmount = {Min = 1, Max = 5},
		Health = 75,
	},

	Barrel = {
		DisplayName = "Barrel",
		Type = "Blocks",
		Price = 950,
		ImageId = "rbxassetid://85433095978867",
		ProductID = 3433104247,
		Unlimited = false,
		Chance = 45,
		StockAmount = {Min = 1, Max = 5},
		Health = 120,
	},

	Sandbag = {
		DisplayName = "Sandbag",
		Type = "Blocks",
		Price = 2200,
		ImageId = "rbxassetid://95530712312968",
		ProductID = 3433104602,
		Unlimited = false,
		Chance = 36,
		StockAmount = {Min = 1, Max = 5},
		Health = 155,
	},

	SteelFence = {
		DisplayName = "Steel Fence",
		Type = "Blocks",
		Price = 4500,
		ImageId = "rbxassetid://125202399347349",
		ProductID = 3433105403,
		Unlimited = false,
		Chance = 34,
		StockAmount = {Min = 1, Max = 5},
		Health = 250,
	},

	Titanium = {
		DisplayName = "Titanium",
		Type = "Blocks",
		Price = 9000,
		ImageId = "rbxassetid://112393753455351",
		ProductID = 3433551311,
		Unlimited = false,
		Chance = 27,
		StockAmount = {Min = 1, Max = 4},
		Health = 700,
	},
	
	Cobblestone = {
		DisplayName = "Cobblestone",
		Type = "Blocks",
		Price = 1200,
		ImageId = "rbxassetid://87565106525483",
		ProductID = 3451485533,
		Unlimited = false,
		Chance = 43,
		StockAmount = {Min = 1, Max = 5},
		Health = 100,
	},
	
	Diamond = {
		DisplayName = "Diamond",
		Type = "Blocks",
		Price = 25000,
		ImageId = "rbxassetid://90412412707609",
		ProductID = 3451485298,
		Unlimited = false,
		Purchasable = false,           
		ShopHidden  = true,            
		Chance = 24,
		StockAmount = {Min = 1, Max = 3},
		Health = 1600,
	},
	
	WoodenSpike = {
		DisplayName = "WoodenSpike",
		Type = "Blocks",
		Price = 3500,
		ImageId = "rbxassetid://132026303434953",
		ProductID = 3451486230,
		Unlimited = false,
		Chance = 45,
		StockAmount = {Min = 1, Max = 5},
		Health = 80,
	},
	
	MetalSpike = {
		DisplayName = "MetalSpike",
		Type = "Blocks",
		Price = 6000,
		ImageId = "rbxassetid://125231362028631",
		ProductID = 3451485825,
		Unlimited = false,
		Chance = 38,
		StockAmount = {Min = 1, Max = 4},
		Health = 250,
	},
	
	ToxicSpike = {
		DisplayName = "ToxicSpike",
		Type = "Blocks",
		Price = 30000,
		ImageId = "rbxassetid://115198885487974",
		ProductID = 3451486014,
		Unlimited = false,
		Purchasable = false,           
		ShopHidden  = true, 
		Chance = 24,
		StockAmount = {Min = 1, Max = 3},
		Health = 550,
	},
	
	
	
	
	
	



	-- == TURRETS ==
	RevolverGuard = {
		DisplayName = "Revolver Cowboy",
		Type = "Turrets",
		Price = 200,
		ImageId = "rbxassetid://101587176998545",
		ProductID = 3433094679,
		Unlimited = false,
		Chance = 60,
		StockAmount = {Min = 2, Max = 4},
		Damage = 40,
		Range = 18,
		FireRate = 1.5, -- shots per second
		Health = 100, -- ## ADDED ##
	},

	DualRevolverGuard = {
		DisplayName = "Akimbo Cowboy",
		Type = "Turrets",
		Price = 750,
		ImageId = "rbxassetid://90537702528376",
		ProductID = 3433095524,
		Unlimited = false,
		Chance = 54,
		StockAmount = {Min = 1, Max = 3},
		Damage = 52,
		Range = 20,
		FireRate = 1.7, -- shots per second
		Health = 150, -- ## ADDED ##
	},

	SubmachineGunGuard = {
		DisplayName = "Uzi Cowboy",
		Type = "Turrets",
		Price = 3000,
		ImageId = "rbxassetid://85967954170361",
		ProductID = 3434416170,
		Unlimited = false,
		Chance = 45,
		StockAmount = {Min = 1, Max = 4},
		Damage = 23,
		Range = 24,
		FireRate = 4, -- shots per second
		Health = 150, -- ## ADDED ##
	},

	RifleGuard = {
		DisplayName = "Rifle Cowboy",
		Type = "Turrets",
		Price = 20000,
		ImageId = "rbxassetid://97972248199343",
		ProductID = 3433095916,
		Unlimited = false,
		Chance = 42,
		StockAmount = {Min = 1, Max = 3},
		Damage = 52,
		Range = 32,
		FireRate = 2.4, -- shots per second
		Health = 200, -- ## ADDED ##
	},

	ShotgunGuard = {
		DisplayName = "Shotgun Cowboy",
		Type = "Turrets",
		Price = 60000,
		ImageId = "rbxassetid://120607492947002",
		ProductID = 3433096316,
		Unlimited = false,
		Chance = 36,
		StockAmount = {Min = 1, Max = 3},
		Damage = 12,
		Range = 25,
		FireRate = 0.6, -- shots per second
		Health = 250, -- ## ADDED ##
	},


	GatlingGuard = {
		DisplayName = "Heavy Gunner",
		Type = "Turrets",
		Price = 120000,
		ImageId = "rbxassetid://100612332867121",
		ProductID = 3433096925,
		Unlimited = false,
		Chance = 30,
		StockAmount = {Min = 1, Max = 2},
		Damage = 20,
		Range = 40,
		FireRate = 5, -- shots per second
		Health = 300, -- ## ADDED ##
	},
	
	MortarGuard = {
		DisplayName = "MortarGuard",
		Type = "Turrets",
		Purchasable = false,
		ShopHidden = true,
		Price = nil,
		ProductID = nil,
		ImageId = "rbxassetid://97959863510956",

		Health = 300,
		Range = 80,
		MinRange = 18,
		Reload = 3.4,
		ProjectileSpeed = 90,
		SplashRadius = 15,
		Damage = 75,
		Spread = 1.5,
	},

}


-- Multipliers per tier (M1..M4)
local DAMAGE_MULT = { 1.10, 1.2, 1.3, 1.4 }
local HEALTH_MULT = { 1.10, 1.2, 1.3, 1.4 }

local MUTATION_IMAGES = {
	RevolverGuard = {
		[1] = "rbxassetid://132739787429109",
		[2] = "rbxassetid://128257399819685",
		[3] = "rbxassetid://72956303264604",
		[4] = "rbxassetid://97526334862988",
	},
	DualRevolverGuard = {
		[1] = "rbxassetid://85841518982837",
		[2] = "rbxassetid://119178152048750",
		[3] = "rbxassetid://76605895704232",
		[4] = "rbxassetid://110654873125512",
	},
	SubmachineGunGuard = {
		[1] = "rbxassetid://112682836269230",
		[2] = "rbxassetid://117726000125383",
		[3] = "rbxassetid://91758128710538",
		[4] = "rbxassetid://126017085127710",
	},
	RifleGuard = {
		[1] = "rbxassetid://116993191702178",
		[2] = "rbxassetid://132651447738530",
		[3] = "rbxassetid://111461787411888",
		[4] = "rbxassetid://74644215753266",
	},
	ShotgunGuard = {
		[1] = "rbxassetid://81501793595409",
		[2] = "rbxassetid://84050774573694",
		[3] = "rbxassetid://124834736686053",
		[4] = "rbxassetid://79931546514777",
	},
	GatlingGuard = {
		[1] = "rbxassetid://79150585476282",
		[2] = "rbxassetid://140395535147598",
		[3] = "rbxassetid://133302387592107",
		[4] = "rbxassetid://127328237788388",
	},
}


local function makeMutation(baseId: string, tier: number)
	local base = ItemConfigurations[baseId]
	if not base then
		warn("[ItemConfigurations] Missing base for mutation: ", baseId)
		return nil
	end

	local clone = table.clone(base)
	clone.DisplayName = (base.DisplayName or baseId)..("L%d"):format(tier)
	clone.Damage = math.floor((base.Damage or 0) * (DAMAGE_MULT[tier] or 1))
	clone.Health = math.floor((base.Health or 0) * (HEALTH_MULT[tier] or 1))
	clone.Purchasable = false   
	clone.ShopHidden  = true    
	clone.IsMutation  = true
	clone.BaseId      = baseId
	clone.Tier        = tier
	clone.ProductID   = nil     
	clone.Chance      = nil
	clone.StockAmount = nil
	clone.Unlimited   = nil

	local customImage = MUTATION_IMAGES[baseId] and MUTATION_IMAGES[baseId][tier]
	clone.ImageId = customImage or base.ImageId

	return clone
end


for _, baseId in ipairs({
	"RevolverGuard",
	"DualRevolverGuard",
	"SubmachineGunGuard",
	"RifleGuard",
	"ShotgunGuard",
	"GatlingGuard",
	}) do
	for tier = 1, 4 do
		local mid = ("%s_M%d"):format(baseId, tier)
		ItemConfigurations[mid] = makeMutation(baseId, tier)
	end
end

return ItemConfigurations

---

--- ReplicatedStorage.Modules.PlacementHandler (ModuleScript) ---
--!strict
-- Client placement handler with screen-anchored mobile HUD (âœ“ place, â†» rotate).
-- Desktop: click to place / R to rotate (unchanged).
-- Mobile: your Templates/MobileUi lives in PlayerGui and follows the ghost; we don't resize it.

--// Services
local UserInputService     = game:GetService("UserInputService")
local RunService           = game:GetService("RunService")
local ReplicatedStorage    = game:GetService("ReplicatedStorage")
local Workspace            = game:GetService("Workspace")
local CollectionService    = game:GetService("CollectionService")
local HttpService          = game:GetService("HttpService")
local ContextActionService = game:GetService("ContextActionService")
local Players              = game:GetService("Players")

local player    = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local mouse     = player:GetMouse()

--// Modules
local ItemConfigurations  = require(script.Parent:WaitForChild("ItemConfigurations"))
local NotificationManager = require(script.Parent:WaitForChild("NotificationManager"))
local FrameManager        = require(script.Parent:WaitForChild("FrameManager"))

--// Net
local EventsFolder     = ReplicatedStorage:WaitForChild("Events")
local FunctionsFolder  = ReplicatedStorage:WaitForChild("Functions")

local PlaceItemEvent        = EventsFolder:WaitForChild("PlaceItemEvent")
local RemoveItemEvent       = EventsFolder:WaitForChild("RemoveItemEvent")
local BlockInventoryUpdated = EventsFolder:WaitForChild("BlockInventoryUpdated")
local ItemPlacedFX          = EventsFolder:WaitForChild("ItemPlacedFX")
local ItemRemovedFX         = EventsFolder:WaitForChild("ItemRemovedFX")
local PlacementDenied       = EventsFolder:WaitForChild("PlacementDenied")
local GetBlockInventory     = FunctionsFolder:WaitForChild("GetBlockInventory")

--// Assets
local SoundsFolder = ReplicatedStorage:WaitForChild("Sounds")
local PlaceSound   = SoundsFolder:WaitForChild("PlaceSound")
local DeleteSound  = SoundsFolder:WaitForChild("DeleteSound")

local BLOCKS_MODELS  = ReplicatedStorage:WaitForChild("Blocks")
local TURRETS_MODELS = ReplicatedStorage:FindFirstChild("Turrets")

-- ====== CONFIG ======
local GRID_SIZE               = 4
local ROTATION_INCREMENT      = 90
local GHOST_ITEM_TRANSPARENCY = 0.7
local DELETE_HIGHLIGHT_TRANSPARENCY = 0.3
local HIDDEN_POSITION         = CFrame.new(0, -1000, 0)
local VALID_COLOR             = Color3.fromRGB(0, 255, 0)
local INVALID_COLOR           = Color3.fromRGB(255, 0, 0)
local GHOST_ITEM_TAG          = "ClientGhostItem"
local EPS                     = 0.05
local MAX_HEIGHT              = 4 -- must match server

-- Screen HUD settings (we DO NOT resize your UI)
local HUD_STUDS_OFFSET_Y = 6
local HUD_TEMPLATE_PATH = { "Templates", "MobileUi" } -- ReplicatedStorage/Templates/MobileUi

local function getTemplate(): Instance?
	local obj: Instance? = ReplicatedStorage
	for _, name in ipairs(HUD_TEMPLATE_PATH) do
		obj = obj and obj:FindFirstChild(name)
	end
	return obj
end
local HUD_TEMPLATE: Instance? = getTemplate() -- Frame with ConfirmButton & RotateButton

-- ====== State ======
local PlacementHandler = {}
local inventoryState = Instance.new("StringValue")
PlacementHandler.InventoryState = inventoryState

PlacementHandler.State = {
	isActive                      = false,
	isDeleteMode                  = false,
	ghostModel                    = nil :: Model?,
	currentItemId                 = nil :: string?,
	currentRotation               = 0,
	canPlace                      = false,
	playerPlot                    = nil :: Model?,
	highlightedItem               = nil :: { Model: Model, OriginalProperties: {[BasePart]: { Color: Color3, Transparency: number }} }?,
	currentInventory              = {} :: {[string]: number},
	originalRangePartTransparency = nil :: number?,
	selectionBox                  = nil :: SelectionBox?,
	highlightColor                = nil :: Color3?,
}

function PlacementHandler:GetInventory()
	return self.State.currentInventory
end

-- ====== Screen-anchored HUD (follows ghost)
local screenHud: ScreenGui?
local hudRoot: Frame?
local hudConns: { RBXScriptConnection } = {}
local followConn: RBXScriptConnection?

-- ====== Helpers ======
local function findMyPlot(): Model?
	for _, plot in ipairs(Workspace:WaitForChild("Plots"):GetChildren()) do
		if plot:IsA("Model") and plot:GetAttribute("OwnerId") == player.UserId then
			return plot
		end
	end
	return nil
end

local function getPlacementBox(model: Model): BasePart?
	local pb = model:FindFirstChild("PlacementBox")
	if pb and pb:IsA("BasePart") then
		return pb
	end
	return nil
end

local function isBlock(itemId: string): boolean
	local cfg = ItemConfigurations[itemId]
	return (cfg and cfg.Type == "Blocks") == true
end

local function isTurret(itemId: string): boolean
	local cfg = ItemConfigurations[itemId]
	return (cfg and cfg.Type == "Turrets") == true
end

local function unbindLegacyReload()
	for _, name in ipairs({ "Reload", "GunReload", "Gun_Reload", "ReloadAction" }) do
		ContextActionService:UnbindAction(name)
	end
end

local function isTypingInTextBox(): boolean
	return UserInputService:GetFocusedTextBox() ~= nil
end

local function applyGhostRotation(ghost: Model, deg: number)
	if not (ghost and ghost.PrimaryPart) then return end
	local pp = ghost.PrimaryPart
	local pos = pp.CFrame.Position
	local yAngle = math.rad(deg)
	local newCF = CFrame.new(pos) * CFrame.Angles(0, yAngle, 0)
	ghost:PivotTo(newCF)
end

local function getFootprintXZ(pb: BasePart, rotationDeg: number): (number, number)
	local rx = pb.Size.X
	local rz = pb.Size.Z
	local rot = ((rotationDeg % 360) + 360) % 360
	if rot == 90 or rot == 270 then
		return rz, rx
	end
	return rx, rz
end

-- ====== Screen HUD build/destroy ======
local function disconnectHud()
	for _, c in ipairs(hudConns) do
		pcall(function() c:Disconnect() end)
	end
	table.clear(hudConns)
	if followConn then
		pcall(function() followConn:Disconnect() end)
		followConn = nil
	end
end

local function destroyHud()
	disconnectHud()
	if screenHud then
		screenHud:Destroy()
		screenHud = nil
		hudRoot = nil
	end
end

local function buildScreenHud(adorneePart: BasePart)
	destroyHud()
	if not UserInputService.TouchEnabled then return end

	screenHud = Instance.new("ScreenGui")
	screenHud.Name = "PlacementScreenHUD"
	screenHud.ResetOnSpawn = false
	screenHud.IgnoreGuiInset = false
	screenHud.Parent = playerGui

	assert(HUD_TEMPLATE and HUD_TEMPLATE:IsA("Frame"), "[PlacementHandler] Templates/MobileUi not found or not a Frame")
	hudRoot = (HUD_TEMPLATE :: Frame):Clone()
	hudRoot.Name = "MobileUi"
	hudRoot.AnchorPoint = Vector2.new(0.5, 0.5) -- center
	hudRoot.Parent = screenHud

	local confirmBtn = hudRoot:FindFirstChild("ConfirmButton", true) :: GuiButton?
	local rotateBtn  = hudRoot:FindFirstChild("RotateButton",  true) :: GuiButton?

	if confirmBtn then
		table.insert(hudConns, confirmBtn.Activated:Connect(function()
			local S = PlacementHandler.State
			if S.isActive and not S.isDeleteMode then
				if S.canPlace and S.ghostModel and S.currentItemId then
					PlaceItemEvent:FireServer(S.currentItemId, S.ghostModel:GetPrimaryPartCFrame(), S.playerPlot)
				else
					NotificationManager.show("Not enough space!", "Error")
				end
			end
		end))
	end

	if rotateBtn then
		table.insert(hudConns, rotateBtn.Activated:Connect(function()
			local S = PlacementHandler.State
			if S.isActive and not S.isDeleteMode then
				S.currentRotation = (S.currentRotation + ROTATION_INCREMENT) % 360
				if S.ghostModel then
					applyGhostRotation(S.ghostModel, S.currentRotation)
					task.defer(function() PlacementHandler:_UpdatePlacementPreview() end)
				end
			end
		end))
	end

	-- Follow the ghost in screen space
	local cam = Workspace.CurrentCamera
	followConn = RunService.RenderStepped:Connect(function()
		if not (cam and hudRoot and adorneePart and adorneePart.Parent) then return end
		local worldPos = adorneePart.Position + Vector3.new(0, HUD_STUDS_OFFSET_Y, 0)
		local v3, onScreen = cam:WorldToViewportPoint(worldPos)
		hudRoot.Visible = onScreen and v3.Z > 0
		if not hudRoot.Visible then return end
		hudRoot.Position = UDim2.fromOffset(v3.X, v3.Y)
	end)
end

-- ====== Core actions ======
local function _PlaceCurrentItem()
	local S = PlacementHandler.State
	if not S.isActive or S.isDeleteMode then return end
	if not S.canPlace then
		NotificationManager.show("Not enough space!", "Error")
		return
	end

	local currentItemId = S.currentItemId
	if currentItemId then
		local ownedCount = S.currentInventory[currentItemId] or 0
		if ownedCount <= 0 then
			NotificationManager.show("Not enough stock!", "Error")
			FrameManager.open("Inventory")
			PlacementHandler:ExitAllModes()
			return
		end
	end

	if S.ghostModel and currentItemId then
		PlaceItemEvent:FireServer(currentItemId, S.ghostModel:GetPrimaryPartCFrame(), S.playerPlot)
	end
end

local function _deleteModel(model: Model?)
	if not model then return end
	RemoveItemEvent:FireServer(model)
end

local function _topPlacedModelUnderPart(part: BasePart?, plot: Model?): Model?
	if not (part and plot) then return nil end
	local a: Instance? = part
	while a and a.Parent ~= plot do
		a = a.Parent
	end
	if a and (a :: Instance):GetAttribute("IsPlacedItem") then
		return a :: Model
	end
	return nil
end

local function _deleteAtScreenPoint(pos: Vector2)
	local S = PlacementHandler.State
	if not S.playerPlot then return end
	local camera = Workspace.CurrentCamera
	if not camera then return end

	for _, gui in ipairs(playerGui:GetGuiObjectsAtPosition(pos.X, pos.Y)) do
		if gui:IsA("GuiButton") then
			return
		end
	end

	local ray = camera:ScreenPointToRay(pos.X, pos.Y)
	local rp = RaycastParams.new()
	rp.FilterType = Enum.RaycastFilterType.Whitelist
	rp.FilterDescendantsInstances = { S.playerPlot }

	local res = Workspace:Raycast(ray.Origin, ray.Direction * 1000, rp)
	if not res then return end

	local model = _topPlacedModelUnderPart(res.Instance, S.playerPlot)
	if model then
		_deleteModel(model)
	end
end

-- ====== Placement Preview (raycast, under-fill & stacking rules) ======
local function countBlocksInColumn(plot: Model, xz: Vector3, footprint: Vector3): (number, Model?, BasePart?, boolean, boolean)
	local blocksCount = 0
	local topModel: Model? = nil
	local topPB: BasePart? = nil
	local topIsBlock = false
	local topIsTurret = false
	local bestTopY = -math.huge

	for _, ch in ipairs(plot:GetChildren()) do
		if not CollectionService:HasTag(ch, "PlacedItem") then
			continue
		end
		local pb = getPlacementBox(ch)
		if not pb then
			continue
		end

		local dx = math.abs(pb.Position.X - xz.X)
		local dz = math.abs(pb.Position.Z - xz.Z)
		local fitsXZ = (dx <= math.max(pb.Size.X, footprint.X)/2 + EPS)
			and (dz <= math.max(pb.Size.Z, footprint.Z)/2 + EPS)

		if fitsXZ then
			local cfg = ItemConfigurations[ch.Name]
			if cfg and cfg.Type == "Blocks" then
				blocksCount += 1
			end
			local topY = pb.Position.Y + pb.Size.Y/2
			if topY > bestTopY then
				bestTopY = topY
				topModel = ch
				topPB = pb
				topIsBlock = (cfg and cfg.Type == "Blocks") == true
				topIsTurret = (cfg and cfg.Type == "Turrets") == true
			end
		end
	end

	return blocksCount, topModel, topPB, topIsBlock, topIsTurret
end

function PlacementHandler:_UpdatePlacementPreview()
	-- ignore when over UI buttons
	local guiObjects = playerGui:GetGuiObjectsAtPosition(mouse.X, mouse.Y)
	for _, object in ipairs(guiObjects) do
		if object:IsA("GuiButton") then
			return
		end
	end

	local S = self.State
	if not (S.ghostModel and S.ghostModel.PrimaryPart) then return end

	-- Ensure plot reference
	if not S.playerPlot then
		S.playerPlot = findMyPlot()
		if not S.playerPlot then return end
	elseif not S.playerPlot.Parent then
		S.playerPlot = nil
		return
	end

	local plotBase = S.playerPlot:FindFirstChild("Base")
	if not plotBase then return end

	local camera = Workspace.CurrentCamera
	if not camera then return end

	-- 1) Raycast to plot
	local rcParams = RaycastParams.new()
	rcParams.FilterType = Enum.RaycastFilterType.Whitelist
	rcParams.FilterDescendantsInstances = { S.playerPlot }

	local ray = camera:ScreenPointToRay(mouse.X, mouse.Y)
	local result = Workspace:Raycast(ray.Origin, ray.Direction * 1000, rcParams)

	local worldHitPos: Vector3
	if result then
		worldHitPos = result.Position
	else
		-- fallback: plane projection onto base
		local planeN = plotBase.CFrame.UpVector
		local denom = ray.Direction:Dot(planeN)
		if math.abs(denom) < 1e-4 then
			S.ghostModel:PivotTo(HIDDEN_POSITION)
			S.canPlace = false
			return
		end
		local t = (plotBase.Position - ray.Origin):Dot(planeN) / denom
		if t < 0 then
			S.ghostModel:PivotTo(HIDDEN_POSITION)
			S.canPlace = false
			return
		end
		worldHitPos = ray.Origin + ray.Direction * t
	end

	-- 2) Snap X/Z to grid (rotation-aware footprint)
	local plotLocal = plotBase.CFrame:ToObjectSpace(CFrame.new(worldHitPos))
	local halfPlotSize = plotBase.Size / 2

	local pb = getPlacementBox(S.ghostModel)
	if not pb then return end
	local boxX, boxZ = getFootprintXZ(pb, S.currentRotation)
	local boxSize = Vector3.new(boxX, pb.Size.Y, boxZ)

	local shiftedX = plotLocal.X + halfPlotSize.X
	local snappedCornerX = math.floor(shiftedX / GRID_SIZE) * GRID_SIZE
	local x = (snappedCornerX + boxSize.X / 2) - halfPlotSize.X

	local shiftedZ = plotLocal.Z + halfPlotSize.Z
	local snappedCornerZ = math.floor(shiftedZ / GRID_SIZE) * GRID_SIZE
	local z = (snappedCornerZ + boxSize.Z / 2) - halfPlotSize.Z

	-- Clamp inside plot
	local halfBoxSize = boxSize / 2
	x = math.clamp(x, -halfPlotSize.X + halfBoxSize.X, halfPlotSize.X - halfBoxSize.X)
	z = math.clamp(z, -halfPlotSize.Z + halfBoxSize.Z, halfPlotSize.Z - halfBoxSize.Z)

	-- 3) Choose support at/under aimed height (under-fill)
	local colCenterWorld = plotBase.CFrame * Vector3.new(x, 0, z)
	local aimY = worldHitPos.Y

	local chosenSupportTopY = plotBase.Position.Y + plotBase.Size.Y/2
	local chosenSupportModel: Model? = nil
	local chosenSupportIsTurret = false
	local bestTopY = -math.huge

	for _, ch in ipairs(S.playerPlot:GetChildren()) do
		if not CollectionService:HasTag(ch, "PlacedItem") then
			continue
		end
		local spb = ch:FindFirstChild("PlacementBox")
		if not (spb and spb:IsA("BasePart")) then
			continue
		end

		local dx = math.abs(spb.Position.X - colCenterWorld.X)
		local dz = math.abs(spb.Position.Z - colCenterWorld.Z)
		local fitsXZ = (dx <= math.max(spb.Size.X, boxSize.X)/2 + EPS)
			and (dz <= math.max(spb.Size.Z, boxSize.Z)/2 + EPS)
		if not fitsXZ then
			continue
		end

		local topY = spb.Position.Y + spb.Size.Y/2
		if topY <= (aimY + EPS) and topY > bestTopY then
			bestTopY = topY
			chosenSupportTopY = topY
			chosenSupportModel = ch
			local cfg = ItemConfigurations[ch.Name]
			chosenSupportIsTurret = (cfg and cfg.Type == "Turrets") == true
		end
	end

	-- 4) Set ghost on top of chosen support (base if none matched)
	local ghost = S.ghostModel
	local ghostHalfY = ghost.PrimaryPart.Size.Y/2
	local finalCF = CFrame.new(colCenterWorld.X, chosenSupportTopY + ghostHalfY, colCenterWorld.Z)
	finalCF *= CFrame.Angles(0, math.rad(S.currentRotation), 0)
	ghost:PivotTo(finalCF)

	-- 5) Client overlap probe (hint only)
	local isOverlapping = false
	local overlapParams = OverlapParams.new()
	overlapParams.FilterDescendantsInstances = { S.ghostModel }

	local parts = Workspace:GetPartsInPart(getPlacementBox(S.ghostModel) :: BasePart, overlapParams)
	for _, part in ipairs(parts) do
		local m = part:FindFirstAncestorOfClass("Model")
		if (m and m:GetAttribute("IsPlacedItem")) or part.Name == "PlotHealth" then
			isOverlapping = true
			break
		end
	end

	-- 6) Count total blocks in column for height cap
	local blocksCount = 0
	for _, ch in ipairs(S.playerPlot:GetChildren()) do
		if not CollectionService:HasTag(ch, "PlacedItem") then
			continue
		end
		local spb = ch:FindFirstChild("PlacementBox")
		if not (spb and spb:IsA("BasePart")) then
			continue
		end
		local dx = math.abs(spb.Position.X - colCenterWorld.X)
		local dz = math.abs(spb.Position.Z - colCenterWorld.Z)
		local fitsXZ = (dx <= math.max(spb.Size.X, boxSize.X)/2 + EPS)
			and (dz <= math.max(spb.Size.Z, boxSize.Z)/2 + EPS)
		if fitsXZ then
			local cfg = ItemConfigurations[ch.Name]
			if cfg and cfg.Type == "Blocks" then
				blocksCount += 1
			end
		end
	end

	-- 7) Rule checks
	local itemId = S.currentItemId or ""
	local placingBlock = isBlock(itemId)
	local placingTurret = isTurret(itemId)

	local ruleOk = true
	if placingTurret then
		ruleOk = (chosenSupportModel == nil) or not chosenSupportIsTurret
	elseif placingBlock then
		if chosenSupportIsTurret then
			ruleOk = false
		else
			ruleOk = (blocksCount + 1) <= MAX_HEIGHT
		end
	end

	S.canPlace = ruleOk and (not isOverlapping)

	-- 8) SelectionBox feedback
	if not S.selectionBox then
		S.selectionBox = Instance.new("SelectionBox")
		S.selectionBox.LineThickness = 0.2
		S.selectionBox.SurfaceColor3 = VALID_COLOR
		S.selectionBox.Color3 = VALID_COLOR
		S.selectionBox.Transparency = 0
		S.selectionBox.Adornee = pb
		S.selectionBox.Parent = pb
		S.highlightColor = VALID_COLOR
	end

	local targetColor = S.canPlace and VALID_COLOR or INVALID_COLOR
	if S.highlightColor ~= targetColor then
		S.selectionBox.Color3 = targetColor
		S.highlightColor = targetColor
	end
end

function PlacementHandler:_UpdateDeleteHighlight()
	-- Desktop hover highlight only; on mobile we delete by tap ray.
	local guiObjects = playerGui:GetGuiObjectsAtPosition(mouse.X, mouse.Y)
	for _, object in ipairs(guiObjects) do
		if object:IsA("GuiButton") then
			return
		end
	end

	local S = self.State
	local targetPart = mouse.Target
	local topLevelModel: Model? = nil

	if targetPart and S.playerPlot then
		topLevelModel = _topPlacedModelUnderPart(targetPart, S.playerPlot)
	end

	if S.highlightedItem and S.highlightedItem.Model ~= topLevelModel then
		for part, originalProperties in pairs(S.highlightedItem.OriginalProperties) do
			if part and part.Parent then
				part.Color = originalProperties.Color
				part.Transparency = originalProperties.Transparency
			end
		end
		if S.selectionBox then
			S.selectionBox:Destroy()
			S.selectionBox = nil
		end
		S.highlightedItem = nil
	end

	if topLevelModel and not S.highlightedItem then
		local originalProperties: {[BasePart]: { Color: Color3, Transparency: number }} = {}
		local placementBox = topLevelModel:FindFirstChild("PlacementBox")
		for _, part in ipairs(topLevelModel:GetDescendants()) do
			if part:IsA("BasePart") then
				originalProperties[part] = { Color = part.Color, Transparency = part.Transparency }
				part.Color = INVALID_COLOR
				if part.Name == "PlacementBox" then
					part.Transparency = 1
				else
					part.Transparency = DELETE_HIGHLIGHT_TRANSPARENCY
				end
			end
		end
		PlacementHandler.State.highlightedItem = { Model = topLevelModel, OriginalProperties = originalProperties }
		if placementBox and not S.selectionBox then
			S.selectionBox = Instance.new("SelectionBox")
			S.selectionBox.LineThickness = 0.2
			S.selectionBox.Color3 = INVALID_COLOR
			S.selectionBox.Transparency = 0
			S.selectionBox.Adornee = placementBox
			S.selectionBox.Parent = placementBox
			S.highlightColor = INVALID_COLOR
		end
	end

	if not topLevelModel and S.selectionBox then
		S.selectionBox:Destroy()
		S.selectionBox = nil
	end
end

function PlacementHandler:_Update()
	local S = self.State
	if not S.isActive then return end

	if S.playerPlot and not S.playerPlot.Parent then
		S.playerPlot = nil
	end
	if not S.playerPlot then
		S.playerPlot = findMyPlot()
		if not S.playerPlot then return end
	end

	if S.isDeleteMode then
		self:_UpdateDeleteHighlight()
	else
		self:_UpdatePlacementPreview()
	end

	-- Optional UX: dim your confirm image when invalid placement
	if hudRoot and S.isActive and not S.isDeleteMode then
		local confirm = hudRoot:FindFirstChild("ConfirmButton", true)
		if confirm and confirm:IsA("GuiButton") then
			(confirm :: GuiButton).AutoButtonColor = S.canPlace
			local confirmImage = (confirm :: GuiButton):FindFirstChild("ConfirmImage", true)
			if confirmImage and (confirmImage:IsA("ImageLabel") or confirmImage:IsA("ImageButton")) then
				(confirmImage :: any).ImageTransparency = S.canPlace and 0 or 0.4
			end
		end
	end
end

-- ====== Input (desktop); mobile uses screen HUD ======
function PlacementHandler:_HandleInput(input: InputObject, gameProcessed: boolean)
	local S = self.State

	-- PC: R to rotate (reliable)
	if not UserInputService.TouchEnabled
		and input.KeyCode == Enum.KeyCode.R
		and input.UserInputState == Enum.UserInputState.Begin
		and not isTypingInTextBox()
		and S.isActive and not S.isDeleteMode
	then
		S.currentRotation = (S.currentRotation + ROTATION_INCREMENT) % 360
		if S.ghostModel then
			applyGhostRotation(S.ghostModel, S.currentRotation)
			task.defer(function() self:_UpdatePlacementPreview() end)
		end
		return
	end

	if gameProcessed then return end

	if S.isDeleteMode then
		if input.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputState == Enum.UserInputState.Begin then
			if not UserInputService.TouchEnabled then
				if S.highlightedItem and S.highlightedItem.Model then
					_deleteModel(S.highlightedItem.Model)
				else
					local model = _topPlacedModelUnderPart(mouse.Target, S.playerPlot)
					_deleteModel(model)
				end
			end
		elseif input.KeyCode == Enum.KeyCode.Q and input.UserInputState == Enum.UserInputState.Begin then
			self:ExitAllModes()
		end
	else
		if input.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputState == Enum.UserInputState.Begin then
			if not UserInputService.TouchEnabled then
				_PlaceCurrentItem()
			end
		elseif input.KeyCode == Enum.KeyCode.Q and input.UserInputState == Enum.UserInputState.Begin then
			self:ExitAllModes()
		end
	end
end

-- ====== Touch handling (MOBILE) â€“ rely on screen HUD; keep tap-to-delete only ======
local touchTapConn: RBXScriptConnection?

local function refreshTouchTapConn()
	if touchTapConn then
		touchTapConn:Disconnect()
		touchTapConn = nil
	end
	if not UserInputService.TouchEnabled then return end
	local S = PlacementHandler.State
	touchTapConn = UserInputService.TouchTap:Connect(function(positions)
		if not S.isActive then return end
		local pt = positions[1]
		if not pt then return end

		-- Let GUI consume taps
		for _, o in ipairs(playerGui:GetGuiObjectsAtPosition(pt.X, pt.Y)) do
			if o:IsA("GuiButton") then return end
		end

		if S.isDeleteMode then
			_deleteAtScreenPoint(pt)
		else
			-- With screen HUD, do NOT place on world tap; use âœ“
		end
	end)
end

-- ====== Mode switches ======
function PlacementHandler:ExitAllModes()
	local S = self.State
	S.isActive = false
	S.isDeleteMode = false

	if S.ghostModel then
		local rangePart = S.ghostModel:FindFirstChild("RangePart")
		if rangePart and rangePart:IsA("BasePart") then
			rangePart.Transparency = S.originalRangePartTransparency or 1
		end
		S.ghostModel:Destroy()
		S.ghostModel = nil
	end

	if S.selectionBox then
		S.selectionBox:Destroy()
		S.selectionBox = nil
	end

	if S.highlightedItem then
		for part, originalProperties in pairs(S.highlightedItem.OriginalProperties) do
			if part and part.Parent then
				part.Color = originalProperties.Color
				part.Transparency = originalProperties.Transparency
			end
		end
		S.highlightedItem = nil
	end

	S.currentItemId = nil
	S.currentRotation = 0
	S.originalRangePartTransparency = nil
	S.highlightColor = nil

	-- Clean mobile HUD
	destroyHud()
	refreshTouchTapConn()
end

function PlacementHandler:EnterPlacementMode(itemId: string)
	self:ExitAllModes()

	local template = BLOCKS_MODELS:FindFirstChild(itemId) or (TURRETS_MODELS and TURRETS_MODELS:FindFirstChild(itemId))
	if not (template and template.PrimaryPart) then return end

	local ghost = template:Clone()
	CollectionService:AddTag(ghost, GHOST_ITEM_TAG)

	-- Anchor ALL parts, disable collisions, make visible (except PlacementBox).
	for _, part in ipairs(ghost:GetDescendants()) do
		if part:IsA("BasePart") then
			part.Anchored = true
			part.CanCollide = false
			if part.Name ~= "PlacementBox" then
				part.Transparency = GHOST_ITEM_TRANSPARENCY
			else
				part.Transparency = 1
			end
		end
	end

	local itemConfig = ItemConfigurations[itemId]
	if itemConfig and itemConfig.Type == "Turrets" then
		local rangePart = ghost:FindFirstChild("RangePart")
		if rangePart and rangePart:IsA("BasePart") and itemConfig.Range then
			local radius = itemConfig.Range
			local diameter = radius * 2
			self.State.originalRangePartTransparency = rangePart.Transparency
			rangePart.Size = Vector3.new(0.25, diameter, diameter)
			rangePart.Transparency = GHOST_ITEM_TRANSPARENCY
			rangePart.CanCollide = false
			rangePart.Anchored = true
		end
	end

	self.State.ghostModel = ghost
	self.State.currentItemId = itemId
	self.State.isActive = true
	self.State.isDeleteMode = false
	ghost.Parent = Workspace

	applyGhostRotation(ghost, self.State.currentRotation)

	-- Mobile: screen HUD follows the ghost
	if UserInputService.TouchEnabled then
		local adornee = ghost.PrimaryPart or ghost:FindFirstChildWhichIsA("BasePart")
		if adornee then
			buildScreenHud(adornee)
		end
	end

	refreshTouchTapConn()
end

function PlacementHandler:EnterDeleteMode()
	self:ExitAllModes()
	self.State.isActive = true
	self.State.isDeleteMode = true
	-- No HUD in delete mode
	refreshTouchTapConn()
end

-- ====== Loop / Signals ======
function PlacementHandler:Init()
	unbindLegacyReload()

	RunService.Heartbeat:Connect(function()
		self:_Update()
	end)

	UserInputService.InputBegan:Connect(function(i: InputObject, gp: boolean)
		self:_HandleInput(i, gp)
	end)

	ItemPlacedFX.OnClientEvent:Connect(function()
		PlaceSound:Play()
	end)
	ItemRemovedFX.OnClientEvent:Connect(function()
		DeleteSound:Play()
	end)

	PlacementDenied.OnClientEvent:Connect(function(msg: string)
		NotificationManager.show(msg, "Error")
	end)

	BlockInventoryUpdated.OnClientEvent:Connect(function(newInventory: {[string]: number})
		self.State.currentInventory = newInventory
		inventoryState.Value = HttpService:JSONEncode(newInventory)
		if self.State.isActive and (not self.State.isDeleteMode) and self.State.currentItemId then
			if (self.State.currentInventory[self.State.currentItemId] or 0) <= 0 then
				self:ExitAllModes()
				FrameManager.open("Inventory")
			end
		end
	end)

	local ok, initialInventory = pcall(function()
		return GetBlockInventory:InvokeServer()
	end)
	if ok and initialInventory then
		self.State.currentInventory = initialInventory
		inventoryState.Value = HttpService:JSONEncode(initialInventory)
	else
		warn("[PlacementHandler] Failed to get initial inventory:", tostring(initialInventory))
	end

	refreshTouchTapConn()
end

return PlacementHandler

---

--- ReplicatedStorage.Modules.WaveConfigurations (ModuleScript) ---
--!strict
export type Group = { Enemy: string, Count: number, DelayBetweenSpawns: number }
export type WaveConfig = {
	CashReward: number?,
	Enemies: { Group },
	IsBossWave: boolean,
	BossImageId: string?,
	HealthMultiplier: number?,
	KillCashMultiplier: number?,
	DamageMultiplier: number?,
	SpawnDelayMultiplier: number?,
	TargetConcurrent: number?,
}

-- ========= BASICS =========
local MAX_WAVES = 1000
local STEP = 15

local EXTENSION = {
	baseCountMultPerSegment = 1.06,
	perWaveCountMultPerSegment = 1.01,
	perWaveHealthMultPerSegment = 1.01,
	perWaveSpawnRateMultPerSegment = 1.01,
	baseDelayMultPerSegment = 0.98,
}

-- ========= BOSSES =========
type BossDef = {
	Name: string,
	DefaultOdds: number,
	ImageId: string?,
	HealthMultiplier: number?,
	KillCashMultiplier: number?,
	DamageMultiplier: number?,
	EnemiesOverride: { Group }?,
}
local Bosses: { BossDef } = {
	{
		Name = "Drooling Zombie",
		DefaultOdds = 0.50,
		ImageId = "rbxassetid://111610396402545",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Ghost Rider",
		DefaultOdds = 0.60,
		ImageId = "rbxassetid://122442057337109",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Noob Boss",
		DefaultOdds = 0.70,
		ImageId = "rbxassetid://130140534739954",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Jandel Boss",
		DefaultOdds = 0.55,
		ImageId = "rbxassetid://135733218169449",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Shedletsky Boss",
		DefaultOdds = 0.70,
		ImageId = "rbxassetid://126735198756079",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Zombie Boss",
		DefaultOdds = 0.70,
		ImageId = "rbxassetid://116373301567241",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Void Boss",
		DefaultOdds = 0.30,
		ImageId = "rbxassetid://115344938798030",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Bacon Boss",
		DefaultOdds = 0.67,
		ImageId = "rbxassetid://94458678326774",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Pumpkin Alien",
		DefaultOdds = 0.67,
		ImageId = "rbxassetid://94458678326774",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Pumpkin Alien",
		DefaultOdds = 0.67,
		ImageId = "rbxassetid://100993286322952",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Pumpkin Reaper",
		DefaultOdds = 0.67,
		ImageId = "rbxassetid://97691854894317",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},
}

-- ========= SEGMENTS (after 15) =========
type Segment = {
	enemyWeights: { [string]: number },
	bossWeights: { [string]: number }?,
	baseCount: number?,
	perWaveCountMult: number?,
	perWaveHealthMult: number?,
	perWaveSpawnRateMult: number?,
	baseDelay: number?,
}
local Segments: { Segment } = {
	-- 16â€“30
	{
		enemyWeights = {
			["Normal Zombie"] = 0.35,
			["Ghost Zombie"]  = 0.30,
			["Ice Zombie"]    = 0.25,
			["Fire Zombie"]   = 0.10,
			["Skeleton"]      = 0.30,
			["Angry Miner"]   = 0.24,
			["Half Skeletal"] = 0.10,
			["Explosive Boy"] = 0.10,
			["RogueCowboy"]   = 0.15,
			["SkullHead"]     = 0.10,
		},
		baseCount = 24,
		perWaveCountMult = 1.03,
		perWaveHealthMult = 1.02,
		perWaveSpawnRateMult = 1.02,
		baseDelay = 1.2,
	},
	-- 31â€“45
	{
		enemyWeights = {
			["Normal Zombie"] = 0.30,
			["Ghost Zombie"]  = 0.20,
			["Ice Zombie"]    = 0.20,
			["Fire Zombie"]   = 0.30,
			["Skeleton"]      = 0.30,
			["Angry Miner"]   = 0.30,
			["Half Skeletal"] = 0.20,
			["Explosive Boy"] = 0.15,
			["RogueCowboy"]   = 0.20,
			["SkullHead"]     = 0.20,
			["Looter Caravan"] = 0.15,
			["Alien Bandit"]   = 0.10,
			["Rider Villain"]  = 0.15,
			["Ghost Cowboy"]   = 0.15,
		},
		baseCount = 26,
		perWaveCountMult = 1.035,
		perWaveHealthMult = 1.022,
		perWaveSpawnRateMult = 1.022,
		baseDelay = 1.15,
	},
	-- 46â€“60+ (odds repeat; knobs ramp every extra segment)
	{
		enemyWeights = {
			["Normal Zombie"] = 0.30,
			["Ghost Zombie"]  = 0.25,
			["Ice Zombie"]    = 0.25,
			["Fire Zombie"]   = 0.20,
			["Skeleton"]      = 0.30,
			["Angry Miner"]   = 0.30,
			["Half Skeletal"] = 0.25,
			["Explosive Boy"] = 0.25,
			["RogueCowboy"]   = 0.30,
			["SkullHead"]     = 0.30,
			["Looter Caravan"] = 0.25,
			["Alien Bandit"]   = 0.20,
			["Rider Villain"]  = 0.20,
			["Ghost Cowboy"]   = 0.20,
		},
		baseCount = 28,
		perWaveCountMult = 1.04,
		perWaveHealthMult = 1.025,
		perWaveSpawnRateMult = 1.022,
		baseDelay = 1.10,
	},
}

-- ========= HARDCODED 1â€“15 (ALL NON-BOSS) =========
local WaveConfigurations: { [number]: WaveConfig } = {
	[1]  = { CashReward=25,  IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=3, DelayBetweenSpawns=1.4}} },
	[2]  = { CashReward=40,  IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=5, DelayBetweenSpawns=1.4}} },
	[3]  = { CashReward=55,  IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=6, DelayBetweenSpawns=1.3},{Enemy="Ghost Zombie", Count=2, DelayBetweenSpawns=1.3}} },
	[4]  = { CashReward=70,  IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=8, DelayBetweenSpawns=1.3},{Enemy="Ghost Zombie", Count=2, DelayBetweenSpawns=1.3}} },
	[5]  = { CashReward=90,  IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=8, DelayBetweenSpawns=1.2},{Enemy="Ghost Zombie", Count=3, DelayBetweenSpawns=1.2},{Enemy="Ice Zombie", Count=1, DelayBetweenSpawns=1.2}} },
	[6]  = { CashReward=110, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=10,DelayBetweenSpawns=1.2},{Enemy="Ghost Zombie", Count=3, DelayBetweenSpawns=1.2},{Enemy="Ice Zombie", Count=2, DelayBetweenSpawns=1.2}} },
	[7]  = { CashReward=130, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=12,DelayBetweenSpawns=1.2},{Enemy="Ghost Zombie", Count=4, DelayBetweenSpawns=1.2},{Enemy="Ice Zombie", Count=2, DelayBetweenSpawns=1.2}} },
	[8]  = { CashReward=150, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=14,DelayBetweenSpawns=1.2},{Enemy="Ghost Zombie", Count=5, DelayBetweenSpawns=1.2},{Enemy="Ice Zombie", Count=3, DelayBetweenSpawns=1.2}} },
	[9]  = { CashReward=170, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=16,DelayBetweenSpawns=1.1},{Enemy="Ghost Zombie", Count=6, DelayBetweenSpawns=1.1},{Enemy="Ice Zombie", Count=3, DelayBetweenSpawns=1.1}} },
	[10] = { CashReward=190, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=18,DelayBetweenSpawns=1.1},{Enemy="Ghost Zombie", Count=7, DelayBetweenSpawns=1.1},{Enemy="Ice Zombie", Count=3, DelayBetweenSpawns=1.1}} },
	[11] = { CashReward=210, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=20,DelayBetweenSpawns=1.0},{Enemy="Ghost Zombie", Count=7, DelayBetweenSpawns=1.0},{Enemy="Ice Zombie", Count=4, DelayBetweenSpawns=1.0}} },
	[12] = { CashReward=230, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=20,DelayBetweenSpawns=1.0},{Enemy="Ghost Zombie", Count=8, DelayBetweenSpawns=1.0},{Enemy="Ice Zombie", Count=5, DelayBetweenSpawns=1.0}} },
	[13] = { CashReward=260, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=22,DelayBetweenSpawns=1.0},{Enemy="Ghost Zombie", Count=9, DelayBetweenSpawns=1.0},{Enemy="Ice Zombie", Count=5, DelayBetweenSpawns=1.0},{Enemy="Fire Zombie", Count=1, DelayBetweenSpawns=1.0}} },
	[14] = { CashReward=280, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=24,DelayBetweenSpawns=1.0},{Enemy="Ghost Zombie", Count=10,DelayBetweenSpawns=1.0},{Enemy="Ice Zombie", Count=6, DelayBetweenSpawns=1.0},{Enemy="Fire Zombie", Count=2, DelayBetweenSpawns=1.0}} },
	[15] = { CashReward=300, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=26,DelayBetweenSpawns=1.0},{Enemy="Ghost Zombie", Count=11,DelayBetweenSpawns=1.0},{Enemy="Ice Zombie", Count=6, DelayBetweenSpawns=1.0},{Enemy="Fire Zombie", Count=3, DelayBetweenSpawns=1.0}} },
}

-- ========= HELPERS =========
local function cashForWave(w: number): number
	local v = 180 + 10*w + 0.65*(w*w)
	return math.floor(v/5 + 0.5) * 5
end

local function weightsToCounts(weights: { [string]: number }, total: number): { [string]: number }
	local out, used = {}, 0
	local keys = {}
	for k in pairs(weights) do table.insert(keys, k) end
	table.sort(keys)
	for i, name in ipairs(keys) do
		if i < #keys then
			local c = math.floor(total * (weights[name] or 0))
			out[name] = c
			used += c
		else
			out[name] = math.max(0, total - used)
		end
	end
	return out
end

local function pickBoss(bossWeights: { [string]: number }?): BossDef
	local pool = {}
	if bossWeights then
		for name, weight in pairs(bossWeights) do pool[name] = weight end
	else
		for _, b in ipairs(Bosses) do pool[b.Name] = b.DefaultOdds end
	end
	local total, acc = 0, 0
	for _, v in pairs(pool) do total += v end
	local roll = math.random() * math.max(total, 1e-6)
	for name, v in pairs(pool) do
		acc += v
		if roll <= acc then
			for _, b in ipairs(Bosses) do if b.Name == name then return b end end
		end
	end
	return Bosses[1]
end

-- ========= SEGMENT LOGIC =========
local function segmentIndex(w: number): number
	return math.floor((w - 16) / STEP) + 1
end

local function getSegmentForWave(w: number): Segment
	local idx = segmentIndex(w)
	local last = #Segments
	if idx <= last then
		return Segments[idx]
	else
		local seg = Segments[last]
		local extra = idx - last
		return {
			enemyWeights = seg.enemyWeights,
			bossWeights  = seg.bossWeights,
			baseCount = math.floor((seg.baseCount or 24) * (EXTENSION.baseCountMultPerSegment ^ extra)),
			perWaveCountMult = (seg.perWaveCountMult or 1.03) * (EXTENSION.perWaveCountMultPerSegment ^ extra),
			perWaveHealthMult = (seg.perWaveHealthMult or 1.02) * (EXTENSION.perWaveHealthMultPerSegment ^ extra),
			perWaveSpawnRateMult = (seg.perWaveSpawnRateMult or 1.02) * (EXTENSION.perWaveSpawnRateMultPerSegment ^ extra),
			baseDelay = math.max(0.05, (seg.baseDelay or 1.2) * (EXTENSION.baseDelayMultPerSegment ^ extra)),
		}
	end
end

local function makeBossWave(w: number, seg: Segment): WaveConfig
	local b = pickBoss(seg.bossWeights)
	return {
		CashReward = cashForWave(w) + 250,
		IsBossWave = true,
		BossImageId = b.ImageId,
		HealthMultiplier = b.HealthMultiplier or 3.0,
		KillCashMultiplier = b.KillCashMultiplier or 2.0,
		DamageMultiplier = b.DamageMultiplier or 1.25,
		Enemies = b.EnemiesOverride or { { Enemy = b.Name, Count = 1, DelayBetweenSpawns = 0 } },
		TargetConcurrent = 1,
	}
end

local function makeNormalWave(w: number, seg: Segment): WaveConfig
	local idx = segmentIndex(w)
	local segStart = 16 + (idx - 1) * STEP
	local step = math.max(0, w - segStart)

	local baseCount = seg.baseCount or 24
	local cMult = seg.perWaveCountMult or 1.03
	local hpMult = seg.perWaveHealthMult or 1.02
	local rateMult = seg.perWaveSpawnRateMult or 1.02
	local delay = seg.baseDelay or 1.2

	local total = math.max(1, math.floor(baseCount * (cMult ^ step)))
	local counts = weightsToCounts(seg.enemyWeights, total)
	local enemies = {}
	for name, c in pairs(counts) do
		if c > 0 then
			table.insert(enemies, { Enemy = name, Count = c, DelayBetweenSpawns = delay })
		end
	end
	table.sort(enemies, function(a,b) return a.Enemy < b.Enemy end)

	return {
		CashReward = cashForWave(w),
		IsBossWave = false,
		Enemies = enemies,
		HealthMultiplier = hpMult ^ step,
		SpawnDelayMultiplier = 1 / math.max(0.25, rateMult ^ step),
		TargetConcurrent = nil,
	}
end

-- ========= BUILD ALL WAVES (NUMERIC KEYS ONLY, NO BOSSES) =========
for w = 16, MAX_WAVES do
	local seg = getSegmentForWave(w)
	WaveConfigurations[w] = makeNormalWave(w, seg)
end

-- ========= RARITY WEIGHTS (WAVE + REBIRTH) =========

-- base curve at wave 1 (no rebirth)
local BASE_RARITY_WEIGHTS = {
	Common    = 0.80,
	Rare      = 0.18,
	Epic      = 0.02,
	Legendary = 0.00,
	Boss      = 0.00,
	Secret    = 0.00,
}

-- target curve at wave 1000 (no rebirth)
local MAX_RARITY_WEIGHTS = {
	Common    = 0.05,
	Rare      = 0.10,
	Epic      = 0.35,
	Legendary = 0.30,
	Boss      = 0.15,
	Secret    = 0.05,
}

local MIN_WEIGHT = 0.0025 -- never fully 0 so low tiers still possible

local function lerp(a: number, b: number, t: number): number
	return a + (b - a) * t
end

local function getBaseRarityWeightsForWave(w: number): {[string]: number}
	local t = 0
	if MAX_WAVES > 1 then
		t = math.clamp((w - 1) / (MAX_WAVES - 1), 0, 1)
	end

	local weights: {[string]: number} = {}
	local sum = 0

	for rarity, baseW in pairs(BASE_RARITY_WEIGHTS) do
		local maxW = MAX_RARITY_WEIGHTS[rarity] or baseW
		local wgt = lerp(baseW, maxW, t)
		if wgt < MIN_WEIGHT then
			wgt = MIN_WEIGHT
		end
		weights[rarity] = wgt
		sum += wgt
	end

	for rarity, wgt in pairs(weights) do
		weights[rarity] = wgt / sum
	end

	return weights
end

-- per-rebirth bias: >1 boosts, <1 nerfs
local REBIRTH_RARITY_BIAS = {
	Common    = 0.92,
	Rare      = 0.96,
	Epic      = 1.04,
	Legendary = 1.08,
	Boss      = 1.10,
	Secret    = 1.12,
}

local function applyRebirthToWeights(baseWeights: {[string]: number}, rebirths: number): {[string]: number}
	if rebirths <= 0 then
		return baseWeights
	end

	local clampedRebirths = math.min(rebirths, 15) -- hard-cap so it doesn't go insane
	local adjusted: {[string]: number} = {}
	local sum = 0

	for rarity, wgt in pairs(baseWeights) do
		local bias = REBIRTH_RARITY_BIAS[rarity] or 1
		local mult = bias ^ clampedRebirths
		local newW = wgt * mult
		if newW < MIN_WEIGHT then
			newW = MIN_WEIGHT
		end
		adjusted[rarity] = newW
		sum += newW
	end

	for rarity, wgt in pairs(adjusted) do
		adjusted[rarity] = wgt / sum
	end

	return adjusted
end

local function GetRarityWeights(waveNumber: number, rebirths: number?): {[string]: number}
	local base = getBaseRarityWeightsForWave(waveNumber)
	if not rebirths or rebirths <= 0 then
		return base
	end
	return applyRebirthToWeights(base, rebirths)
end

-- ========= EXPOSE HELPERS =========
local function ResolveWave(w: number): WaveConfig
	return WaveConfigurations[w]
end

local function ResolveBossWave(w: number): WaveConfig
	local seg = getSegmentForWave(math.max(w, 16))
	return makeBossWave(w, seg)
end

setmetatable(WaveConfigurations, {
	__index = function(_, k)
		if k == "ResolveWave" then
			return ResolveWave
		elseif k == "ResolveBossWave" then
			return ResolveBossWave
		elseif k == "GetRarityWeights" then
			return GetRarityWeights
		end
		return nil
	end
})

return WaveConfigurations

---

--- ReplicatedStorage.Modules.EnemyConfigurations (ModuleScript) ---
--!strict
-- This module contains data for each enemy type.

local EnemyConfigurations = {
	["Normal Zombie"] = {
		CashReward = 5,
		MaxHealth = 85,
		Damage = 10,
		Rarity = "Common",
		ValuePerSecond = 1,
		SellValue = 5,
	},

	["Ghost Zombie"] = {
		CashReward = 7,
		MaxHealth = 100,
		Damage = 15,
		Rarity = "Rare",
		ValuePerSecond = 2,
		SellValue = 10,
	},

	["Ice Zombie"] = {
		CashReward = 8,
		MaxHealth = 150,
		Damage = 20,
		Rarity = "Rare",
		ValuePerSecond = 2,
		SellValue = 12,
	},

	["Fire Zombie"] = {
		CashReward = 9,
		MaxHealth = 190,
		Damage = 25,
		Rarity = "Rare",
		ValuePerSecond = 3,
		SellValue = 15,
	},

	["Toxic Zombie"] = {
		CashReward = 10,
		MaxHealth = 240,
		Damage = 30,
		Rarity = "Rare",
		ValuePerSecond = 3,
		SellValue = 18,
	},

	["Skeleton"] = {
		CashReward = 6,
		MaxHealth = 90,
		Damage = 15,
		Rarity = "Common",
		ValuePerSecond = 1,
		SellValue = 6,
	},

	["Angry Miner"] = {
		CashReward = 8,
		MaxHealth = 135,
		Damage = 15,
		Rarity = "Rare",
		ValuePerSecond = 2,
		SellValue = 12,
	},

	["Half Skeletal"] = {
		CashReward = 9,
		MaxHealth = 105,
		Damage = 20,
		Rarity = "Rare",
		ValuePerSecond = 2,
		SellValue = 14,
	},

	["Explosive Boy"] = {
		CashReward = 10,
		MaxHealth = 245,
		Damage = 35,
		Rarity = "Epic",
		ValuePerSecond = 4,
		SellValue = 20,
	},

	["RogueCowboy"] = {
		CashReward = 10,
		MaxHealth = 130,
		Damage = 25,
		Rarity = "Epic",
		ValuePerSecond = 4,
		SellValue = 22,
	},

	["SkullHead"] = {
		CashReward = 10,
		MaxHealth = 135,
		Damage = 25,
		Rarity = "Epic",
		ValuePerSecond = 4,
		SellValue = 22,
	},

	["Looter Caravan"] = {
		CashReward = 12,
		MaxHealth = 300,
		Damage = 40,
		Rarity = "Epic",
		ValuePerSecond = 5,
		SellValue = 25,
	},

	["Alien Bandit"] = {
		CashReward = 12,
		MaxHealth = 250,
		Damage = 65,
		Rarity = "Legendary",
		ValuePerSecond = 7,
		SellValue = 35,
	},

	["Rider Villain"] = {
		CashReward = 12,
		MaxHealth = 250,
		Damage = 65,
		Rarity = "Legendary",
		ValuePerSecond = 7,
		SellValue = 35,
	},

	["Ghost Cowboy"] = {
		CashReward = 12,
		MaxHealth = 160,
		Damage = 70,
		Rarity = "Legendary",
		ValuePerSecond = 8,
		SellValue = 40,
	},

	-- BOSS
	["Ghost Rider"] = {
		CashReward = 20,
		MaxHealth = 1640,
		Damage = 60,
		Rarity = "Boss",
		ValuePerSecond = 15,
		SellValue = 100,
	},

	["Noob Boss"] = {
		CashReward = 20,
		MaxHealth = 1640,
		Damage = 55,
		Rarity = "Boss",
		ValuePerSecond = 15,
		SellValue = 100,
	},

	["Jandel Boss"] = {
		CashReward = 20,
		MaxHealth = 1640,
		Damage = 65,
		Rarity = "Boss",
		ValuePerSecond = 16,
		SellValue = 110,
	},

	["Shedletsky Boss"] = {
		CashReward = 20,
		MaxHealth = 1640,
		Damage = 60,
		Rarity = "Boss",
		ValuePerSecond = 15,
		SellValue = 100,
	},

	["Drooling Zombie"] = {
		CashReward = 20,
		MaxHealth = 1640,
		Damage = 64,
		Rarity = "Boss",
		ValuePerSecond = 16,
		SellValue = 110,
	},

	["Zombie Boss"] = {
		CashReward = 20,
		MaxHealth = 1640,
		Damage = 60,
		Rarity = "Boss",
		ValuePerSecond = 15,
		SellValue = 100,
	},

	["Void Boss"] = {
		CashReward = 20,
		MaxHealth = 1640,
		Damage = 63,
		Rarity = "Boss",
		ValuePerSecond = 18,
		SellValue = 120,
	},

	["Bacon Boss"] = {
		CashReward = 20,
		MaxHealth = 1640,
		Damage = 56,
		Rarity = "Boss",
		ValuePerSecond = 15,
		SellValue = 100,
	},

	["Pumpkin Alien"] = {
		CashReward = 20,
		MaxHealth = 1640,
		Damage = 65,
		Rarity = "Boss",
		ValuePerSecond = 17,
		SellValue = 115,
	},

	["Pumpkin Reaper"] = {
		CashReward = 20,
		MaxHealth = 1640,
		Damage = 65,
		Rarity = "Boss",
		ValuePerSecond = 18,
		SellValue = 120,
	},
}

return EnemyConfigurations

---

--- ReplicatedStorage.Modules.ModelProgression (ModuleScript) ---
--!strict
-- This module defines the progression of items the player protects.

local ModelProgression = {
	-- IMPORTANT: The tables must be in order, starting from 1.

	[1] = {
		ModelName = "1",
		PlotHealth = 10,
		WaveRequirement = 0,
		ImageId = "rbxassetid://110988601683343",
	},
	[2] = {
		ModelName = "2",
		PlotHealth = 20,
		WaveRequirement = 15,
		ImageId = "rbxassetid://71530011018392",
	},
	[3] = {
		ModelName = "3",
		PlotHealth = 30,
		WaveRequirement = 45,
		ImageId = "rbxassetid://70765293183243",
	},
	[4] = {
		ModelName = "4",
		PlotHealth = 40,
		WaveRequirement = 60,
		ImageId = "rbxassetid://127554191147986",
	},
	[5] = {
		ModelName = "5",
		PlotHealth = 50,
		WaveRequirement = 75,
		ImageId = "rbxassetid://101196843053573",
	},
	[6] = {
		ModelName = "6",
		PlotHealth = 50,
		WaveRequirement = 120,
		ImageId = "rbxassetid://109464415588878",
	},
	[7] = {
		ModelName = "7",
		PlotHealth = 50,
		WaveRequirement = 150,
		ImageId = "rbxassetid://122966550318789",
	},
	[8] = {
		ModelName = "8",
		PlotHealth = 50,
		WaveRequirement = 205,
		ImageId = "rbxassetid://111332197178362",
	},
}

return ModelProgression
---

--- ReplicatedStorage.Modules.DamageHandler (ModuleScript) ---
--!strict
-- Located in: ReplicatedStorage/Modules/DamageHandler.lua

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local HighlightZombie = ReplicatedStorage.Events:WaitForChild("HighlightZombie")

local DamageHandler = {}

function DamageHandler.dealDamage(source: Instance, target: Instance, damageAmount: number): boolean
	if not target or not target.Parent then return false end

	local humanoid = target:FindFirstChildOfClass("Humanoid")
	local healthAttribute = target:GetAttribute("Health")

	if humanoid then
		humanoid:TakeDamage(damageAmount)

		-- Only highlight if the target is still alive
		--if humanoid.Health > 0 then
		--	HighlightZombie:FireAllClients(target)
		--end

		return humanoid.Health <= 0

	elseif typeof(healthAttribute) == "number" then
		local newHealth = healthAttribute - damageAmount
		target:SetAttribute("Health", newHealth)

		if newHealth <= 0 then
			if target.Name ~= "PlotHealth" then
				target:Destroy()
			end
			return true
		end
	end

	return false
end

return DamageHandler
---

--- ReplicatedStorage.Modules.WeaponConfigurations (ModuleScript) ---
--!strict
-- This module contains data for all crates and weapons.

local WeaponConfigurations = {
	--RESTOCKS
	ShopProducts = {
		RestockBlocksShop = { ProductID = 3435398560}, -- Use your new DevProduct ID here
		RestockWeaponsShop = { ProductID = 3435398961}, -- Use your new DevProduct ID here
	},
	--CASH
	CashProducts = {
		Product1 = { ProductID = 3433108028, CashAmount = 5000 },
		Product2 = { ProductID = 3433108213, CashAmount = 25000 },
		Product3 = { ProductID = 3433108417, CashAmount = 100000 },
		Product4 = { ProductID = 3433108573, CashAmount = 300000 },
	},
	--CRATES
	Crates = {
		--ROBUX
		GoldCrate = {
			DisplayName = "Gold Weapon Crate",
			ImageId = "rbxassetid://103369512470336",
			ProductID = 3433548997,
			Loot = {
				{Item = "Electra", Weight = 25},
				{Item = "Heliocore", Weight = 15},
				{Item = "PlasmaGun", Weight = 15},
				{Item = "Riftshot", Weight = 20},
				{Item = "Toxion", Weight = 25},
			}
		},
		--SHOP
		WoodCrate = {
			DisplayName = "Wood Weapon Crate",
			Price = 600,
			ImageId = "rbxassetid://71941897708431",
			ProductID = 3433106911,
			SkipTimerProductID = 3433550556,
			Unlimited = false,
			Chance = 100,
			StockAmount = {Min = 1, Max = 5},
			UnlockTime = 60,
			Loot = {
				{Item = "KimberK65", Weight = 40},
				--{Item = "DesertEagle", Weight = 25},
				{Item = "Uzi", Weight = 5},
			}
		},
		MetalCrate = {
			DisplayName = "Metal Weapon Crate",
			Price = 4500,
			ImageId = "rbxassetid://83369732207805",
			ProductID = 3433107064,
			SkipTimerProductID = 3433550660,
			Unlimited = false,
			Chance = 60,
			StockAmount = {Min = 1, Max = 4},
			UnlockTime = 180,
			Loot = {
				{Item = "Uzi", Weight = 30},
				{Item = "Mp5", Weight = 20},
				{Item = "K3", Weight = 10},
				{Item = "Ak47", Weight = 4.5},
			}
		},
		LavaCrate = {
			DisplayName = "Mystic Weapon Crate",
			Price = 10500,
			ImageId = "rbxassetid://123400851920868",
			ProductID = 3451490544,
			SkipTimerProductID = 3451799259,
			Unlimited = false,
			Chance = 30,
			StockAmount = {Min = 1, Max = 3},
			UnlockTime = 480,
			Loot = {
				{Item = "Uzi", Weight = 40},
				{Item = "Mp5", Weight = 30},
				{Item = "Ak47", Weight = 15},
				{Item = "K3", Weight = 30},
				{Item = "Electra", Weight = 0.5},
				{Item = "Heliocore", Weight = 0.5},
				{Item = "PlasmaGun", Weight = 0.5},
				{Item = "Riftshot", Weight = 0.5},
				{Item = "Toxion", Weight = 0.5},
			}
		},
	},

	Weapons = {
		----Starter
		Heizer = { DisplayName = "Starter Pistol", ImageId = "rbxassetid://126357192361583" },
		--Wood
		KimberK65 = { DisplayName = "Revolver", ImageId = "rbxassetid://126357192361583" },
		DesertEagle = { DisplayName = "Desert Eagle", ImageId = "rbxassetid://126321981198719" },
		--Metal 
		Uzi = { DisplayName = "Uzi", ImageId = "rbxassetid://105402058861520" },
		Mp5 = { DisplayName = "MP5", ImageId = "rbxassetid://86471167567925" },
		sp5 = { DisplayName = "SP5", ImageId = "rbxassetid://126321981198719" },
		--Lava
		K3 = { DisplayName = "K3", ImageId = "rbxassetid://101148291850721" },
		M14 = { DisplayName = "M14", ImageId = "rbxassetid://126321981198719" },
		--Gold 
		Ak47 = { DisplayName = "Ak-47", ImageId = "rbxassetid://76263708523559" },
		Scout = { DisplayName = "Scout Sniper", ImageId = "rbxassetid://126321981198719" },
		Minigun = { DisplayName = "OP Minigun", ImageId = "rbxassetid://105369473183603" },
		
		Heliocore = { DisplayName = "Heliocore", ImageId = "rbxassetid://110449100260279" },
		Electra = { DisplayName = "Electra", ImageId = "rbxassetid://97942841375097" },
		Toxion = { DisplayName = "Toxion", ImageId = "rbxassetid://122765809455182" },
		Riftshot = { DisplayName = "Riftshot", ImageId = "rbxassetid://129412800119898" },
		PlasmaGun = { DisplayName = "PlasmaGun", ImageId = "rbxassetid://112273276197884" },

		
		
		
		--WoodSword = { DisplayName = "Wood Sword", ImageId = "rbxassetid://126321981198719" },
		----Wood
		--StoneSword = { DisplayName = "Stone Sword", ImageId = "rbxassetid://98850338938642" },
		--ClassicSword = { DisplayName = "Classic Sword", ImageId = "rbxassetid://137083985660048" },
		--WhiteSword = { DisplayName = "WhiteSword", ImageId = "rbxassetid://107209992307667" },
		----Metal
		--BlueSword = { DisplayName = "Blue Sword", ImageId = "rbxassetid://106268955187746" },
		--IceSword = { DisplayName = "Ice Sword", ImageId = "rbxassetid://86285408542421" },
		--AzureSword = { DisplayName = "Azure Sword", ImageId = "rbxassetid://139447042654835" },
		--PinkSword = { DisplayName = "Pink Sword", ImageId = "rbxassetid://123160254672400" },
		----Lava
		--OrangeSword = { DisplayName = "Orange Sword", ImageId = "rbxassetid://127527435191865" },
		--RedSword = { DisplayName = "Red Sword", ImageId = "rbxassetid://101443099194443" },
		--DragonSword = { DisplayName = "Dragon Sword", ImageId = "rbxassetid://101415025341980" },
		----Gold
		--GoldSword = { DisplayName = "Gold Sword", ImageId = "rbxassetid://122412629570696" },
		--GoldClassic = { DisplayName = "Gold Classic", ImageId = "rbxassetid://94902355900831" },
		--GoldIce = { DisplayName = "Gold Ice", ImageId = "rbxassetid://87139784295616" },
		--GoldAzure = { DisplayName = "Gold Azure", ImageId = "rbxassetid://74018974426561" },
	}
}

return WeaponConfigurations
---

--- ReplicatedStorage.Modules.LeaderboardConfig (ModuleScript) ---
--!strict
local LeaderboardConfig = {
	DataStores = {
		MostCash       = "LB_MostCash_v1",
		MostWaves      = "LB_MostWaves_v1",
		MostPlaytime   = "LB_MostPlaytime_v1",
		MostRobuxSpent = "LB_MostRobuxSpent_v1", 
	},

	UI = {
		CanvasSize    = Vector2.new(900, 700),
		PixelsPerStud = 45,
		Bg            = Color3.fromRGB(30,170,255),
		Stroke        = Color3.fromRGB(0,0,0),
		TitleColor    = Color3.fromRGB(255,255,255),
		TextColor     = Color3.fromRGB(240,240,240),
		TitleSize     = 42,
		RowSize       = 28,
		RowPad        = 12,
	},


	Limit        = 10,
	PullInterval = 120,


	ModelNames = {
		Cash     = "MostCash",
		Waves    = "MostWaves",
		Playtime = "MostPlaytime",
		Robux    = "MostRobuxSpent",
	},


	BoardPartName = "Board",
}
return LeaderboardConfig

---

--- ReplicatedStorage.Modules.TravellingConfigurations (ModuleScript) ---
--!strict
local TravellingConfigurations = {
	-- Window stays 5 minutes (300 s)
	WINDOW_SECONDS = 300,

	-- NEW: auto-open every N minutes (use 20 for :00, :20, :40)
	AUTO_MINUTE_INTERVAL = 20,

	ADMIN_USER_IDS = {
		[936563031] = true, -- you
		[102527104] = true,
	},

	LUCK_DURATION_SECONDS = 15 * 60,
	LUCK_DROP_MULTIPLIER  = 1.50,
	LUCK_BADGE_ICON       = "rbxassetid://74485910606028",

	OFFERS = {
		{
			Id = "LuckPotion15m",
			Title = "Luck Potion (15m)",
			Kind  = "Luck",
			Duration = 15 * 60,
			Price = 12000,
			StockTotal = 2,
			Icon = "rbxassetid://74485910606028",
		},
		{
			Id = "MortarGuard",
			Title = "Mortar Cowboy",
			Kind  = "Unit",
			Price = 65000,
			StockTotal = 2,
			Icon = "rbxassetid://97959863510956",
		},
		{
			Id = "Diamond",
			Title = "Diamond Block",
			Kind  = "Block",
			Price = 25000,
			StockTotal = 2,
			Icon = "rbxassetid://90412412707609",
		},
		{
			Id = "ToxicSpike",
			Title = "Toxic Spike",
			Kind  = "Block",
			Price = 30000,
			StockTotal = 2,
			Icon = "rbxassetid://115198885487974",
		},
	},

	ALLOW_PUBLIC_RESTOCK  = false,
	RESTOCK_DEVPRODUCT_ID = 0,
	RESTOCK_INCREMENT     = 1,
}

return TravellingConfigurations

---

--- ReplicatedStorage.Modules.UpgradePlotConfig (ModuleScript) ---
--!strict
local UpgradePlotConfig = {}

UpgradePlotConfig.MaxTier = 10

UpgradePlotConfig.TurretLimitByTier  = {10, 15, 20, 25, 30, 35, 40, 45, 50, 55}
UpgradePlotConfig.BlockLimitByTier   = {15, 30, 50, 70, 90, 100, 110, 120, 130, 140}

-- Multipliers (still applied if players already have tiers)
UpgradePlotConfig.TurretHpMultByTier = {1.00, 1.10, 1.20, 1.30, 1.40, 1.55, 1.70, 1.85, 2.05, 2.25}
UpgradePlotConfig.BlockHpMultByTier  = {1.00, 1.08, 1.16, 1.24, 1.32, 1.42, 1.52, 1.64, 1.78, 1.95}

-- Cash costs current -> next
UpgradePlotConfig.Costs_TurretLimit  = {5000, 15000, 30000, 45000, 90000, 125000, 160000, 200000}
UpgradePlotConfig.Costs_BlockLimit   = {2500, 7500, 15000, 30000, 45000, 60000, 75000, 90000, 105000, 120000}

-- ðŸ”’ Retired: disallow further HP purchases by providing no next-costs
UpgradePlotConfig.Costs_TurretHp     = {}
UpgradePlotConfig.Costs_BlockHp      = {}

function UpgradePlotConfig.GetTrackValue(track:string, tier:number): number
	local t = if track=="TurretLimitTier" then UpgradePlotConfig.TurretLimitByTier
		elseif track=="BlockLimitTier"   then UpgradePlotConfig.BlockLimitByTier
		elseif track=="TurretHpTier"     then UpgradePlotConfig.TurretHpMultByTier
		elseif track=="BlockHpTier"      then UpgradePlotConfig.BlockHpMultByTier
		else error("Unknown track "..track)
	return t[math.clamp(tier, 1, #t)]
end

function UpgradePlotConfig.GetNextCost(track:string, tier:number): number?
	if tier >= UpgradePlotConfig.MaxTier then return nil end
	local t = if track=="TurretLimitTier" then UpgradePlotConfig.Costs_TurretLimit
		elseif track=="BlockLimitTier"   then UpgradePlotConfig.Costs_BlockLimit
		elseif track=="TurretHpTier"     then UpgradePlotConfig.Costs_TurretHp
		elseif track=="BlockHpTier"      then UpgradePlotConfig.Costs_BlockHp
		else error("Unknown track "..track)
	return t[tier] -- will be nil for HP tracks -> cannot buy
end

return UpgradePlotConfig

---

--- ReplicatedStorage.Modules.TopUpModule (ModuleScript) ---
--!strict
-- TopUpModule: pick nearest cash devproduct and prompt player if short on money.
-- Non-blocking API with a callback invoked as soon as the prompt closes.
local ReplicatedStorage    = game:GetService("ReplicatedStorage")
local Players              = game:GetService("Players")
local MarketplaceService   = game:GetService("MarketplaceService")

local ModulesFolder        = ReplicatedStorage:WaitForChild("Modules")
local WeaponConfigurations = require(ModulesFolder:WaitForChild("WeaponConfigurations"))
-- << ADDED >>
local Functions = ReplicatedStorage:WaitForChild("Functions")

local TopUp = {}

type CashProduct = { ProductID: number, CashAmount: number }
type ResultCb = (purchased: boolean) -> ()

local function allCashProducts(): { CashProduct }
	local arr: { CashProduct } = {}
	for _, entry in pairs(WeaponConfigurations.CashProducts) do
		if typeof(entry.ProductID) == "number" and typeof(entry.Amount) == "number" then
			table.insert(arr, { ProductID = entry.ProductID, CashAmount = entry.CashAmount })
		end
	end
	return arr
end

-- << NEW FUNCTION >> Get the player's current cash directly from the server
local function getLocalBalance(p: Player): number
	local getCashFunc = Functions:FindFirstChild("GetPlayerCash")
	if getCashFunc and getCashFunc:IsA("RemoteFunction") then
		local ok, cash = pcall(getCashFunc.InvokeServer, getCashFunc)
		if ok and typeof(cash) == "number" then
			return cash
		end
	end
	-- Fallback to 0 if server can't be reached
	return 0
end


function TopUp.getNearestProductId(missingAmount: number): number?
	if typeof(missingAmount) ~= "number" or missingAmount <= 0 then return nil end
	local bestId: number?
		= nil
	local bestDiff = math.huge
	local bestAmt  = -math.huge
	for _, p in ipairs(allCashProducts()) do
		local diff = math.abs(p.CashAmount - missingAmount)
		if diff < bestDiff or (diff == bestDiff and p.CashAmount > bestAmt) then
			bestDiff = diff
			bestAmt  = p.CashAmount
			bestId   = p.ProductID
		end
	end
	return bestId
end

-- Opens the prompt and returns immediately.
-- Returns: promptOpened:boolean
-- onResult(purchased:boolean) is called as soon as the dialog closes.
function TopUp.PromptIfShort(costOrMissing: number, balance: number?, onResult: ResultCb?): boolean
	-- Use the server to get the current balance if not provided, since leaderstats are gone
	if balance == nil then
		balance = getLocalBalance(Players.LocalPlayer) -- Use the new local getter
	end

	local missing = (typeof(balance) == "number") and (costOrMissing - balance) or costOrMissing
	if typeof(missing) ~= "number" or missing <= 0 then
		return false
	end

	local productId = TopUp.getNearestProductId(missing)
	if typeof(productId) ~= "number" then
		if onResult then onResult(false) end
		return false
	end

	local lp = Players.LocalPlayer
	if not lp then
		if onResult then onResult(false) end
		return false
	end

	local conn: RBXScriptConnection?
		= nil
	conn = MarketplaceService.PromptProductPurchaseFinished:Connect(function(player, purchasedProductId, wasPurchased)
		if player == lp and purchasedProductId == productId then
			if conn then conn:Disconnect() end
			if onResult then
				onResult(wasPurchased == true)
			end
		end
	end)

	local ok, err = pcall(function()
		MarketplaceService:PromptProductPurchase(lp, productId)
	end)
	if not ok then
		if conn then conn:Disconnect() end
		if onResult then onResult(false) end
		return false
	end

	return true
end

return TopUp
---

--- ReplicatedStorage.Modules.BadgeConfigurations (ModuleScript) ---
--!strict
-- Central place for all badge IDs

export type BadgeKey =
	"You played!" |
"Acquired Revolver Cowboy" |
"Acquired Akimbo Cowboy" |
"Acquired Uzi Cowboy" |
"Acquired Shotgun Cowboy" |
"Acquired Heavy Gunner" |
"Acquired Rifle Cowboy" |
"Acquired Mortar Cowboy" |
"First Mutation"

local BadgeCatalog: {[BadgeKey]: number} = {
	["You played!"]                 = 3052525153404258,
	["Acquired Revolver Cowboy"]    = 591671251623280,
	["Acquired Akimbo Cowboy"]      = 3467287377539020,
	["Acquired Uzi Cowboy"]         = 583789044141476,
	["Acquired Shotgun Cowboy"]     = 84885666466521,
	["Acquired Heavy Gunner"]       = 2468150254651967,
	["Acquired Rifle Cowboy"]       = 3063311694654024,
	["Acquired Mortar Cowboy"]      = 801395319305690,
	["First Mutation"]              = 1504419190804543,
}

return BadgeCatalog

---

--- ReplicatedStorage.Modules.LevelUpConfiguration (ModuleScript) ---
--!strict
local Config = {
	PROFILE_KEYS = {
		UNITS = "BlockInventory",      -- where all guard counts live
		JOB   = "ActiveLevelUpJob",    -- current running job
	},

	-- We have 5 levels: L1 (base), L2, L3, L4, L5
	-- Tier index is the "merge step":
	--   tier 1 => L1 -> L2
	--   tier 2 => L2 -> L3
	--   tier 3 => L3 -> L4
	--   tier 4 => L4 -> L5 (max)
	MAX_TIER   = 4,

	DAMAGE_MULT  = { 1.10, 1.25, 1.45, 1.70 },  -- for L2..L5
	HEALTH_MULT  = { 1.10, 1.25, 1.40, 1.60 },

	-- Time per level-up job (you can tweak)
	TIER_SECONDS = {
		15 * 60,  -- tier 1
		30 * 60,  -- tier 2
		45 * 60,  -- tier 3
		60 * 60,  -- tier 4
	},

	-- Result id helper:
	--   baseId, tier=1 => baseId_M1 (L2)
	--   baseId, tier=2 => baseId_M2 (L3)
	--   baseId, tier=3 => baseId_M3 (L4)
	--   baseId, tier=4 => baseId_M4 (L5)
	ResultId = function(baseId: string, tier: number): string
		return string.format("%s_M%d", baseId, tier)
	end,

	-- Level-up rules: units + optional cash per tier.
	-- You can change the cash values whenever.
	RULES = {
		RevolverGuard = {
			[1] = { units = 10, cash = 0 },    -- L1 -> L2
			[2] = { units =  6, cash = 0 },    -- L2 -> L3
			[3] = { units =  4, cash = 0 },    -- L3 -> L4 (set >0 for money cost)
			[4] = { units =  2, cash = 0 },    -- L4 -> L5 (set >0 for money cost)
		},
		DualRevolverGuard = {
			[1] = { units = 10, cash = 0 },
			[2] = { units =  6, cash = 0 },
			[3] = { units =  4, cash = 0 },
			[4] = { units =  2, cash = 0 },
		},
		SubmachineGunGuard = {
			[1] = { units = 10, cash = 0 },
			[2] = { units =  6, cash = 0 },
			[3] = { units =  4, cash = 0 },
			[4] = { units =  2, cash = 0 },
		},
		RifleGuard = {
			[1] = { units = 10, cash = 0 },
			[2] = { units =  6, cash = 0 },
			[3] = { units =  4, cash = 0 },
			[4] = { units =  2, cash = 0 },
		},
		ShotgunGuard = {
			[1] = { units = 10, cash = 0 },
			[2] = { units =  6, cash = 0 },
			[3] = { units =  4, cash = 0 },
			[4] = { units =  2, cash = 0 },
		},
		GatlingGuard = {
			[1] = { units = 10, cash = 0 },
			[2] = { units =  6, cash = 0 },
			[3] = { units =  4, cash = 0 },
			[4] = { units =  2, cash = 0 },
		},
	},

	MUTABLE = {
		"RevolverGuard","DualRevolverGuard","RifleGuard",
		"ShotgunGuard","GatlingGuard","SubmachineGunGuard",
	},

	-- Parse helper: "RevolverGuard_M3" -> "RevolverGuard", 3
	ParseMutationId = function(id: string): (string?, number?)
		local base, t = string.match(id, "^(.-)_M(%d+)$")
		if base and t then return base, tonumber(t) end
		return nil, nil
	end,

	-- Apply tier stat multipliers (for your tower stats module)
	ApplyTierBoost = function(baseStats: {[string]: any}, tier: number): {[string]: any}
		local dmgMul = (Config.DAMAGE_MULT[tier] or 1)
		local hpMul  = (Config.HEALTH_MULT[tier] or 1)
		local copy = table.clone(baseStats)
		if copy.Damage then copy.Damage = math.floor(copy.Damage * dmgMul) end
		if copy.Health then copy.Health = math.floor(copy.Health * hpMul) end
		return copy
	end,
}

return Config

---

--- ReplicatedStorage.Modules.RewardConfiguration (ModuleScript) ---
--!strict
-- ReplicatedStorage/Modules/RewardConfiguration

local RewardConfiguration = {}

-- Daily rewards list (index = day)
-- You can tweak the "Type" handling later; for now only "Cash" is actually
-- granted, the rest just show a notification text.

RewardConfiguration.DailyRewards = {
	[1] = { 
		Id = 1,
		Type = "Cash",
		Amount = 50_000,
		Label = "50,000 Cash",
	},


	[2] = { 
		Id = 2,
		Type = "Cash",
		Amount = 75_000,
		Label = "75,000 Cash",
	},

	[3] = {
		Id = 3,
		Type = "Cowboy",
		CowboyId = "ShotgunCowboy",
		Label = "Shotgun Cowboy (to be implemented)",
	},

	[4] = {
		Id = 4,
		Type = "Cash",
		Amount = 100_000,
		Label = "100,000 Cash",
	},

	[5] = {
		Id = 5,
		Type = "TimedMinigun",
		DurationSeconds = 60 * 60,
		Label = "1 Hour of Minigun (to be implemented)",
	},

	[6] = {
		Id = 6,
		Type = "PermanentLuck",
		Amount = 1,
		Label = "Permanent +1 Luck (to be implemented)",
	},

	[7] = {
		Id = 7,
		Type = "Cowboy",
		CowboyId = "OPCowboy",
		Label = "OP Cowboy (to be implemented)",
	},
}

RewardConfiguration.MaxDailyDay = #RewardConfiguration.DailyRewards

return RewardConfiguration

---

--- ReplicatedStorage.Modules.DailyRewardsHandler (ModuleScript) ---
--!strict
-- ReplicatedStorage/Modules/DailyRewardsHandler

local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService        = game:GetService("RunService")

local NotificationManager = require(ReplicatedStorage.Modules:WaitForChild("NotificationManager"))

local DailyRewardsHandler = {}

----------------------------------------------------------------
-- REMOTES
----------------------------------------------------------------

local player    = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local Functions = ReplicatedStorage:WaitForChild("Functions")
local GetDailyRewardsStateFn = Functions:WaitForChild("GetDailyRewardsState") :: RemoteFunction
local ClaimDailyRewardFn     = Functions:WaitForChild("ClaimDailyReward")     :: RemoteFunction

----------------------------------------------------------------
-- UI REFERENCES
----------------------------------------------------------------

-- DailyRewards frame: PlayerGui/ScreenGui/DailyRewards
local MainScreenGui     = playerGui:WaitForChild("ScreenGui") :: ScreenGui
local DailyRewardsFrame = MainScreenGui:WaitForChild("DailyRewards") :: Frame
local CloseButton       = DailyRewardsFrame:WaitForChild("xbutton") :: ImageButton

-- HUD button: PlayerGui/GUI/HUD/Right/Buttons/Rewards
local GuiRoot   = playerGui:WaitForChild("GUI") :: ScreenGui
local HUD       = GuiRoot:WaitForChild("HUD") :: Frame
local RightSide = HUD:WaitForChild("Right") :: Frame
local Buttons   = RightSide:WaitForChild("Buttons") :: Frame
local RewardsButton = Buttons:WaitForChild("Rewards") :: ImageButton

-- Layout:
-- DailyRewards > Container > Day7
-- DailyRewards > Container > Grid > Day1..Day6
local Container = DailyRewardsFrame:WaitForChild("Container") :: Frame
local Grid      = Container:WaitForChild("Grid") :: Frame
local Day7Frame = Container:WaitForChild("Day7") :: Frame

-- Day slots & clickable buttons
local DaySlots:   {[number]: Frame | TextButton} = {}
local DayButtons: {[number]: TextButton} = {}

-- Day1..Day6 are TextButtons directly under Grid with those names
for i = 1, 6 do
	local btn = Grid:WaitForChild("Day" .. i) :: TextButton
	DaySlots[i] = btn
	DayButtons[i] = btn
end

-- Day7Frame has a TextButton child named "Day7"
local day7Btn = Day7Frame:WaitForChild("Day7") :: TextButton
DaySlots[7]   = day7Btn
DayButtons[7] = day7Btn

----------------------------------------------------------------
-- STYLE TEMPLATES
----------------------------------------------------------------

type DayStyle = {
	PosColor: Color3?,
	TextColor: Color3?,
}

local ClaimedStyle: DayStyle = {}
local UnclaimedStyle: DayStyle = {}

local function extractStyle(slot: Frame | TextButton): DayStyle
	local posImg = slot:FindFirstChild("pos")
	local txt    = slot:FindFirstChild("TextLabel")

	local posColor: Color3? = nil
	local textColor: Color3? = nil

	if posImg and posImg:IsA("ImageLabel") then
		posColor = posImg.ImageColor3
	end
	if txt and txt:IsA("TextLabel") then
		textColor = txt.TextColor3
	end

	return {
		PosColor = posColor,
		TextColor = textColor,
	}
end

local function cacheStyles()
	local d1 = DaySlots[1]
	local d2 = DaySlots[2]

	if d1 then ClaimedStyle = extractStyle(d1) end
	if d2 then UnclaimedStyle = extractStyle(d2) end
end

----------------------------------------------------------------
-- STATE
----------------------------------------------------------------

local dailyState = {
	currentDay = 1,              -- NEXT day index (1..7) they will eventually claim
	alreadyClaimedToday = false, -- true if claim already done for this calendar day
	secondsUntilNextClaim = 0,   -- only meaningful when alreadyClaimedToday == true
}

----------------------------------------------------------------
-- RENDER HELPERS
----------------------------------------------------------------

local function applyClaimed(slot: Frame | TextButton)
	local posImg = slot:FindFirstChild("pos")
	local txt    = slot:FindFirstChild("TextLabel")

	if posImg and posImg:IsA("ImageLabel") and ClaimedStyle.PosColor then
		posImg.ImageColor3 = ClaimedStyle.PosColor
	end

	if txt and txt:IsA("TextLabel") then
		txt.Text = "Claimed!"
		if ClaimedStyle.TextColor then
			txt.TextColor3 = ClaimedStyle.TextColor
		end
	end
end

local function applyUnclaimedLabel(slot: Frame | TextButton, text: string)
	local posImg = slot:FindFirstChild("pos")
	local txt    = slot:FindFirstChild("TextLabel")

	if posImg and posImg:IsA("ImageLabel") and UnclaimedStyle.PosColor then
		posImg.ImageColor3 = UnclaimedStyle.PosColor
	end

	if txt and txt:IsA("TextLabel") then
		txt.Text = text
		if UnclaimedStyle.TextColor then
			txt.TextColor3 = UnclaimedStyle.TextColor
		end
	end
end

local function formatTime(secs: number): string
	secs = math.max(0, math.floor(secs + 0.5))
	local h = math.floor(secs / 3600)
	local m = math.floor((secs % 3600) / 60)
	local s = secs % 60
	return string.format("%02d:%02d:%02d", h, m, s)
end

-- Claimed days are ALWAYS 1..(currentDay-1), regardless of "alreadyClaimedToday".
-- "alreadyClaimedToday" just toggles if you can click again today.
local function refreshDailyUI()
	local currentDay = math.clamp(dailyState.currentDay, 1, 7)
	local lastClaimedDay = math.clamp(currentDay - 1, 0, 7)

	for i = 1, 7 do
		local slot = DaySlots[i]
		if slot then
			if i <= lastClaimedDay then
				applyClaimed(slot)
			else
				if i == 7 then
					applyUnclaimedLabel(slot, "Day 7")
				else
					applyUnclaimedLabel(slot, "Day " .. tostring(i))
				end
			end
		end
	end

	-- If they already claimed today, draw a countdown on the NEXT day (currentDay)
	if dailyState.alreadyClaimedToday and dailyState.secondsUntilNextClaim > 0 then
		local slot = DaySlots[currentDay]
		if slot then
			local label = slot:FindFirstChild("TextLabel")
			if label and label:IsA("TextLabel") then
				label.Text = formatTime(dailyState.secondsUntilNextClaim)
			end
		end
	end
end

----------------------------------------------------------------
-- NOTIFICATIONS
----------------------------------------------------------------

local function notify(msg: any)
	if msg == nil then return end
	local text = tostring(msg)
	if text == "" then return end

	if typeof(NotificationManager) == "table" and typeof(NotificationManager.show) == "function" then
		NotificationManager.show(text, "Normal")
	end
end

----------------------------------------------------------------
-- CLAIM LOGIC
----------------------------------------------------------------

local function tryClaimCurrentDay()
	local success, msg, newInfo = ClaimDailyRewardFn:InvokeServer()

	if newInfo and typeof(newInfo) == "table" then
		dailyState.currentDay            = newInfo.currentDay or dailyState.currentDay
		dailyState.alreadyClaimedToday   = newInfo.alreadyClaimedToday or false
		dailyState.secondsUntilNextClaim = newInfo.secondsUntilNextClaim or 0
	end

	refreshDailyUI()
	notify(msg)
end

local function hookDayClicks()
	for dayIndex, button in pairs(DayButtons) do
		button.MouseButton1Click:Connect(function()
			-- only allow clicking the NEXT day and only if you haven't claimed today
			local nextDayIndex   = dailyState.currentDay
			local canClaimToday  = not dailyState.alreadyClaimedToday

			if not canClaimToday then
				return
			end
			if dayIndex ~= nextDayIndex then
				return
			end

			tryClaimCurrentDay()
		end)
	end
end

----------------------------------------------------------------
-- PUBLIC API
----------------------------------------------------------------

function DailyRewardsHandler.Init()
	DailyRewardsFrame.Visible = false

	RewardsButton.MouseButton1Click:Connect(function()
		DailyRewardsFrame.Visible = not DailyRewardsFrame.Visible
	end)

	CloseButton.MouseButton1Click:Connect(function()
		DailyRewardsFrame.Visible = false
	end)

	cacheStyles()

	-- initial state from server
	local info = GetDailyRewardsStateFn:InvokeServer()
	if info and typeof(info) == "table" then
		dailyState.currentDay            = info.currentDay or 1
		dailyState.alreadyClaimedToday   = info.alreadyClaimedToday or false
		dailyState.secondsUntilNextClaim = info.secondsUntilNextClaim or 0
	end

	refreshDailyUI()
	hookDayClicks()

	-- simple client-side countdown for the timer text
	RunService.Heartbeat:Connect(function(dt)
		if dailyState.alreadyClaimedToday and dailyState.secondsUntilNextClaim > 0 then
			dailyState.secondsUntilNextClaim -= dt
			if dailyState.secondsUntilNextClaim < 0 then
				dailyState.secondsUntilNextClaim = 0
			end
			refreshDailyUI()
		end
	end)
end

return DailyRewardsHandler

---

--- ReplicatedStorage.Modules.MutationConfigurations (ModuleScript) ---
--!strict
-- MutationConfigurations
-- Multiplier applies to:
--  â€¢ ValuePerSecond (cage income)
--  â€¢ SellValue (when you add auto-sell later)

local MutationConfigurations = {
	Gold = {
		Multiplier = 2,
	},
	Diamond = {
		Multiplier = 3,
	},
	Rainbow = {
		Multiplier = 4,
	},
	Christmas = {
		Multiplier = 10,
	},
	Glitch = {
		Multiplier = 10,
	},
}

return MutationConfigurations

---

--- ReplicatedStorage.Modules.RebirthConfig (ModuleScript) ---
--!strict
-- ReplicatedStorage/Modules/RebirthConfig.lua

export type RebirthCfg = {
	RequiredCash: number,
	MoneyBonusPercent: number,
	LuckBonusPercent: number,
	UnlockCages: {number}?,
}

local RebirthConfig: {
	[number]: RebirthCfg,
	MaxRebirth: number,
} = {
	[1] = {
		RequiredCash      = 5_000_000,
		MoneyBonusPercent = 25,   -- +25% money
		LuckBonusPercent  = 25,   -- +25% luck
		UnlockCages       = nil,  -- none
	},

	[2] = {
		RequiredCash      = 25_000_000,
		MoneyBonusPercent = 25,   -- +25% money
		LuckBonusPercent  = 25,   -- +25% luck
		UnlockCages       = nil,  -- (keep empty for now or add {6} later)
	},

	[3] = {
		RequiredCash      = 100_000_000,
		MoneyBonusPercent = 0,
		LuckBonusPercent  = 25,   -- +50% luck
		UnlockCages       = { 6 }, -- â¬… Rebirth 3 unlocks Cage 6
	},

	[4] = {
		RequiredCash      = 250_000_000,
		MoneyBonusPercent = 0,
		LuckBonusPercent  = 50,   -- +50% luck
		UnlockCages       = { 7 }, --unlocks Cage 7
	},
}

RebirthConfig.MaxRebirth = 4

return RebirthConfig

---

--- ReplicatedStorage.Modules.LuckHelper (ModuleScript) ---
--!strict
-- ServerScriptService/Modules/LuckHelper.lua

local ReplicatedStorage   = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Players             = game:GetService("Players")

local PlayerController = require(ServerScriptService.Controllers:WaitForChild("PlayerController"))

local LuckHelper = {}

local function getProfile(player: Player)
	return PlayerController:GetProfile(player)
end

function LuckHelper.GetTotalLuckMultiplier(player: Player): number
	local profile = getProfile(player)
	if not profile then return 1 end

	local data = profile.Data

	-- From rebirths (already set by RebirthController)
	local rebirthLuck = data.RebirthLuckMultiplier or 1

	-- Gamepass luck (you wire this later, default 1)
	local passLuck = data.LuckGamepassMultiplier or 1

	-- Potion luck (you wire this later, default 1)
	local potionLuck = data.LuckPotionMultiplier or 1

	-- Server-wide luck (set as an attribute on ReplicatedStorage if you want)
	local serverLuck = (ReplicatedStorage:GetAttribute("ServerLuckMultiplier") :: number?) or 1

	return rebirthLuck * passLuck * potionLuck * serverLuck
end

function LuckHelper.Roll(player: Player, baseChance: number): boolean
	local mult = LuckHelper.GetTotalLuckMultiplier(player)
	local finalChance = baseChance * mult
	if finalChance >= 1 then
		return true
	end
	return math.random() < finalChance
end

return LuckHelper

---