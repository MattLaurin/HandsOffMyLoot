--- StarterPlayer.StarterPlayerScripts.ClientCrateHandler (LocalScript) ---
--!strict
-- Manages the client-side visual timer for placed crates.

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local crateGUITemplate = ReplicatedStorage.Templates:WaitForChild("CrateGUITemplate")

local activeCrateUpdaters = {}

local COUNTDOWN_STROKE_COLOR = Color3.fromRGB(50, 50, 50)
local READY_STROKE_COLOR = Color3.fromRGB(120, 78, 0)

local function formatTime(seconds: number): string
	if seconds < 0 then seconds = 0 end
	local hours = math.floor(seconds / 3600)
	local minutes = math.floor((seconds % 3600) / 60)
	local secs = seconds % 60
	return string.format("%02i:%02i:%02i", hours, minutes, secs)
end

local function setupCrate(crateModel: Model)
	-- ## ADDED ## Wait for the PrimaryPart to be loaded
	while not crateModel.PrimaryPart do
		task.wait()
	end

	local ownerId = crateModel:GetAttribute("OwnerId")
	if ownerId ~= player.UserId then return end

	local gui = crateGUITemplate:Clone()
	gui.Parent = crateModel.PrimaryPart

	local timerLabel = gui.TimerLabel
	local textStroke = timerLabel:FindFirstChild("Stroke")
	local textGradient = timerLabel:FindFirstChild("Gradient")

	activeCrateUpdaters[crateModel] = RunService.Heartbeat:Connect(function()
		local unlockTimestamp = crateModel:GetAttribute("UnlockTimestamp")
		if typeof(unlockTimestamp) ~= "number" then
			if activeCrateUpdaters[crateModel] then
				activeCrateUpdaters[crateModel]:Disconnect()
				activeCrateUpdaters[crateModel] = nil
			end
			return
		end

		local remaining = unlockTimestamp - os.time()

		if remaining > 0 then
			timerLabel.Text = "" .. formatTime(remaining)
			if textStroke then textStroke.Color = COUNTDOWN_STROKE_COLOR end
			if textGradient then textGradient.Enabled = false end
		else
			timerLabel.Text = "Ready!"
			if textStroke then textStroke.Color = READY_STROKE_COLOR end
			if textGradient then textGradient.Enabled = true end

			if activeCrateUpdaters[crateModel] then
				activeCrateUpdaters[crateModel]:Disconnect()
				activeCrateUpdaters[crateModel] = nil
			end
		end
	end)
end

local function cleanupCrate(crateModel: Model)
	if activeCrateUpdaters[crateModel] then
		activeCrateUpdaters[crateModel]:Disconnect()
		activeCrateUpdaters[crateModel] = nil
	end
end

task.spawn(function()
	local playerPlot: Model?
	while not playerPlot do
		local plotNum = player:GetAttribute("PlotNumber")
		if plotNum then playerPlot = Workspace.Plots:FindFirstChild("Plot"..tostring(plotNum)) end
		task.wait(1)
	end

	local crateFolder = playerPlot:WaitForChild("Crate")
	for _, child in ipairs(crateFolder:GetChildren()) do
		if child:IsA("Model") then setupCrate(child) end
	end
	crateFolder.ChildAdded:Connect(function(child)
		if child:IsA("Model") then setupCrate(child) end
	end)
	crateFolder.ChildRemoved:Connect(cleanupCrate)
end)
---

--- StarterPlayer.StarterPlayerScripts.ClientFXController (LocalScript) ---
local CollectionService = game:GetService("CollectionService")

local TweenService = game:GetService("TweenService")

local RunService = game:GetService("RunService")

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Players = game:GetService("Players")

local UserInputService = game:GetService("UserInputService")

local Workspace = game:GetService("Workspace")

local Debris = game:GetService("Debris")


local localPlayer = Players.LocalPlayer

local playerGui = localPlayer:WaitForChild("PlayerGui")


local ItemConfigurations = require(ReplicatedStorage.Modules.ItemConfigurations)

local NumberFormatter = require(ReplicatedStorage.Modules.NumberFormatter)


local shineTemplate = ReplicatedStorage.Templates:WaitForChild("ShineEffectTemplate")


local Events = ReplicatedStorage:WaitForChild("Events")

local Functions = ReplicatedStorage:WaitForChild("Functions")

local CashUpdated = Events:WaitForChild("CashUpdated")

local GetPlayerCash = Functions:WaitForChild("GetPlayerCash")


local activeHoverTweens = {}

local activeShineThreads = {}

local sunburstObjects = {}


local buttonStates = {}

local partButtonStates = {}


local function getUIScale(gui)

	local s = gui:FindFirstChildOfClass("UIScale")

	if not s then

		s = Instance.new("UIScale")

		s.Scale = 1

		s.Parent = gui

	end

	return s

end


local SKIP_ROBUX_STORE_BUTTON_FX = false

local function isInsideRobuxStore(inst)

	local p = inst

	while p and not p:IsA("ScreenGui") do p = p.Parent end

	return p ~= nil and p.Name == "RobuxStore"

end


local HOVER_TWEEN_INFO = TweenInfo.new(0.2, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)

local CLICK_TWEEN_INFO = TweenInfo.new(0.1, Enum.EasingStyle.Quint, Enum.EasingDirection.InOut)

local HOVER_SCALE = 1.05

local CLICK_SCALE = 0.95


local function getButtonColor(button)

	if button:IsA("TextButton") then return button.BackgroundColor3 end

	if button:IsA("ImageButton") then return button.ImageColor3 end

	return nil

end


local function tweenColor(button, tweenInfo, color)

	local prop = button:IsA("TextButton") and "BackgroundColor3" or "ImageColor3"

	TweenService:Create(button, tweenInfo, {[prop] = color}):Play()

end


local function applyButtonAnimation(button)

	if buttonStates[button] then return end

	if SKIP_ROBUX_STORE_BUTTON_FX and isInsideRobuxStore(button) then return end


	local scaleObj = getUIScale(button)

	buttonStates[button] = {

		originalSize = button.Size, 

		originalColor = getButtonColor(button),

	}


	button.MouseEnter:Connect(function()

		TweenService:Create(scaleObj, HOVER_TWEEN_INFO, {Scale = HOVER_SCALE}):Play()

		local color = buttonStates[button].originalColor

		if color then tweenColor(button, HOVER_TWEEN_INFO, color:Lerp(Color3.new(1,1,1), 0.1)) end

	end)


	button.MouseLeave:Connect(function()

		TweenService:Create(scaleObj, HOVER_TWEEN_INFO, {Scale = 1}):Play()

		local color = buttonStates[button].originalColor

		if color then tweenColor(button, HOVER_TWEEN_INFO, color) end

	end)


	button.MouseButton1Down:Connect(function()

		TweenService:Create(scaleObj, CLICK_TWEEN_INFO, {Scale = CLICK_SCALE}):Play()

		local color = buttonStates[button].originalColor

		if color then tweenColor(button, CLICK_TWEEN_INFO, color:Lerp(Color3.new(0,0,0), 0.2)) end

	end)


	button.MouseButton1Up:Connect(function()

		TweenService:Create(scaleObj, CLICK_TWEEN_INFO, {Scale = HOVER_SCALE}):Play()

		local color = buttonStates[button].originalColor

		if color then tweenColor(button, CLICK_TWEEN_INFO, color:Lerp(Color3.new(1,1,1), 0.1)) end

	end)

end


local SUNBURST_ROTATION_SPEED = 20

local function applySunburstEffect(guiObject)

	sunburstObjects[guiObject] = true

end


RunService.Heartbeat:Connect(function(dt)

	for guiObject, _ in pairs(sunburstObjects) do

		if guiObject.Parent then

			guiObject.Rotation += SUNBURST_ROTATION_SPEED * dt

		else

			sunburstObjects[guiObject] = nil

		end

	end

end)


local HOVER_OFFSET = 5

local HOVER_DURATION = 1.5

local HOVER_TWEEN_INFO_EFFECT = TweenInfo.new(HOVER_DURATION / 2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)


local function applyHoverEffect(guiObject)

	local originalPosition = guiObject.Position

	local targetPositionUp = originalPosition + UDim2.fromOffset(0, -HOVER_OFFSET)

	local tweenUp = TweenService:Create(guiObject, HOVER_TWEEN_INFO_EFFECT, {Position = targetPositionUp})

	local tweenDown = TweenService:Create(guiObject, HOVER_TWEEN_INFO_EFFECT, {Position = originalPosition})


	activeHoverTweens[guiObject] = {tweenUp, tweenDown}


	task.spawn(function()

		while guiObject.Parent do

			tweenUp:Play()

			tweenUp.Completed:Wait()

			if not guiObject.Parent then break end

			tweenDown:Play()

			tweenDown.Completed:Wait()

		end

		if activeHoverTweens[guiObject] then

			for _, tween in ipairs(activeHoverTweens[guiObject]) do tween:Cancel() end

			activeHoverTweens[guiObject] = nil

		end

	end)

end


local SHINE_MIN_DELAY, SHINE_MAX_DELAY = 1, 4

local SHINE_FADE_IN_TIME, SHINE_FADE_OUT_TIME = 0.3, 0.7


local function applyShineEffect(guiObject)

	activeShineThreads[guiObject] = task.spawn(function()

		while guiObject.Parent do

			task.wait(math.random() * (SHINE_MAX_DELAY - SHINE_MIN_DELAY) + SHINE_MIN_DELAY)

			if not guiObject.Parent then break end


			local newShine = shineTemplate:Clone()

			newShine.Position = UDim2.fromScale(math.random(), math.random())

			newShine.ImageTransparency = 1

			newShine.Rotation = math.random(-45, 45)

			newShine.Parent = guiObject


			local fadeIn = TweenService:Create(newShine, TweenInfo.new(SHINE_FADE_IN_TIME), {ImageTransparency = 0})

			local fadeOut = TweenService:Create(newShine, TweenInfo.new(SHINE_FADE_OUT_TIME), {ImageTransparency = 1})


			fadeIn:Play()

			fadeIn.Completed:Wait()

			if not newShine.Parent then break end

			fadeOut:Play()

			fadeOut.Completed:Wait()

			newShine:Destroy()

		end

	end)

end


local PRESS_DEPTH = 0.4

local PRESS_TWEEN_INFO = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

local POP_UP_TWEEN_INFO = TweenInfo.new(1, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out)


local function applyPressEffect(part)

	if partButtonStates[part] then return end


	local originalPosition = part.Position

	partButtonStates[part] = { Debounce = false, Connections = {} }


	local conn = part.Touched:Connect(function(hit)

		if partButtonStates[part].Debounce then return end

		if not (localPlayer.Character and hit:IsDescendantOf(localPlayer.Character)) then return end


		partButtonStates[part].Debounce = true

		local press = TweenService:Create(part, PRESS_TWEEN_INFO, { Position = originalPosition - Vector3.new(0, PRESS_DEPTH, 0) })

		press:Play()

		press.Completed:Wait()


		local popUp = TweenService:Create(part, POP_UP_TWEEN_INFO, { Position = originalPosition })

		popUp:Play()

		popUp.Completed:Wait()


		partButtonStates[part].Debounce = false

	end)


	table.insert(partButtonStates[part].Connections, conn)

end


local activeModelHoverTweens = {}

local MODEL_HOVER_OFFSET = 0.5

local MODEL_HOVER_DURATION = 2

local MODEL_HOVER_TWEEN_INFO = TweenInfo.new(MODEL_HOVER_DURATION / 2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)


local function applyModelHoverEffect(model)

	task.wait(1)


	if not model:IsA("Model") or not model.Parent or not model.PrimaryPart then

		return

	end


	local primaryPart = model.PrimaryPart

	local originalCFrame = primaryPart.CFrame

	local targetCFrameUp = originalCFrame * CFrame.new(0, MODEL_HOVER_OFFSET, 0)


	local tweenUp = TweenService:Create(primaryPart, MODEL_HOVER_TWEEN_INFO, {CFrame = targetCFrameUp})

	local tweenDown = TweenService:Create(primaryPart, MODEL_HOVER_TWEEN_INFO, {CFrame = originalCFrame})


	activeModelHoverTweens[model] = {tweenUp, tweenDown}


	task.spawn(function()

		while model.Parent do

			tweenUp:Play()

			tweenUp.Completed:Wait()

			if not model.Parent then break end

			tweenDown:Play()

			tweenDown.Completed:Wait()

		end

		if activeModelHoverTweens[model] then

			for _, tween in ipairs(activeModelHoverTweens[model]) do tween:Cancel() end

			activeModelHoverTweens[model] = nil

		end

	end)


	local function cleanupModelHoverEffect(model)

		if activeModelHoverTweens[model] then

			for _, tween in ipairs(activeModelHoverTweens[model]) do tween:Cancel() end

			activeModelHoverTweens[model] = nil

		end

	end


	local cashAmountLabel = playerGui:WaitForChild("GUI"):WaitForChild("HUD"):WaitForChild("Cash"):WaitForChild("Amount")

	local oldCashValue = 0

	local cashAnimConnection


	local function animateCashIncrease(startValue, endValue)

		local duration, startTime, delta = 0.5, os.clock(), endValue - startValue

		if cashAnimConnection then cashAnimConnection:Disconnect() end

		cashAnimConnection = RunService.Heartbeat:Connect(function()

			local progress = math.min((os.clock() - startTime) / duration, 1)

			local alpha = TweenService:GetValue(progress, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)

			cashAmountLabel.Text = NumberFormatter.formatNumber(math.floor(startValue + delta * alpha), "$")

			if progress >= 1 then

				if cashAnimConnection then cashAnimConnection:Disconnect() cashAnimConnection = nil end

			end

		end)

	end


	local function onCashValueReceived(newValue)

		newValue = tonumber(newValue) or 0

		if newValue > oldCashValue then

			animateCashIncrease(oldCashValue, newValue)

		else

			cashAmountLabel.Text = NumberFormatter.formatNumber(newValue, "$")

		end

		oldCashValue = newValue

	end


	task.spawn(function()


		CashUpdated.OnClientEvent:Connect(onCashValueReceived)


		local success, initialCash = pcall(GetPlayerCash.InvokeServer, GetPlayerCash)


		if success and typeof(initialCash) == "number" then

			onCashValueReceived(initialCash)

		else

			warn("[ClientFXController] Failed to get initial cash from server.")

			onCashValueReceived(0)

		end

	end)


	local itemDamageData = {}


	local function updateItemColor(itemModel)

		local data = itemDamageData[itemModel]

		local config = ItemConfigurations[itemModel.Name]

		local currentHealth = itemModel:GetAttribute("Health")

		if not (config and config.Health and typeof(currentHealth) == "number") then return end


		local healthPercent = math.clamp(currentHealth / config.Health, 0, 1)

		local lerpAlpha = (1 - healthPercent) * 0.8

		for part, originalColor in pairs(data.originalColors) do

			if part.Parent then

				part.Color = originalColor:Lerp(Color3.new(0, 0, 0), lerpAlpha)

			end

		end

	end


	local function setupItemVFX(itemModel)

		if itemDamageData[itemModel] or not itemModel:GetAttribute("IsPlacedItem") then return end

		local config = ItemConfigurations[itemModel.Name]

		if not (itemModel:IsA("Model") and config and config.Health) then return end


		local data = { originalColors = {}, healthConnection = nil }

		for _, descendant in ipairs(itemModel:GetDescendants()) do

			if descendant:IsA("BasePart") then

				data.originalColors[descendant] = descendant.Color

			end

		end

		data.healthConnection = itemModel:GetAttributeChangedSignal("Health"):Connect(function()

			updateItemColor(itemModel)

		end)

		itemDamageData[itemModel] = data

		updateItemColor(itemModel)

	end


	local function cleanupItemVFX(itemModel)

		local data = itemDamageData[itemModel]

		if data then

			if data.healthConnection then data.healthConnection:Disconnect() end

			itemDamageData[itemModel] = nil

		end

	end


	task.spawn(function()

		local playerPlot

		while not playerPlot do

			for _, plot in ipairs(Workspace.Plots:GetChildren()) do

				if plot:IsA("Model") and plot:GetAttribute("OwnerId") == localPlayer.UserId then

					playerPlot = plot

					break

				end

			end

			if not playerPlot then task.wait(1) end

		end


		for _, child in ipairs(playerPlot:GetChildren()) do

			setupItemVFX(child)

		end

		playerPlot.ChildAdded:Connect(setupItemVFX)

		playerPlot.ChildRemoved:Connect(cleanupItemVFX)

	end)


	local turretFiredEvent = ReplicatedStorage.Events:WaitForChild("TurretFiredFX")

	local effectsFolder = Workspace:FindFirstChild("Effects") or Instance.new("Folder", Workspace)

	effectsFolder.Name = "Effects"


	turretFiredEvent.OnClientEvent:Connect(function(turretModel, startPos, endPos)

		local distance = (startPos - endPos).Magnitude

		local tracer = Instance.new("Part")

		tracer.Anchored, tracer.CanCollide, tracer.CanTouch, tracer.CastShadow = true, false, false, false

		tracer.Color, tracer.Material = Color3.new(1, 1, 0), Enum.Material.Neon

		tracer.Size = Vector3.new(0.1, 0.1, distance)

		tracer.CFrame = CFrame.lookAt(startPos, endPos) * CFrame.new(0, 0, -distance / 2)

		tracer.Parent = effectsFolder

		Debris:AddItem(tracer, 0.1)


		if turretModel then

			local fireSound = turretModel:FindFirstChild("FireSound", true)

			if fireSound and fireSound:IsA("Sound") then fireSound:Play() end

		end

	end)


	local highlightZombieEvent = ReplicatedStorage.Events:WaitForChild("HighlightZombie")

	highlightZombieEvent.OnClientEvent:Connect(function(zombieModel)

		if not zombieModel or not zombieModel.Parent then return end

		local highlight = Instance.new("Highlight")

		highlight.FillColor = Color3.fromRGB(255, 0, 0)

		highlight.FillTransparency = 0.5

		highlight.OutlineTransparency = 1

		highlight.Parent = zombieModel

		Debris:AddItem(highlight, 0.2)

	end)


	local function setupTag(tagName, applyFn, cleanupFn)

		for _, instance in ipairs(CollectionService:GetTagged(tagName)) do

			task.spawn(applyFn, instance)

		end

		CollectionService:GetInstanceAddedSignal(tagName):Connect(applyFn)

		CollectionService:GetInstanceRemovedSignal(tagName):Connect(cleanupFn)

	end


	setupTag("ButtonAnimation", applyButtonAnimation, function(inst) buttonStates[inst] = nil end)

	setupTag("SunburstEffect", applySunburstEffect, function(inst) sunburstObjects[inst] = nil end)

	setupTag("HoverEffect", applyHoverEffect, function(inst)

		if activeHoverTweens[inst] then

			for _,t in pairs(activeHoverTweens[inst]) do t:Cancel() end

			activeHoverTweens[inst] = nil

		end

	end)

	setupTag("ShineEffect", applyShineEffect, function(inst)

		if activeShineThreads[inst] then task.cancel(activeShineThreads[inst]) activeShineThreads[inst] = nil end

	end)

	setupTag("PartButton", applyPressEffect, function(inst)

		if partButtonStates[inst] then

			for _,c in pairs(partButtonStates[inst].Connections) do c:Disconnect() end

			partButtonStates[inst] = nil

		end

	end)

	setupTag("ModelHoverEffect", applyModelHoverEffect, cleanupModelHoverEffect)

end 
---

--- StarterPlayer.StarterPlayerScripts.CageBillboardHandler (LocalScript) ---
--!strict

local Players   = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer

local RARITY_COLORS: {[string]: Color3} = {
	Common    = Color3.fromRGB(200, 200, 200),
	Rare      = Color3.fromRGB(80, 170, 255),
	Epic      = Color3.fromRGB(190, 90, 255),
	Legendary = Color3.fromRGB(255, 200, 80),
	Boss      = Color3.fromRGB(255, 80, 80),
	Secret    = Color3.fromRGB(80, 255, 200),
}

local function getPlotForPlayer(): Model?
	local plotsFolder = Workspace:FindFirstChild("Plots")
	if not plotsFolder then return nil end

	local plotNum = player:GetAttribute("PlotNumber")
	if plotNum then
		local plot = plotsFolder:FindFirstChild("Plot" .. tostring(plotNum))
		if plot and plot:IsA("Model") then return plot end
	end

	for _, plot in ipairs(plotsFolder:GetChildren()) do
		if plot:IsA("Model") and plot:GetAttribute("OwnerId") == player.UserId then
			return plot
		end
	end
	return nil
end

local function ensureBillboard(cage: Model): BillboardGui
	-- find the part we want to stick the label to
	local attach = cage:FindFirstChild("EnemyPlacementBillboard", true)
	if attach and not attach:IsA("BasePart") then
		attach = nil
	end

	-- find any existing CageLabel anywhere under this cage
	local billboard = cage:FindFirstChild("CageLabel", true) :: BillboardGui?
	if not billboard then
		billboard = Instance.new("BillboardGui")
		billboard.Name = "CageLabel"
		billboard.Size = UDim2.new(0, 520, 0, 260)
		billboard.MaxDistance = 50
		billboard.LightInfluence = 0
		billboard.AlwaysOnTop = true
		billboard.Enabled = false

		local label = Instance.new("TextLabel")
		label.Name = "Text"
		label.Size = UDim2.new(1, 0, 1, 0)
		label.BackgroundTransparency = 1
		label.TextColor3 = Color3.new(1, 1, 1)
		label.TextStrokeTransparency = 0
		label.Font = Enum.Font.GothamBlack
		label.TextSize = 32
		label.TextWrapped = true
		label.RichText = true
		label.Parent = billboard
	end

	-- if we have the EnemyPlacementBillboard part, parent + adorn to it
	if attach and attach:IsA("BasePart") then
		billboard.Parent = attach
		billboard.Adornee = attach
		billboard.StudsOffsetWorldSpace = Vector3.new(0, 0, 0)
	else
		-- fallback: keep it on the cage root (old behaviour)
		billboard.Parent = cage
		billboard.Adornee = nil
	end

	return billboard
end

local function updateBillboard(cage: Model)
	local billboard = ensureBillboard(cage)
	local textLabel = billboard:FindFirstChild("Text") :: TextLabel?
	if not textLabel then return end

	local unlocked = cage:GetAttribute("Unlocked") == true
	if not unlocked then
		billboard.Enabled = false
		return
	end

	billboard.Enabled = true

	local enemyId   = cage:GetAttribute("EnemyId") :: string?
	local display   = cage:GetAttribute("DisplayName") :: string?
	local rarity    = cage:GetAttribute("Rarity") :: string?
	local mutation  = cage:GetAttribute("Mutation") :: string?
	local banked    = cage:GetAttribute("Banked") :: number? or 0
	local lastOff   = cage:GetAttribute("LastOffline") :: number? or 0
	local vps       = cage:GetAttribute("ValuePerSecond") :: number? or 0
	local mult      = cage:GetAttribute("VpsMultiplier") :: number? or 1

	if not enemyId or enemyId == "" then
		textLabel.Text = "<b><font size='32'>Empty Cage</font></b>"
		textLabel.TextColor3 = Color3.new(1, 1, 1)
		return
	end

	local nameText     = display or enemyId
	local rarityText   = rarity or "Common"
	local mutationText = (mutation and mutation ~= "") and mutation or "None"

	local bankedText = string.format("Banked: %d", math.floor(banked + 0.5))
	local offlineText = ""
	if lastOff and lastOff > 0 then
		offlineText = string.format("(+%d offline)", math.floor(lastOff + 0.5))
	end

	local multText = ""
	if mult and mult > 1.001 then
		multText = string.format(" (x%.2f)", mult)
	end
	local vpsText = string.format("Value/s: %.0f%s", vps or 0, multText)

	textLabel.Text = string.format(
		"<b><font size='40'>%s</font></b>\n" ..
			"<font size='30'>Rarity: %s</font>\n" ..
			"<font size='30'>Mutation: %s</font>\n" ..
			"<font size='30'>%s</font>\n" ..
			"<font size='28'>%s</font>\n" ..
			"<font size='30'>%s</font>",
		nameText, rarityText, mutationText, bankedText, offlineText, vpsText
	)

	local rarityColor = RARITY_COLORS[rarityText]
	if rarityColor then
		textLabel.TextColor3 = rarityColor
	else
		textLabel.TextColor3 = Color3.new(1, 1, 1)
	end
end

local function hookCage(cage: Model)
	ensureBillboard(cage)
	updateBillboard(cage)

	local watched = {
		"Unlocked",
		"EnemyId",
		"DisplayName",
		"Rarity",
		"Mutation",
		"Banked",
		"LastOffline",
		"ValuePerSecond",
		"VpsMultiplier",
	}
	for _, attr in ipairs(watched) do
		cage:GetAttributeChangedSignal(attr):Connect(function()
			updateBillboard(cage)
		end)
	end
end

local initialized = false

local function tryInit()
	if initialized then return end
	local plot = getPlotForPlayer()
	if not plot then return end

	local cageSystem = plot:FindFirstChild("CageSystem")
	if not cageSystem then return end

	for _, cage in ipairs(cageSystem:GetChildren()) do
		if cage:IsA("Model") and cage.Name:match("^Cage%d+$") then
			hookCage(cage)
		end
	end

	initialized = true
end

task.spawn(function()
	while not initialized do
		tryInit()
		task.wait(0.5)
	end
end)

---

--- StarterPlayer.StarterPlayerScripts.DisableResetButton (LocalScript) ---
while wait() do
	local ok, err = pcall(function()
		game.StarterGui:SetCore("ResetButtonCallback", false)
	end)
	if ok then break end
end
---

--- StarterPlayer.StarterPlayerScripts.CagePromptHandler (LocalScript) ---
--!strict

local Players   = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer

local function getPlotForPlayer(): Model?
	local plotsFolder = Workspace:FindFirstChild("Plots")
	if not plotsFolder then return nil end

	local plotNum = player:GetAttribute("PlotNumber")
	if plotNum then
		local plot = plotsFolder:FindFirstChild("Plot" .. tostring(plotNum))
		if plot and plot:IsA("Model") then return plot end
	end

	for _, plot in ipairs(plotsFolder:GetChildren()) do
		if plot:IsA("Model") and plot:GetAttribute("OwnerId") == player.UserId then
			return plot
		end
	end
	return nil
end

local function updatePromptForCage(cage: Model, prompt: ProximityPrompt)
	local unlocked = cage:GetAttribute("Unlocked") == true
	if not unlocked then
		prompt.Enabled = false
		return
	end

	local enemyId  = cage:GetAttribute("EnemyId") :: string?
	local display  = cage:GetAttribute("DisplayName") :: string?
	local hasEnemy = enemyId ~= nil and enemyId ~= ""

	local selectedName = player:GetAttribute("SelectedEnemyDisplayName") :: string?
	local selectedId   = player:GetAttribute("SelectedEnemyId") :: string?

	if hasEnemy then
		local nameText = display or enemyId or "Enemy"
		prompt.ObjectText = "Cage"
		prompt.ActionText = "Remove " .. nameText
		prompt.Enabled = true
	else
		if selectedId and selectedId ~= "" then
			local nameText = selectedName or "Enemy"
			prompt.ObjectText = "Cage"
			prompt.ActionText = "Place " .. nameText
			prompt.Enabled = true
		else
			prompt.ObjectText = "Empty Cage"
			prompt.ActionText = "Place Enemy"
			prompt.Enabled = false
		end
	end
end

local function hookCage(cage: Model)
	local prompt = cage:FindFirstChild("CagePrompt", true) :: ProximityPrompt?
	if not prompt then return end

	local function refresh()
		updatePromptForCage(cage, prompt)
	end

	cage:GetAttributeChangedSignal("Unlocked"):Connect(refresh)
	cage:GetAttributeChangedSignal("EnemyId"):Connect(refresh)
	cage:GetAttributeChangedSignal("DisplayName"):Connect(refresh)
	player:GetAttributeChangedSignal("SelectedEnemyId"):Connect(refresh)
	player:GetAttributeChangedSignal("SelectedEnemyDisplayName"):Connect(refresh)

	refresh()
end

local initialized = false

local function tryInit()
	if initialized then return end

	local plot = getPlotForPlayer()
	if not plot then return end

	local cageSystem = plot:FindFirstChild("CageSystem")
	if not cageSystem then return end

	for _, cage in ipairs(cageSystem:GetChildren()) do
		if cage:IsA("Model") and cage.Name:match("^Cage%d+$") then
			hookCage(cage)
		end
	end

	initialized = true
end

task.spawn(function()
	while not initialized do
		tryInit()
		task.wait(0.5)
	end
end)

---

--- StarterPlayer.StarterPlayerScripts.HUDButtons (LocalScript) ---
--!strict
-- This script manages HUD button interactions, visuals, and auto equip/unequip logic.

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local ContextActionService = game:GetService("ContextActionService")
local MarketplaceService = game:GetService("MarketplaceService") -- ADDED

-- Modules
local FrameManager = require(ReplicatedStorage.Modules.FrameManager)
local PlacementHandler = require(ReplicatedStorage.Modules.PlacementHandler)
local WeaponConfigurations = require(ReplicatedStorage.Modules.WeaponConfigurations)

-- Player and UI
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local guiRoot = playerGui:WaitForChild("GUI")
local hudRoot = guiRoot:WaitForChild("HUD")

local bottomHud = hudRoot:WaitForChild("Bottom")
local inventoryButton = bottomHud:WaitForChild("Inventory")
local deleteButton = bottomHud:WaitForChild("Delete")
local weaponsButton = bottomHud:WaitForChild("Weapons")
local weaponsButtonImage = weaponsButton:WaitForChild("Image")


local inventoryDesign = inventoryButton:WaitForChild("Design")
local inventoryStroke = inventoryDesign:WaitForChild("Stroke")
local deleteDesign = deleteButton:WaitForChild("Design")
local deleteStroke = deleteDesign:WaitForChild("Stroke")
local weaponsDesign = weaponsButton:WaitForChild("Design")
local weaponsStroke = weaponsDesign:WaitForChild("Stroke")

-- Events
local unequipWeaponRequest = ReplicatedStorage.Events:WaitForChild("UnequipWeaponRequest")
local equipLastWeaponRequest = ReplicatedStorage.Events:WaitForChild("EquipLastWeaponRequest")

-- State Tracking
local wasInUIMode = false

-- Color Definitions
local SELECTED_BG_COLOR = Color3.fromRGB(0, 255, 0)
local SELECTED_STROKE_COLOR = Color3.fromRGB(0, 255, 0)
local DEFAULT_BG_COLOR = Color3.fromRGB(0, 0, 0)
local DEFAULT_STROKE_COLOR = Color3.fromRGB(50, 50, 50)

-- ===== helpers =====
local function hudActive(): boolean
	return bottomHud.Visible == true
end

-- ========== Unified actions used by buttons & hotkeys ==========
local function toggleInventoryPlacement()
	if not hudActive() then return end
	unequipWeaponRequest:FireServer()
	PlacementHandler:ExitAllModes()
	FrameManager.close("InventoryTwo")
	if FrameManager.getOpenFrameName() == "Inventory" then
		FrameManager.close("Inventory")
	else
		FrameManager.open("Inventory")
	end
end

local function toggleWeapons()
	if not hudActive() then return end
	PlacementHandler:ExitAllModes()
	FrameManager.close("Inventory")
	if FrameManager.getOpenFrameName() == "InventoryTwo" then
		FrameManager.close("InventoryTwo")
	else
		FrameManager.open("InventoryTwo")
	end
end

local function toggleDeleteMode()
	if not hudActive() then return end
	unequipWeaponRequest:FireServer()
	FrameManager.close("Inventory")
	FrameManager.close("InventoryTwo")
	PlacementHandler:EnterDeleteMode()
end


-- ========== Button wiring ==========
inventoryButton.MouseButton1Click:Connect(toggleInventoryPlacement)
weaponsButton.MouseButton1Click:Connect(toggleWeapons)
deleteButton.MouseButton1Click:Connect(toggleDeleteMode)

-- If any inventory panel closes, kill placement state so we don't leave a ghost active.
FrameManager.onFrameClosed(function(frameName)
	if frameName == "Inventory" or frameName == "InventoryTwo" then
		PlacementHandler:ExitAllModes()
	end
end)

-- ========== 1/2/3 Hotkeys (mirror the buttons exactly) ==========
ContextActionService:BindActionAtPriority(
	"HK_Placement",
	function(_, state)
		if state ~= Enum.UserInputState.Begin then return Enum.ContextActionResult.Pass end
		if not hudActive() then return Enum.ContextActionResult.Pass end
		toggleInventoryPlacement()
		return Enum.ContextActionResult.Sink
	end,
	false,
	Enum.ContextActionPriority.High.Value,
	Enum.KeyCode.One
)

ContextActionService:BindActionAtPriority(
	"HK_Delete",
	function(_, state)
		if state ~= Enum.UserInputState.Begin then return Enum.ContextActionResult.Pass end
		if not hudActive() then return Enum.ContextActionResult.Pass end
		toggleDeleteMode()
		return Enum.ContextActionResult.Sink
	end,
	false,
	Enum.ContextActionPriority.High.Value,
	Enum.KeyCode.Two
)

ContextActionService:BindActionAtPriority(
	"HK_Weapons",
	function(_, state)
		if state ~= Enum.UserInputState.Begin then return Enum.ContextActionResult.Pass end
		if not hudActive() then return Enum.ContextActionResult.Pass end
		toggleWeapons()
		return Enum.ContextActionResult.Sink
	end,
	false,
	Enum.ContextActionPriority.High.Value,
	Enum.KeyCode.Three
)

-- Enable/disable hotkeys when the HUD shows/hides
local function updateHotkeysEnabled()
	local enabled = hudActive()
	pcall(function() ContextActionService:SetBindEnabled("HK_Placement", enabled) end)
	pcall(function() ContextActionService:SetBindEnabled("HK_Delete", enabled) end)
	pcall(function() ContextActionService:SetBindEnabled("HK_Weapons", enabled) end)
end
bottomHud:GetPropertyChangedSignal("Visible"):Connect(updateHotkeysEnabled)
updateHotkeysEnabled()

-- ========== Weapon icon preview ==========
local function updateWeaponsButtonImage()
	local weaponName = player:GetAttribute("LastEquippedWeapon")
	if typeof(weaponName) == "string" then
		local weaponConfig = WeaponConfigurations.Weapons[weaponName]
		if weaponConfig and weaponConfig.ImageId then
			weaponsButtonImage.Image = weaponConfig.ImageId
			weaponsButtonImage.ImageTransparency = 0
			return
		end
	end
	weaponsButtonImage.ImageTransparency = 1
end
player:GetAttributeChangedSignal("LastEquippedWeapon"):Connect(updateWeaponsButtonImage)
updateWeaponsButtonImage()

-- ========== HUD visuals + auto (re)equip ==========
RunService.Heartbeat:Connect(function()
	local openFrameName = FrameManager.getOpenFrameName()
	local isDeleteActive = PlacementHandler.State.isDeleteMode

	-- Inventory
	if openFrameName == "Inventory" then
		inventoryDesign.BackgroundColor3 = SELECTED_BG_COLOR
		inventoryStroke.Color = SELECTED_STROKE_COLOR
	else
		inventoryDesign.BackgroundColor3 = DEFAULT_BG_COLOR
		inventoryStroke.Color = DEFAULT_STROKE_COLOR
	end

	-- Weapons
	if openFrameName == "InventoryTwo" then
		weaponsDesign.BackgroundColor3 = SELECTED_BG_COLOR
		weaponsStroke.Color = SELECTED_STROKE_COLOR
	else
		weaponsDesign.BackgroundColor3 = DEFAULT_BG_COLOR
		weaponsStroke.Color = DEFAULT_STROKE_COLOR
	end

	-- Delete
	if isDeleteActive then
		deleteDesign.BackgroundColor3 = SELECTED_BG_COLOR
		deleteStroke.Color = SELECTED_STROKE_COLOR
	else
		deleteDesign.BackgroundColor3 = DEFAULT_BG_COLOR
		deleteStroke.Color = DEFAULT_STROKE_COLOR
	end

	-- Auto (re)equip last weapon when leaving UI/delete modes
	local isCurrentlyInUIMode = (openFrameName == "Inventory") or (openFrameName == "InventoryTwo") or isDeleteActive
	if not isCurrentlyInUIMode and wasInUIMode then
		equipLastWeaponRequest:FireServer()
	end
	wasInUIMode = isCurrentlyInUIMode
end)

-- On join: if we're not in any UI/delete, re-equip the last weapon
task.wait(1)
do
	local openFrameName = FrameManager.getOpenFrameName()
	local isDeleteActive = PlacementHandler.State.isDeleteMode
	if not ((openFrameName == "Inventory") or (openFrameName == "InventoryTwo") or isDeleteActive) then
		equipLastWeaponRequest:FireServer()
	end
end

---

--- StarterPlayer.StarterPlayerScripts.HealthUIController (LocalScript) ---
--!strict
-- LOCATION: StarterPlayerScripts/HealthUIController.lua
-- DESCRIPTION: Manages both the Plot Health and Boss Health bars on the player's HUD.

-- Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- ## MODIFIED ## Use WaitForChild to safely load modules
local Modules = ReplicatedStorage:WaitForChild("Modules")
local FrameManager = require(Modules:WaitForChild("FrameManager"))
local ModelProgression = require(Modules:WaitForChild("ModelProgression"))

-- Player and UI References
local localPlayer = Players.LocalPlayer
local playerGui = localPlayer:WaitForChild("PlayerGui")
local hud = playerGui:WaitForChild("GUI"):WaitForChild("HUD")

-- Events
local WaveStateChangedEvent = ReplicatedStorage.Events:WaitForChild("WaveStateChanged")
local UpdateProtectionModelFX = ReplicatedStorage.Events:WaitForChild("UpdateProtectionModelFX")
local BossWaveStarted = ReplicatedStorage.Events:WaitForChild("BossWaveStarted")
local BossWaveEnded = ReplicatedStorage.Events:WaitForChild("BossWaveEnded")

-------------------------------------------------------------------
-- ## PLOT HEALTH UI ##
-------------------------------------------------------------------

local plotHealthFrame = hud:WaitForChild("PlotHealth")
local plotProgressBar = plotHealthFrame:WaitForChild("Progress")
local plotTextLabel = plotHealthFrame:WaitForChild("Text")
local plotModelImage = plotHealthFrame:WaitForChild("Image")
local plotNextLabel = plotHealthFrame:WaitForChild("Next")
local bottomFrame = hud:WaitForChild("Bottom")

local plotHealthConnection: RBXScriptConnection?
local plotHealthPart: BasePart?
local plotMaxHealth = 100

local function updateNextUnlockLabel(currentModelIndex: number)
	local nextIndex = currentModelIndex + 1
	local nextModelData = ModelProgression[nextIndex]

	if nextModelData and nextModelData.WaveRequirement then
		plotNextLabel.Text = `Bigger stack of Gold at Wave {nextModelData.WaveRequirement}`
		plotNextLabel.Visible = true
	else
		-- This happens if the player has unlocked all models
		plotNextLabel.Text = "All Cars Unlocked"
		plotNextLabel.Visible = true
	end
end

local function updatePlotHealthUI(currentHealth: number, newMaxHealth: number)
	plotMaxHealth = newMaxHealth
	currentHealth = math.clamp(currentHealth, 0, plotMaxHealth)
	local percentage = currentHealth / plotMaxHealth

	plotProgressBar:TweenSize(UDim2.new(percentage, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.2, true)
	plotTextLabel.Text = tostring(math.floor(currentHealth)) .. " / " .. tostring(plotMaxHealth)
end

task.spawn(function()
	local playerPlot: Model?
	while not playerPlot do
		for _, plot in ipairs(Workspace.Plots:GetChildren()) do
			if plot:IsA("Model") and plot:GetAttribute("OwnerId") == localPlayer.UserId then
				playerPlot = plot
				break
			end
		end
		if not playerPlot then
			task.wait(1)
		end
	end

	plotHealthPart = playerPlot:FindFirstChild("PlotHealth")
	if plotHealthPart then
		if plotHealthConnection then plotHealthConnection:Disconnect() end
		plotHealthConnection = plotHealthPart:GetAttributeChangedSignal("Health"):Connect(function()
			updatePlotHealthUI(plotHealthPart:GetAttribute("Health"), plotMaxHealth)
		end)
	end
end)

UpdateProtectionModelFX.OnClientEvent:Connect(function(imageId: string, newMaxHealth: number?, currentModelIndex: number?)
	plotModelImage.Image = imageId
	if newMaxHealth and plotHealthPart then
		updatePlotHealthUI(newMaxHealth, newMaxHealth)
	end

	if currentModelIndex then
		updateNextUnlockLabel(currentModelIndex)
	end
end)

WaveStateChangedEvent.OnClientEvent:Connect(function(isFighting: boolean, currentHealth: number?, newMaxHealth: number?)
	plotHealthFrame.Visible = isFighting
	bottomFrame.Visible = not isFighting

	if not isFighting then
		plotNextLabel.Visible = false
	end

	if isFighting and currentHealth and newMaxHealth then
		updatePlotHealthUI(currentHealth, newMaxHealth)
	end

	if isFighting then
		local openFrameName = FrameManager.getOpenFrameName()
		if openFrameName then
			FrameManager.close(openFrameName)
		end
	end
end)


-------------------------------------------------------------------
-- ## BOSS HEALTH UI ##
-------------------------------------------------------------------

local bossHealthFrame = hud:WaitForChild("BossHealth")
local bossProgressBar = bossHealthFrame:WaitForChild("Progress")
local bossTextLabel = bossHealthFrame:WaitForChild("Text")
local bossImage = bossHealthFrame:WaitForChild("Image")

local bossHealthConnection: RBXScriptConnection?

local function updateBossHealthUI(humanoid: Humanoid)
	local currentHealth = humanoid.Health
	local maxHealth = humanoid.MaxHealth
	local percentage = math.clamp(currentHealth / maxHealth, 0, 1)

	bossProgressBar:TweenSize(UDim2.new(percentage, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.2)
	bossTextLabel.Text = `BOSS: {math.floor(currentHealth)} / {maxHealth}`
end

BossWaveStarted.OnClientEvent:Connect(function(bossHumanoid: Humanoid, imageId: string)
	if not bossHumanoid then return end

	if bossHealthConnection then
		bossHealthConnection:Disconnect()
	end

	bossImage.Image = imageId
	bossHealthFrame.Visible = true
	updateBossHealthUI(bossHumanoid)

	bossHealthConnection = bossHumanoid.HealthChanged:Connect(function()
		updateBossHealthUI(bossHumanoid)
	end)
end)

BossWaveEnded.OnClientEvent:Connect(function()
	bossHealthFrame.Visible = false
	if bossHealthConnection then
		bossHealthConnection:Disconnect()
		bossHealthConnection = nil
	end
end)


-------------------------------------------------------------------
-- ## INITIAL SETUP ##
-------------------------------------------------------------------
plotHealthFrame.Visible = false
bottomFrame.Visible = true
bossHealthFrame.Visible = false
plotNextLabel.Visible = false
---

--- StarterPlayer.StarterPlayerScripts.WaveUIController (LocalScript) ---
--!strict
-- Manages the wave progress bar UI and the next boss indicator.

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- ## ADDED ## Require WaveConfigurations to know which waves have bosses
local WaveConfigurations = require(ReplicatedStorage.Modules.WaveConfigurations)

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local waveBar = playerGui:WaitForChild("GUI"):WaitForChild("HUD"):WaitForChild("Top"):WaitForChild("WaveBar")
local progressBar = waveBar:WaitForChild("Progress")
local textLabel = waveBar:WaitForChild("Text")
local mysteryLabel = waveBar:WaitForChild("Mystery")

local WaveUIStateChanged = ReplicatedStorage.Events:WaitForChild("WaveUIStateChanged")
local ZombieKilled = ReplicatedStorage.Events:WaitForChild("ZombieKilled")

local totalEnemiesInWave = 0
local currentWaveDisplaying = 0

local bossWaveNumbers = {}
for waveNum, config in pairs(WaveConfigurations) do
	if config.IsBossWave then
		table.insert(bossWaveNumbers, waveNum)
	end
end
table.sort(bossWaveNumbers)

local function updateNextBossLabel(currentWaveNumber: number)
	local nextBossWave: number? = nil

	for _, bossWave in ipairs(bossWaveNumbers) do
		if bossWave > currentWaveNumber then
			nextBossWave = bossWave
			break
		end
	end

	if nextBossWave then
		mysteryLabel.Text = `??? at Wave {nextBossWave}`
		mysteryLabel.Visible = true
	else
		mysteryLabel.Visible = false
	end
end


WaveUIStateChanged.OnClientEvent:Connect(function(isFighting: boolean, waveNumber: number?, totalEnemies: number?)
	waveBar.Visible = isFighting
	mysteryLabel.Visible = isFighting

	if isFighting and waveNumber and totalEnemies then
		totalEnemiesInWave = totalEnemies
		currentWaveDisplaying = waveNumber
		textLabel.Text = "Wave " .. tostring(waveNumber)
		progressBar:TweenSize(UDim2.new(0, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.1)

		updateNextBossLabel(waveNumber)
	end
end)

ZombieKilled.OnClientEvent:Connect(function(killedCount: number, eventWaveNumber: number)
	if eventWaveNumber ~= currentWaveDisplaying then return end

	if totalEnemiesInWave > 0 then
		local percentage = math.clamp(killedCount / totalEnemiesInWave, 0, 1)
		progressBar:TweenSize(UDim2.new(percentage, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.3)
	end
end)

waveBar.Visible = false
mysteryLabel.Visible = false
---

--- StarterPlayer.StarterPlayerScripts.ModelAwardHandler (LocalScript) ---
--!strict
-- Handles the award UI pop-up for unlocking new protection models.

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local showModelAwardEvent = ReplicatedStorage.Events:WaitForChild("ShowModelAward")

local awardFrame = playerGui:WaitForChild("GUI"):WaitForChild("Frames"):WaitForChild("ModelAward")
local itemIcon = awardFrame:FindFirstChild("Icon")
local itemNameLabel = awardFrame:FindFirstChild("NameLabel")
local awardSound: Sound = awardFrame:WaitForChild("AwardSound")

awardFrame.AnchorPoint = Vector2.new(0.5, 0.5)
awardFrame.Position = UDim2.fromScale(0.5, 0.5)
awardFrame.Visible = false
local originalSize = awardFrame.Size
local originalTransparency = awardFrame.BackgroundTransparency
local tweenInfoIn = TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
local tweenInfoOut = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In)

showModelAwardEvent.OnClientEvent:Connect(function(modelName: string, imageId: string)
	if itemIcon and itemIcon:IsA("ImageLabel") then
		itemIcon.Image = imageId
	end
	if itemNameLabel and itemNameLabel:IsA("TextLabel") then
		itemNameLabel.Text = "" .. modelName
	end

	awardFrame.Size = UDim2.fromScale(0, 0)
	awardFrame.BackgroundTransparency = 1
	awardFrame.Visible = true

	local tweenIn = TweenService:Create(awardFrame, tweenInfoIn, {
		Size = originalSize,
		BackgroundTransparency = originalTransparency,
	})
	local tweenOut = TweenService:Create(awardFrame, tweenInfoOut, {
		Size = UDim2.fromScale(0, 0),
		BackgroundTransparency = 1,
	})

	tweenIn:Play()
	awardSound:Play()
	tweenIn.Completed:Wait()
	task.wait(3) -- Keep on screen
	tweenOut:Play()

	tweenOut.Completed:Once(function()
		awardFrame.Visible = false
	end)
end)
---

--- StarterPlayer.StarterPlayerScripts.MusicController (LocalScript) ---
--!strict
-- StarterPlayerScripts/MusicController.client.lua
local Players           = game:GetService("Players")
local SoundService      = game:GetService("SoundService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService      = game:GetService("TweenService")

local LocalPlayer = Players.LocalPlayer

local NormalMusic   = SoundService:WaitForChild("NormalMusic") :: Sound
local FightingMusic = SoundService:WaitForChild("FightingMusic") :: Sound
local BossMusic     = SoundService:WaitForChild("BossMusic") :: Sound
local WaveUIStateChanged = ReplicatedStorage.Events:WaitForChild("WaveUIStateChanged") :: RemoteEvent

local TRACKS = { NormalMusic, FightingMusic, BossMusic }
local FADE_TIME = 1.5

-- remember base volumes
local function rememberBaseVolume(s: Sound)
	if s:GetAttribute("BaseVolume") == nil then
		s:SetAttribute("BaseVolume", s.Volume)
	end
end
for _, s in ipairs(TRACKS) do rememberBaseVolume(s) end
local function baseVolume(s: Sound): number
	local v = s:GetAttribute("BaseVolume")
	return (typeof(v) == "number") and v or 1
end

-- state
local intendedTrack: Sound? = NormalMusic
local nowPlayingId = 0
local activeTweens: {[Sound]: Tween} = {}

local function isMusicEnabled(): boolean
	local v = LocalPlayer:GetAttribute("Setting_Music")
	if typeof(v) ~= "boolean" then return true end
	return v
end

local function stopTweens()
	for snd, tw in pairs(activeTweens) do
		if tw then
			pcall(function() tw:Cancel() end)
		end
		activeTweens[snd] = nil
	end
end

local function hardStopAll()
	stopTweens()
	for _, s in ipairs(TRACKS) do
		if s.IsPlaying then s:Stop() end
		s.Volume = baseVolume(s) -- reset target volume for next time
	end
end

local function fadeOutAndStop(id: number, s: Sound)
	if not s.IsPlaying then return end
	local tw = TweenService:Create(s, TweenInfo.new(FADE_TIME), { Volume = 0 })
	activeTweens[s] = tw
	tw.Completed:Once(function()
		-- only stop if we're still on the same request id
		if id == nowPlayingId then
			s:Stop()
			s.Volume = baseVolume(s)
		end
		activeTweens[s] = nil
	end)
	tw:Play()
end

local function fadeIn(id: number, s: Sound)
	-- ensure playing
	if not s.IsPlaying then
		s.Volume = 0
		s:Play()
	end
	local goal = baseVolume(s)
	local tw = TweenService:Create(s, TweenInfo.new(FADE_TIME), { Volume = goal })
	activeTweens[s] = tw
	tw.Completed:Once(function()
		if activeTweens[s] == tw then
			activeTweens[s] = nil
		end
	end)
	tw:Play()
end

local function requestPlay(track: Sound)
	-- de-dupe same request
	if intendedTrack == track and not (track ~= nil and not track.IsPlaying and isMusicEnabled()) then
		intendedTrack = track
		-- still proceed to enforce exclusivity below
	else
		intendedTrack = track
	end

	nowPlayingId += 1
	local myId = nowPlayingId

	-- cancel any ongoing tweens; weâ€™re taking over
	stopTweens()

	if not isMusicEnabled() then
		hardStopAll()
		return
	end

	-- fade out all others, fade in target
	for _, s in ipairs(TRACKS) do
		if s ~= track then
			fadeOutAndStop(myId, s)
		end
	end
	fadeIn(myId, track)
end

-- react to game events
WaveUIStateChanged.OnClientEvent:Connect(function(isFighting: boolean, _waveNumber: number?, _totalEnemies: number?, isBossWave: boolean?)
	if isFighting then
		if isBossWave then
			requestPlay(BossMusic)
		else
			requestPlay(FightingMusic)
		end
	else
		requestPlay(NormalMusic)
	end
end)

-- react to setting toggles in real time
LocalPlayer:GetAttributeChangedSignal("Setting_Music"):Connect(function()
	if isMusicEnabled() then
		requestPlay(intendedTrack or NormalMusic)
	else
		hardStopAll()
	end
end)

-- guard: if any of these tracks gets played by another script, enforce exclusivity
for _, s in ipairs(TRACKS) do
	s:GetPropertyChangedSignal("Playing"):Connect(function()
		if s.IsPlaying then
			-- if a non-intended track was forced to play, reclaim control
			if not isMusicEnabled() then
				hardStopAll()
			elseif intendedTrack and s ~= intendedTrack then
				requestPlay(intendedTrack)
			end
		end
	end)
end

-- init
intendedTrack = NormalMusic
if isMusicEnabled() then
	requestPlay(NormalMusic)
else
	hardStopAll()
end

---

--- StarterPlayer.StarterPlayerScripts.WorldUIController (LocalScript) ---
--!strict
-- LOCATION: StarterPlayerScripts/WorldUIController.lua
-- Manages in-world UI elements, like the shop restock timers,
-- now using the local player's Plot/Vendors shops.

local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace         = game:GetService("Workspace")
local RunService        = game:GetService("RunService")

local localPlayer  = Players.LocalPlayer
local PLOTS_FOLDER = Workspace:WaitForChild("Plots")

-- Remotes
local getBlocksResetTime     = ReplicatedStorage.Functions:WaitForChild("GetBlockShopResetTime")
local getWeaponsResetTime    = ReplicatedStorage.Functions:WaitForChild("GetWeaponShopResetTime")
local updateBlocksStockEvent = ReplicatedStorage.Events:WaitForChild("UpdateBlockStocks")
local updateWeaponsStockEvent= ReplicatedStorage.Events:WaitForChild("UpdateWeaponStocks")

local blocksTimerLabel: TextLabel
local weaponsTimerLabel: TextLabel

local activeTimers: {[string]: RBXScriptConnection?} = {
	Blocks = nil,
	Weapons = nil,
}

local function formatRemaining(seconds: number): string
	if seconds <= 0 then return "00:00" end
	local min = math.floor(seconds / 60)
	local sec = seconds % 60
	return string.format("%02d:%02d", min, sec)
end

local function waitForPlayerPlot(): Model?
	local plot: Model? = nil

	while not plot do
		local plotNum = localPlayer:GetAttribute("PlotNumber")
		if plotNum then
			local candidate = PLOTS_FOLDER:FindFirstChild("Plot" .. tostring(plotNum))
			if candidate and candidate:IsA("Model") then
				plot = candidate
				break
			end
		end
		task.wait(0.5)
	end

	return plot
end

local function resolveTimerLabels()
	local plot = waitForPlayerPlot()
	if not plot then
		warn("[WorldUIController] Could not resolve player plot.")
		return
	end

	local vendors = plot:FindFirstChild("Vendors")
	if not vendors then
		warn("[WorldUIController] Vendors folder missing on plot:", plot.Name)
		return
	end

	local blocksShop  = vendors:FindFirstChild("BlocksShop")
	local weaponsShop = vendors:FindFirstChild("WeaponsShop")

	if not (blocksShop and weaponsShop) then
		warn("[WorldUIController] BlocksShop/WeaponsShop missing under Vendors.")
		return
	end

	local blocksTouch  = blocksShop:FindFirstChild("Touch")
	local weaponsTouch = weaponsShop:FindFirstChild("Touch")

	if not (blocksTouch and weaponsTouch) then
		warn("[WorldUIController] Touch parts missing in shop models.")
		return
	end

	-- Make sure this structure exists on each Touch:
	-- Touch -> RestockGUI -> TimerLabel
	local blocksGUI   = blocksTouch:FindFirstChild("RestockGUI")
	local weaponsGUI  = weaponsTouch:FindFirstChild("RestockGUI")

	if not (blocksGUI and weaponsGUI) then
		warn("[WorldUIController] RestockGUI missing on shop touches.")
		return
	end

	blocksTimerLabel  = (blocksGUI:FindFirstChild("TimerLabel") :: TextLabel)
	weaponsTimerLabel = (weaponsGUI:FindFirstChild("TimerLabel") :: TextLabel)
end

local function startTimer(shopName: "Blocks" | "Weapons", nextTime: number?)
	if not (blocksTimerLabel and weaponsTimerLabel) then
		resolveTimerLabels()
	end

	if activeTimers[shopName] then
		activeTimers[shopName]:Disconnect()
		activeTimers[shopName] = nil
	end

	local label: TextLabel?
	local rf: RemoteFunction?

	if shopName == "Blocks" then
		label = blocksTimerLabel
		rf    = getBlocksResetTime
	else
		label = weaponsTimerLabel
		rf    = getWeaponsResetTime
	end

	if not (label and rf) then
		return
	end

	local function bind(serverResetTime: number)
		local function update()
			local now = os.time()
			local remaining = serverResetTime - now

			if remaining <= 0 then
				label.Text = "00:00"
				if activeTimers[shopName] then
					activeTimers[shopName]:Disconnect()
					activeTimers[shopName] = nil
				end
				return
			end

			label.Text = formatRemaining(remaining)
		end

		update()
		activeTimers[shopName] = RunService.RenderStepped:Connect(update)
	end

	if nextTime then
		bind(nextTime)
	else
		local ok, ts = pcall(function()
			return rf:InvokeServer()
		end)

		if ok and typeof(ts) == "number" then
			bind(ts)
		else
			warn("[WorldUIController] Failed to get reset time for", shopName, ok, ts)
			label.Text = "--:--"
		end
	end
end

-- When server restocks, it sends (stocks, nextRestockTime)
updateBlocksStockEvent.OnClientEvent:Connect(function(_, newRestockTime: number?)
	startTimer("Blocks", newRestockTime)
end)

updateWeaponsStockEvent.OnClientEvent:Connect(function(_, newRestockTime: number?)
	startTimer("Weapons", newRestockTime)
end)

-- Initial timers (will fetch from server)
resolveTimerLabels()
startTimer("Blocks")
startTimer("Weapons")

---

--- StarterPlayer.StarterPlayerScripts.NotificationClient (LocalScript) ---
--[[
	SCRIPT: NotificationClient (LocalScript)
	LOCATION: StarterPlayerScripts/NotificationClient.lua
	DESCRIPTION: Listens for the "ShowNotification" event from the server
	and displays the message using the NotificationManager module.
--]]
--!strict

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Modules
local NotificationManager = require(ReplicatedStorage.Modules:WaitForChild("NotificationManager"))

-- Events
local showNotificationEvent: RemoteEvent = ReplicatedStorage.Events:WaitForChild("ShowNotification")

-- Connect to the event and show the notification when the server sends one.
showNotificationEvent.OnClientEvent:Connect(function(message: string, messageType: string?)
	NotificationManager.show(message, messageType)
end)
---

--- StarterPlayer.StarterPlayerScripts.OnboardingController (LocalScript) ---
--!strict
-- LOCATION: StarterPlayerScripts/OnboardingController.lua
-- Manages the visual elements for the new player onboarding experience.

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- References
local startOnboardingEvent = ReplicatedStorage.Events:WaitForChild("StartOnboarding")
local updateOnboardingStepEvent = ReplicatedStorage.Events:WaitForChild("UpdateOnboardingStep")
local endOnboardingEvent = ReplicatedStorage.Events:WaitForChild("EndOnboarding")
local beamTemplate = ReplicatedStorage.Templates:WaitForChild("OnboardingBeam")
local instructionsLabel = playerGui:WaitForChild("GUI"):WaitForChild("Frames"):WaitForChild("Instructions")
local blocksShop = Workspace:WaitForChild("BlocksShop")
local shopTouchPart = blocksShop:WaitForChild("Touch")
local waveButton = playerGui:WaitForChild("GUI"):WaitForChild("HUD"):WaitForChild("Top"):WaitForChild("Buttons"):WaitForChild("WaveButton")
local onboardingHighlight = waveButton:WaitForChild("Onboarding") -- ## ADDED ##

-- Variables
local beam: Beam?
local attachment0: Attachment?
local attachment1: Attachment?

local function startOnboarding()
	if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
		player.CharacterAdded:Wait()
	end

	local humanoidRootPart = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return end

	instructionsLabel.Text = "Buy your first turret!"
	instructionsLabel.Visible = true

	attachment0 = Instance.new("Attachment")
	attachment0.Parent = humanoidRootPart

	attachment1 = Instance.new("Attachment")
	attachment1.Parent = shopTouchPart

	beam = beamTemplate:Clone()
	beam.Attachment0 = attachment1
	beam.Attachment1 = attachment0
	beam.Parent = humanoidRootPart
end

local function updateOnboarding(stepName: string)
	if stepName == "Step2_PlaceTurret" then
		instructionsLabel.Text = "Place your turret on your plot!"

		local plotNum = player:GetAttribute("PlotNumber")
		if not plotNum then return end
		local playerPlot = Workspace.Plots:FindFirstChild("Plot" .. tostring(plotNum))
		if not playerPlot then return end
		local plotBase = playerPlot:FindFirstChild("Base")

		if attachment1 and plotBase then
			attachment1.Parent = plotBase
		end
	elseif stepName == "Step3_FightButton" then
		instructionsLabel.Text = "Press the Fight button to start the wave!"

		-- ## MODIFIED ## Remove the beam and show the button highlight instead
		if beam then
			beam:Destroy()
			beam = nil
		end
		if attachment1 then
			attachment1:Destroy()
			attachment1 = nil
		end

		if onboardingHighlight then
			onboardingHighlight.Visible = true
		end
	end
end

local function endOnboarding()
	instructionsLabel.Visible = false
	if beam then beam:Destroy() end
	if attachment0 then attachment0:Destroy() end
	if attachment1 then attachment1:Destroy() end

	-- ## ADDED ## Make sure to hide the highlight when onboarding ends
	if onboardingHighlight then
		onboardingHighlight.Visible = false
	end
end

startOnboardingEvent.OnClientEvent:Connect(startOnboarding)
updateOnboardingStepEvent.OnClientEvent:Connect(updateOnboarding)
endOnboardingEvent.OnClientEvent:Connect(endOnboarding)
---

--- StarterPlayer.StarterPlayerScripts.PlacementInitializer (LocalScript) ---
--!strict
--[[
	SCRIPT: PlacementInitializer (LocalScript)
	LOCATION: StarterPlayerScripts/PlacementInitializer.lua
	DESCRIPTION: Initializes the client-side PlacementHandler module.
--]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
-- ## MODIFIED ## Renamed to PlacementHandler
local PlacementHandler = require(ReplicatedStorage.Modules:WaitForChild("PlacementHandler"))

PlacementHandler:Init()
---

--- StarterPlayer.StarterPlayerScripts.PromotionalCrateHandler (LocalScript) ---
--!strict
-- LOCATION: StarterPlayerScripts/PromotionalCrateHandler.lua
-- Handles: ProximityPrompt/Touch purchase + rotating/cycling gun display (client-only, no scaling)

local Players            = game:GetService("Players")
local Workspace          = game:GetService("Workspace")
local ReplicatedStorage  = game:GetService("ReplicatedStorage")
local MarketplaceService = game:GetService("MarketplaceService")
local RunService         = game:GetService("RunService")
local TweenService       = game:GetService("TweenService")

local player = Players.LocalPlayer
local WeaponConfigurations = require(ReplicatedStorage.Modules.WeaponConfigurations)

-- === CONFIG (display) ===
local GUN_SRC     = ReplicatedStorage:WaitForChild("Weapons"):WaitForChild("GunDisplays")
local ROT_SPEED   = math.rad(40) -- rad/s
local CYCLE_TIME  = 2.2          -- seconds per model
local FADE_TIME   = 0.18         -- seconds
-- =========================

-- ---------- utils ----------
local function parts(inst: Instance): {BasePart}
	local t = {}
	for _, d in ipairs(inst:GetDescendants()) do
		if d:IsA("BasePart") then t[#t+1] = d end
	end
	return t
end

local function makePassive(m: Instance)
	for _, d in ipairs(m:GetDescendants()) do
		if d:IsA("ParticleEmitter") or d:IsA("Beam") or d:IsA("Trail") or d:IsA("Light") then d.Enabled = false end
		if d:IsA("Script") or d:IsA("LocalScript") then d.Disabled = true end
	end
	for _, p in ipairs(parts(m)) do
		p.Anchored = true
		p.CanCollide = false
		p.CanQuery = false
		p.Massless = true
		p.CastShadow = false
	end
end

local function setAlpha(inst: Instance, a: number)
	for _, p in ipairs(parts(inst)) do
		p.Transparency = a
	end
end

local function waitForAttachment(crate: Model, timeout: number?): Attachment?
	local deadline = time() + (timeout or 5)
	repeat
		local gd = crate:FindFirstChild("GunDisplay", true)
		if gd then
			for _, d in ipairs(gd:GetDescendants()) do
				if d:IsA("Attachment") then return d end
			end
		end
		RunService.Heartbeat:Wait()
	until time() >= deadline or not crate.Parent
	return nil
end
-- --------------------------

-- Build rotating/cycling display on a given crate (idempotent)
local function buildGunDisplay(crate: Model)
	if not crate or not crate:IsDescendantOf(Workspace) then return end
	if crate:GetAttribute("HasDisplay") then return end

	local attach = waitForAttachment(crate, 5)
	if not attach then
		-- retry once descendants stream in
		local con; con = crate.DescendantAdded:Connect(function()
			local a = waitForAttachment(crate, 2)
			if a then
				con:Disconnect()
				buildGunDisplay(crate)
			end
		end)
		return
	end

	crate:SetAttribute("HasDisplay", true)

	-- pivot at attachment
	local pivot = Instance.new("Part")
	pivot.Name = "GunPivot"
	pivot.Size = Vector3.new(0.2, 0.2, 0.2)
	pivot.Anchored = true
	pivot.Transparency = 1
	pivot.CanCollide = false
	pivot.CanQuery = false
	pivot.Parent = crate
	pivot.CFrame = attach.WorldCFrame

	-- clone silhouettes (NO SCALING)
	local pool: {Model} = {}
	for _, src in ipairs(GUN_SRC:GetChildren()) do
		if src:IsA("Model") then
			local m = src:Clone()
			makePassive(m)
			m:PivotTo(pivot.CFrame)
			setAlpha(m, 1) -- hidden
			m.Parent = crate
			table.insert(pool, m)
		end
	end
	if #pool == 0 then return end
	setAlpha(pool[1], 0) -- show first

	-- animate
	local idx, last = 1, time()
	RunService.RenderStepped:Connect(function()
		if not crate:IsDescendantOf(Workspace) then return end

		-- keep glued to attachment (handles crate motion/streaming)
		pivot.CFrame = attach.WorldCFrame

		-- rotate around Y (no scaling)
		local rot = CFrame.Angles(0, ROT_SPEED * (time() % 10000), 0)
		local target = pivot.CFrame * rot
		for _, m in ipairs(pool) do
			m:PivotTo(target)
		end

		-- cycle
		if time() - last >= CYCLE_TIME then
			last = time()
			local old = pool[idx]
			idx = (idx % #pool) + 1
			local newM = pool[idx]

			local t0 = time()
			while time() - t0 < FADE_TIME do
				local a = (time() - t0) / FADE_TIME
				setAlpha(old, a)
				setAlpha(newM, 1 - a)
				RunService.RenderStepped:Wait()
			end
			setAlpha(old, 1)
			setAlpha(newM, 0)
		end
	end)

	-- if the attachment changes because of streaming, refresh our reference
	crate.AncestryChanged:Connect(function(_, parent)
		if parent and parent:IsDescendantOf(Workspace) then
			local newAttach = waitForAttachment(crate, 2)
			if newAttach then attach = newAttach end
		end
	end)
end

-- Wire the purchase UX on a given crate (prompt + touch)
local function wirePurchaseUI(crate: Model)
	local goldCrateConfig = WeaponConfigurations.Crates.GoldCrate
	if not goldCrateConfig then return end

	-- Wait for PrimaryPart just in case
	while crate and crate.Parent and not crate.PrimaryPart do task.wait() end
	if not crate or not crate.PrimaryPart then return end

	-- ProximityPrompt
	if not crate.PrimaryPart:FindFirstChildOfClass("ProximityPrompt") then
		local prompt = Instance.new("ProximityPrompt")
		prompt.ObjectText = goldCrateConfig.DisplayName
		prompt.ActionText = "Buy"
		prompt.MaxActivationDistance = 20
		prompt.RequiresLineOfSight = false
		prompt.Parent = crate.PrimaryPart
		prompt.Triggered:Connect(function()
			MarketplaceService:PromptProductPurchase(player, goldCrateConfig.ProductID)
		end)
	end

	-- Touched purchase (simple debounce)
	local touchDebounce = false
	crate.PrimaryPart.Touched:Connect(function(hit)
		if touchDebounce then return end
		if not player.Character or not hit:IsDescendantOf(player.Character) then return end
		touchDebounce = true
		MarketplaceService:PromptProductPurchase(player, goldCrateConfig.ProductID)
		task.delay(3, function() touchDebounce = false end)
	end)
end

-- Main: wait plot â†’ find crate â†’ wire + display, and handle respawns
task.spawn(function()
	-- wait for the player's plot
	local plot: Model?
	while not plot do
		local n = player:GetAttribute("PlotNumber")
		if n then plot = Workspace:FindFirstChild("Plots") and Workspace.Plots:FindFirstChild("Plot" .. tostring(n)) or nil end
		task.wait(0.5)
	end

	-- helper to handle a single crate instance
	local function handleCrate(crate: Model)
		buildGunDisplay(crate)
		wirePurchaseUI(crate)
	end

	-- existing promo crate
	local promoCrate = plot:WaitForChild("PromotionalGoldCrate", 10)
	if promoCrate and promoCrate:IsA("Model") then
		handleCrate(promoCrate)
	end

	-- if a new promo crate appears later (e.g., respawn), handle it too
	plot.ChildAdded:Connect(function(ch)
		if ch:IsA("Model") and ch.Name == "PromotionalGoldCrate" then
			handleCrate(ch)
		end
	end)
end)

---

--- StarterPlayer.StarterPlayerScripts.PurchasePrompter (LocalScript) ---
--!strict
-- LOCATION: StarterPlayerScripts/PurchasePrompter.lua

local ReplicatedStorage   = game:GetService("ReplicatedStorage")
local MarketplaceService  = game:GetService("MarketplaceService")
local Players             = game:GetService("Players")

local player  = Players.LocalPlayer
local Events  = ReplicatedStorage:WaitForChild("Events")

local promptSkipTimerRequest = Events:WaitForChild("PromptSkipTimerRequest")
local promptNearestProduct   = Events:WaitForChild("PromptNearestProduct") -- <-- WaitForChild (important)

-- Existing: skip-timer prompts
promptSkipTimerRequest.OnClientEvent:Connect(function(productId: number)
	MarketplaceService:PromptProductPurchase(player, productId)
end)

-- New: nearest-cash prompts
promptNearestProduct.OnClientEvent:Connect(function(productId: number?)
	if typeof(productId) ~= "number" then return end
	local ok, err = pcall(function()
		MarketplaceService:PromptProductPurchase(player, productId)
	end)
	if not ok then
		warn("[PurchasePrompter] PromptProductPurchase failed:", err)
	end
end)

---

--- StarterPlayer.StarterPlayerScripts.ShopClient (LocalScript) ---
--!strict
-- ShopClient (client-side shop triggers, per-plot only)
--
-- Structure:
-- Workspace
--   Plots
--     Plot1..8
--       Vendors
--         BlocksShop   (Model)
--           Touch      (BasePart)
--         WeaponsShop  (Model)
--           Touch      (BasePart)

local Players           = game:GetService("Players")
local Workspace         = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local FrameManager      = require(ReplicatedStorage.Modules.FrameManager)

local localPlayer  = Players.LocalPlayer
local PLOTS_FOLDER = Workspace:WaitForChild("Plots")

---------------------------------------------------------------------
-- Utils
---------------------------------------------------------------------

local function isFromLocalCharacter(hit: Instance?): boolean
	if not hit or not hit:IsA("BasePart") then return false end

	local character = hit:FindFirstAncestorOfClass("Model")
	if not character then return false end

	return Players:GetPlayerFromCharacter(character) == localPlayer
end

local function waitForPlayerPlot(): Model?
	local plot: Model? = nil

	while not plot do
		local plotNum = localPlayer:GetAttribute("PlotNumber")
		if plotNum then
			local candidate = PLOTS_FOLDER:FindFirstChild("Plot" .. tostring(plotNum))
			if candidate and candidate:IsA("Model") then
				plot = candidate
				break
			end
		end

		task.wait(0.5)
	end

	return plot
end

local function connectTouch(touchPart: BasePart?, frameName: string)
	if not touchPart or not touchPart:IsA("BasePart") then
		warn("[ShopClient] Touch part missing or invalid for frame:", frameName)
		return
	end

	local debounce = false

	touchPart.Touched:Connect(function(hit: BasePart)
		if debounce then return end
		if not isFromLocalCharacter(hit) then return end

		debounce = true
		FrameManager.open(frameName)

		task.delay(1, function()
			debounce = false
		end)
	end)
end

---------------------------------------------------------------------
-- Init
---------------------------------------------------------------------

local function init()
	local plot = waitForPlayerPlot()
	if not plot then
		warn("[ShopClient] Could not resolve player plot.")
		return
	end

	local vendors = plot:FindFirstChild("Vendors")
	if not (vendors and vendors:IsA("Folder")) then
		warn("[ShopClient] Vendors folder missing under:", plot:GetFullName())
		return
	end

	-- NOW: grab the Touch PART inside the model
	local blocksModel  = vendors:FindFirstChild("BlocksShop")
	local weaponsModel = vendors:FindFirstChild("WeaponsShop")

	local blocksTouch: BasePart?  = blocksModel and blocksModel:FindFirstChild("Touch")  :: BasePart?
	local weaponsTouch: BasePart? = weaponsModel and weaponsModel:FindFirstChild("Touch") :: BasePart?

	-- Blocks/Cowboys shop
	connectTouch(blocksTouch, "BlocksShop")

	-- Weapon crate shop
	connectTouch(weaponsTouch, "WeaponsShop")
end

task.spawn(init)

---

--- StarterPlayer.StarterPlayerScripts.TeleportController (LocalScript) ---
--[[
	TeleportController Script

	Description: Manages the client-side logic for teleporting the player to various
	locations via UI buttons. Now includes success notifications.

	Location: StarterPlayerScripts
]]
--!strict

-- Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")

-- Modules
local NotificationManager = require(ReplicatedStorage.Modules.NotificationManager)

-- Player and Plot References
local localPlayer: Player = Players.LocalPlayer
local PLOTS_FOLDER = Workspace:WaitForChild("Plots")
local SHOP_TELEPORT_PART = Workspace:WaitForChild("ShopTeleport")

-- ===== Helpers =====

local function teleportCharacter(targetCFrame: CFrame, successMessage: string)
	local character = localPlayer.Character
	if not character then
		warn("Teleport failed: Character not found.")
		return
	end

	local hrp = character:FindFirstChild("HumanoidRootPart") :: BasePart?
	if not hrp then
		warn("Teleport failed: HumanoidRootPart not found.")
		return
	end

	-- small y offset to avoid ground clipping
	hrp.CFrame = targetCFrame * CFrame.new(0, 3, 0)
	NotificationManager.show(successMessage, "Success")
end

-- OwnerId can be number or string (depending on how it was written server-side)
local function isOwnedByLocalPlayer(plot: Instance): boolean
	local ownerAttr = plot:GetAttribute("OwnerId")
	if ownerAttr == nil then return false end
	return tostring(ownerAttr) == tostring(localPlayer.UserId)
end

-- Find SpawnPart anywhere under the plot, or by tag "PlotSpawn" within this plot
local function findSpawnPartInPlot(plot: Instance): BasePart?
	-- recursive name search
	local inst = plot:FindFirstChild("SpawnPart", true)
	if inst and inst:IsA("BasePart") then
		return inst
	end

	-- fallback: tagged part inside this plot
	for _, tagged in ipairs(CollectionService:GetTagged("PlotSpawn")) do
		if tagged:IsA("BasePart") and plot:IsAncestorOf(tagged) then
			return tagged
		end
	end

	return nil
end

local function getPlayerPlot(): Model?
	for _, plot in ipairs(PLOTS_FOLDER:GetChildren()) do
		if plot:IsA("Model") and isOwnedByLocalPlayer(plot) then
			return plot
		end
	end
	return nil
end

local function debugNoSpawnPart(plot: Model)
	-- Print useful info once to help diagnose hierarchy/naming
	warn(("[Teleport] Could not find SpawnPart under plot %s. Children:"):format(plot.Name))
	for _, d in ipairs(plot:GetDescendants()) do
		if d:IsA("BasePart") then
			print("  -", d:GetFullName())
		end
	end
end

-- Connect buttons
local function initializeTeleporters()
	local playerGui = localPlayer:WaitForChild("PlayerGui")
	local buttonsContainer = playerGui:WaitForChild("GUI"):WaitForChild("HUD"):WaitForChild("Top"):WaitForChild("Buttons")

	local plotTeleportButton: TextButton = buttonsContainer:WaitForChild("PlotTeleport") :: TextButton
	local shopTeleportButton: TextButton = buttonsContainer:WaitForChild("ShopTeleport") :: TextButton

	plotTeleportButton.MouseButton1Click:Connect(function()
		print("Plot teleport requested.")
		local playerPlot = getPlayerPlot()
		if not playerPlot then
			warn("Could not teleport to plot: Player plot not found.")
			return
		end

		local spawnPart = findSpawnPartInPlot(playerPlot)
		if spawnPart then
			teleportCharacter(spawnPart.CFrame, "Teleported to your plot!")
		else
			warn("Could not teleport to plot: SpawnPart is missing (not found recursively or by tag 'PlotSpawn').")
			debugNoSpawnPart(playerPlot)
		end
	end)

	shopTeleportButton.MouseButton1Click:Connect(function()
		print("Shop teleport requested.")
		if SHOP_TELEPORT_PART and SHOP_TELEPORT_PART:IsA("BasePart") then
			teleportCharacter(SHOP_TELEPORT_PART.CFrame, "Teleported to the shop!")
		else
			warn("Could not teleport to shop: ShopTeleport part is missing in Workspace.")
		end
	end)
end

-- Rebind on character spawns (and immediately if already spawned)
localPlayer.CharacterAdded:Connect(initializeTeleporters)
if localPlayer.Character then
	initializeTeleporters()
end

---

--- StarterPlayer.StarterPlayerScripts.UIInitializer (LocalScript) ---
--!strict

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local TweenService = game:GetService("TweenService")

local DailyRewardsHandler = require(ReplicatedStorage.Modules.DailyRewardsHandler)
DailyRewardsHandler.Init()

-- Modules
local FrameManager = require(ReplicatedStorage.Modules.FrameManager)

-- Player
local player: Player = Players.LocalPlayer

-- Small helper: add hover/press tweens to an icon button
local function attachIconTweens(btn: TextButton | ImageButton)
	local scale = btn:FindFirstChildOfClass("UIScale")
	if not scale then
		scale = Instance.new("UIScale")
		scale.Scale = 1
		scale.Parent = btn
	end

	local TI = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	local hoverUp   = TweenService:Create(scale, TI, { Scale = 1.05 })
	local hoverDown = TweenService:Create(scale, TI, { Scale = 1.00 })
	local pressIn   = TweenService:Create(scale, TI, { Scale = 0.97 })

	btn.MouseEnter:Connect(function() hoverUp:Play() end)
	btn.MouseLeave:Connect(function() hoverDown:Play() end)
	btn.MouseButton1Down:Connect(function() pressIn:Play() end)
	btn.MouseButton1Up:Connect(function() hoverUp:Play() end)
end

local function hookButtonToFrame(btn: Instance?, frameName: string)
	if not btn then return end
	if not (btn:IsA("TextButton") or btn:IsA("ImageButton")) then return end
	attachIconTweens(btn)
	FrameManager.connect(btn, frameName, "Toggle")
end

local function initializeUI()
	pcall(function()
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
	end)

	local playerGui = player:WaitForChild("PlayerGui")
	local gui = playerGui:WaitForChild("GUI")
	local framesContainer = gui:WaitForChild("Frames")
	local hud = gui:WaitForChild("HUD")

	-- Reference the new ScreenGui with Shop / Gift
	local mainScreenGui = playerGui:WaitForChild("ScreenGui")
	local shopFrame = mainScreenGui:WaitForChild("Shop") :: Frame

	-- Left HUD
	local leftHud = hud:WaitForChild("Left")
	local robuxButton = leftHud:FindFirstChild("RobuxStore")

	-- OLD (removed):
	-- hookButtonToFrame(leftHud:FindFirstChild("RobuxStore"), "RobuxStore")

	-- NEW: directly toggle the Shop frame
	if robuxButton and (robuxButton:IsA("TextButton") or robuxButton:IsA("ImageButton")) then
		attachIconTweens(robuxButton)

		robuxButton.MouseButton1Click:Connect(function()
			-- Simple toggle for now
			shopFrame.Visible = not shopFrame.Visible
		end)
	end

	-- You can optionally hide/remove the old RobuxStore frame if you keep it in the hierarchy
	local oldRobuxStore = framesContainer:FindFirstChild("RobuxStore")
	if oldRobuxStore and oldRobuxStore:IsA("GuiObject") then
		oldRobuxStore.Visible = false
	end

	-- Close buttons inside Frames (still handled via FrameManager)
	for _, frame in ipairs(framesContainer:GetChildren()) do
		if frame:IsA("GuiObject") then
			local closeButton = frame:FindFirstChild("Close")
			if closeButton and (closeButton:IsA("TextButton") or closeButton:IsA("ImageButton")) then
				FrameManager.connect(closeButton, frame.Name, "Close")
			end
		end
	end
end

player.CharacterAdded:Connect(initializeUI)
if player.Character then
	initializeUI()
end

---

--- StarterPlayer.StarterPlayerScripts.ClientMessageHandler (LocalScript) ---
--!strict
-- StarterPlayerScripts/ChatMessageHandler

local ReplicatedStorage  = game:GetService("ReplicatedStorage")
local StarterGui         = game:GetService("StarterGui")
local TextChatService    = game:GetService("TextChatService")

local eventsFolder       = ReplicatedStorage:WaitForChild("Events")
local ChatHint           = eventsFolder:WaitForChild("ChatHint") :: RemoteEvent
local ChatAnnouncement   = eventsFolder:WaitForChild("ChatAnnouncement") :: RemoteEvent

local function systemMessage(text: string, color: Color3)
	-- Convert Color3 -> "#RRGGBB"
	local hex = string.format(
		"#%02X%02X%02X",
		math.floor(color.R * 255),
		math.floor(color.G * 255),
		math.floor(color.B * 255)
	)

	-- Wrap the whole message in a colored font tag
	local richText = string.format('<font color="%s">%s</font>', hex, text)

	-- New chat system (TextChatService)
	if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
		local channelsFolder = TextChatService:WaitForChild("TextChannels")
		local generalChannel = channelsFolder:FindFirstChild("RBXGeneral") :: TextChannel?
			or channelsFolder:FindFirstChild("RBXSystem") :: TextChannel?

		if generalChannel then
			generalChannel:DisplaySystemMessage(richText)
		else
			warn("ChatMessageHandler: no RBXGeneral/RBXSystem channel, message was:", text)
		end
		return
	end

	-- Legacy chat (ChatService) fallback
	local ok, err = pcall(function()
		StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = text,
			Color = color,
			Font = Enum.Font.SourceSansBold,
			TextSize = 18,
		})
	end)
	if not ok then
		warn("ChatMakeSystemMessage failed:", err)
	end
end

ChatHint.OnClientEvent:Connect(function(msg: string)
	systemMessage("[TIP] " .. msg, Color3.fromRGB(130, 200, 255)) -- light blue
end)

ChatAnnouncement.OnClientEvent:Connect(function(msg: string)
	systemMessage(msg, Color3.fromRGB(255, 230, 100)) -- gold/yellow
end)

---

--- StarterPlayer.StarterPlayerScripts.VersionDisplay (LocalScript) ---
--!strict
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- find your already existing GUI
local rootGui = playerGui:WaitForChild("GUI"):WaitForChild("Frames")
local versionFrame = rootGui:WaitForChild("GameVersion")
local versionText = versionFrame:WaitForChild("VersionText") :: TextLabel

-- Place version (auto increments every time you publish)
local placeVersion = game.PlaceVersion

-- Fallback for Studio (PlaceVersion = 0 in most cases)
if placeVersion == 0 and RunService:IsStudio() then
	versionText.Text = "Version: DEV"
else
	versionText.Text = "Version: v" .. tostring(placeVersion)
end

-- Optional: fade-in animation
versionText.TextTransparency = 1
game:GetService("TweenService"):Create(
	versionText,
	TweenInfo.new(0.4, Enum.EasingStyle.Quint, Enum.EasingDirection.Out),
	{TextTransparency = 0}
):Play()

---

--- StarterPlayer.StarterPlayerScripts.TradeClient (LocalScript) ---
--!strict
-- TradeClient
-- LOCATION: StarterPlayerScripts/TradeClient
--
-- Client-side:
--  â€¢ For every other player, attach a ProximityPrompt to their HumanoidRootPart
--  â€¢ Prompt is only Enabled when LocalPlayer has SelectedEnemyId set
--  â€¢ When triggered, fire GiftEnemyRequest(targetUserId, enemyId)

local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer

local EventsFolder      = ReplicatedStorage:WaitForChild("Events")
local GiftEnemyRequest  = EventsFolder:WaitForChild("GiftEnemyRequest") :: RemoteEvent

local PROMPT_NAME       = "TradeEnemyPrompt"
local MAX_DISTANCE      = 8
local KEYBOARD_KEY      = Enum.KeyCode.E
local GAMEPAD_KEY       = Enum.KeyCode.ButtonX

-- Track all prompts so we can toggle Enabled when you equip/unequip an enemy tool
local allPrompts: {ProximityPrompt} = {}

----------------------------------------------------------------
-- HELPERS
----------------------------------------------------------------

local function hasSelectedEnemy(): boolean
	local val = LocalPlayer:GetAttribute("SelectedEnemyId")
	return typeof(val) == "string" and val ~= ""
end

local function updateAllPromptsEnabled()
	local enabled = hasSelectedEnemy()
	for _, prompt in ipairs(allPrompts) do
		if prompt.Parent then
			prompt.Enabled = enabled
		end
	end
end

local function createPromptForCharacter(plr: Player, character: Model)
	if plr == LocalPlayer then return end
	if not character then return end

	local root = character:FindFirstChild("HumanoidRootPart") :: BasePart?
	if not root then
		-- fallback â€“ try later when HRP appears
		task.spawn(function()
			local hrp = character:WaitForChild("HumanoidRootPart", 5)
			if hrp and hrp:IsA("BasePart") then
				createPromptForCharacter(plr, character)
			end
		end)
		return
	end

	-- Avoid duplicates
	if root:FindFirstChild(PROMPT_NAME) then return end

	local prompt = Instance.new("ProximityPrompt")
	prompt.Name = PROMPT_NAME
	prompt.ActionText = "Gift Enemy"
	prompt.ObjectText = plr.DisplayName
	prompt.KeyboardKeyCode = KEYBOARD_KEY
	prompt.GamepadKeyCode = GAMEPAD_KEY
	prompt.RequiresLineOfSight = false
	prompt.MaxActivationDistance = MAX_DISTANCE
	prompt.Enabled = hasSelectedEnemy() -- only visible if holding enemy
	prompt.Parent = root

	table.insert(allPrompts, prompt)

	prompt.Triggered:Connect(function(triggeringPlayer: Player)
		if triggeringPlayer ~= LocalPlayer then return end

		local enemyId = LocalPlayer:GetAttribute("SelectedEnemyId")
		if typeof(enemyId) ~= "string" or enemyId == "" then
			return
		end

		GiftEnemyRequest:FireServer(plr.UserId, enemyId)
	end)
end

local function setupForPlayer(plr: Player)
	if plr == LocalPlayer then return end

	if plr.Character then
		createPromptForCharacter(plr, plr.Character)
	end

	plr.CharacterAdded:Connect(function(char)
		createPromptForCharacter(plr, char)
	end)
end

----------------------------------------------------------------
-- BOOTSTRAP
----------------------------------------------------------------

-- Existing players
for _, plr in ipairs(Players:GetPlayers()) do
	setupForPlayer(plr)
end

-- Future players
Players.PlayerAdded:Connect(setupForPlayer)

-- React when your selected enemy changes (equipping / unequipping placer)
LocalPlayer:GetAttributeChangedSignal("SelectedEnemyId"):Connect(updateAllPromptsEnabled)

-- Initial state
updateAllPromptsEnabled()

---

--- StarterGui.GUI.HUD.Top.Buttons.WaveButton.WaveButtonHandler (LocalScript) ---
--!strict

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local FrameManager = require(ReplicatedStorage.Modules.FrameManager)
-- ## ADDED ## Get the PlacementController to exit preview mode
local PlacementHandler = require(ReplicatedStorage.Modules.PlacementHandler)

local WaveButton = script.Parent
local DesignFrame = WaveButton:WaitForChild("Design")
local TextLabel = WaveButton:WaitForChild("Text")
local Gradient = DesignFrame:WaitForChild("Gradient")
local Stroke = DesignFrame:WaitForChild("Stroke")
local TextStroke = TextLabel:WaitForChild("Stroke")

local ToggleWaveStateEvent = ReplicatedStorage.Events:WaitForChild("ToggleWaveState")
local WaveStateChangedEvent = ReplicatedStorage.Events:WaitForChild("WaveStateChanged")

-- Color presets for the button states
local FIGHT_STROKE_COLOR = Color3.fromRGB(33, 100, 0)
local FIGHT_GRADIENT = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 0)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 0))
})

local STOP_STROKE_COLOR = Color3.fromRGB(130, 0, 0)
local STOP_GRADIENT = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 85, 127))
})

local isWaveActive = false

local function updateButtonState()
	if isWaveActive then
		TextLabel.Text = "Stop"
		Stroke.Color = STOP_STROKE_COLOR
		TextStroke.Color = STOP_STROKE_COLOR
		Gradient.Color = STOP_GRADIENT
	else
		TextLabel.Text = "Fight"
		Stroke.Color = FIGHT_STROKE_COLOR
		TextStroke.Color = FIGHT_STROKE_COLOR
		Gradient.Color = FIGHT_GRADIENT
	end
end

WaveStateChangedEvent.OnClientEvent:Connect(function(isActive: boolean)
	isWaveActive = isActive
	updateButtonState()
end)

WaveButton.MouseButton1Click:Connect(function()
	-- If the fight is about to start, close inventory and exit placement mode.
	if not isWaveActive then
		FrameManager.close("Inventory")
		PlacementHandler:ExitAllModes() -- ## ADDED ##
	end

	ToggleWaveStateEvent:FireServer()
end)

-- Initial setup
updateButtonState()
---

--- StarterGui.GUI.HUD.Top.WaveSettings.AutoWave.AutoWaveHandler (LocalScript) ---
--!strict

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- UI Elements
local autoWaveButton = script.Parent
local DesignFrame = autoWaveButton:WaitForChild("Design")
local Gradient = DesignFrame:WaitForChild("Gradient")
local Stroke = DesignFrame:WaitForChild("Stroke")

-- Events
local SetAutoWaveEvent = ReplicatedStorage.Events:WaitForChild("SetAutoWave")
local AutoWaveStateChangedEvent = ReplicatedStorage.Events:WaitForChild("AutoWaveStateChanged") -- ## ADDED ##

-- State
local isAutoWaveEnabled = false -- Default to off

-- Visual States
local OnStroke = Color3.fromRGB(33, 100, 0)
local OnGradient = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 0)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 0))
})

local OffStroke = Color3.fromRGB(0, 93, 140)
local OffGradient = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 170, 255)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 255))
})

local function updateButtonVisuals()
	if isAutoWaveEnabled then
		Gradient.Color = OnGradient
		Stroke.Color = OnStroke
	else
		Gradient.Color = OffGradient
		Stroke.Color = OffStroke
	end
end

-- Listen for the button to be clicked
autoWaveButton.MouseButton1Click:Connect(function()
	-- Toggle the state
	isAutoWaveEnabled = not isAutoWaveEnabled

	-- Update the button's look
	updateButtonVisuals()

	-- Tell the server about the change
	SetAutoWaveEvent:FireServer(isAutoWaveEnabled)
end)

-- ## ADDED ## Listen for the server to force an update to our state
AutoWaveStateChangedEvent.OnClientEvent:Connect(function(newState: boolean)
	-- Check if the state is actually different to avoid redundant updates
	if isAutoWaveEnabled ~= newState then
		isAutoWaveEnabled = newState
		updateButtonVisuals()
	end
end)


-- Set the initial appearance
updateButtonVisuals()
---

--- StarterGui.GUI.HUD.Top.WaveSpeed.2xWaveSpeed.FastWaveHandler (LocalScript) ---
--!strict
-- PlayerGui/YourFrame/2xWaveSpeedClient.lua

-- Services
local Players = game:GetService("Players")
local MarketplaceService = game:GetService("MarketplaceService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer

-- CONFIG
local GAMEPASS_ID = 1542612384
local COLOR_ACTIVE   = Color3.fromRGB(6, 237, 0)    -- green
local COLOR_INACTIVE = Color3.fromRGB(238, 29, 0)   -- red

-- UI refs
local root = script.Parent :: Instance  -- your 2xWaveSpeed container (Frame/Button/etc.)
-- be robust: find the first image/text anywhere under root
local imageObj = root:FindFirstChildWhichIsA("ImageLabel", true)
	or root:FindFirstChildWhichIsA("ImageButton", true)
	or root
local textObj  = root:FindFirstChildWhichIsA("TextLabel", true)
	or root:FindFirstChild("Text")

-- add a small status dot if none exists
local dot = root:FindFirstChild("StatusDot")
if not dot and root:IsA("GuiObject") then
	dot = Instance.new("Frame")
	dot.Name = "StatusDot"
	dot.AnchorPoint = Vector2.new(1, 0)
	dot.Position = UDim2.new(1, -6, 0, 6)
	dot.Size = UDim2.fromOffset(12, 12)
	dot.BackgroundTransparency = 0
	dot.BorderSizePixel = 0
	local uiCorner = Instance.new("UICorner")
	uiCorner.CornerRadius = UDim.new(1, 0)
	uiCorner.Parent = dot
	dot.Parent = root
end

-- Remotes
local Events = ReplicatedStorage:WaitForChild("Events")
local ToggleFastForward = Events:WaitForChild("ToggleFastForward") :: RemoteEvent
local FastForwardUnlocked = Events:WaitForChild("FastForwardUnlocked") :: RemoteEvent
local WaveSpeedChanged = Events:WaitForChild("WaveSpeedChanged") :: RemoteEvent

-- Create-or-get: RefreshFastForwardOwnership
local RefreshOwnership =
	Events:FindFirstChild("RefreshFastForwardOwnership") :: RemoteEvent
	or (function()
		local re = Instance.new("RemoteEvent")
		re.Name = "RefreshFastForwardOwnership"
		re.Parent = Events
		return re
	end)()

-- State
local owned = false        -- has gamepass
local active = false       -- 2x currently ON
local debounce = false

-- Helpers
local function setTint()
	local color = active and COLOR_ACTIVE or COLOR_INACTIVE

	-- Image layer
	if imageObj:IsA("ImageLabel") or imageObj:IsA("ImageButton") then
		(imageObj :: any).ImageColor3 = color
	elseif imageObj:IsA("GuiObject") then
		(imageObj :: any).BackgroundColor3 = color
	end

	-- Root background (helps if the image is covered)
	if root:IsA("GuiObject") then
		root.BackgroundColor3 = color
	end

	-- Text label for extra clarity
	if textObj and textObj:IsA("TextLabel") then
		textObj.TextColor3 = color
	end

	-- Status dot if present
	if dot and dot:IsA("Frame") then
		dot.BackgroundColor3 = color
	end
end

-- start red (inactive)
setTint()

-- Server confirms ownership (on join / after purchase refresh)
-- Expect a boolean param: true if player owns the pass, false otherwise.
FastForwardUnlocked.OnClientEvent:Connect(function(isOwned: any)
	if typeof(isOwned) == "boolean" then
		owned = isOwned
		if owned then
			print("[2x] You own the 2x Wave Speed gamepass! âœ…")
		else
			print("[2x] You do NOT own the 2x Wave Speed gamepass.")
		end
	end
	setTint()
end)

-- Server reports current multiplier (this is the truth)
WaveSpeedChanged.OnClientEvent:Connect(function(multiplier: number)
	active = (tonumber(multiplier) or 1) > 1
	setTint()
end)

-- Purchase finished -> ask server to re-check; stays inactive until user clicks again
MarketplaceService.PromptGamePassPurchaseFinished:Connect(function(plr, passId, purchased)
	if plr == player and passId == GAMEPASS_ID and purchased then
		--print("[2x] Purchase completed! Refreshing ownership with server...")
		RefreshOwnership:FireServer()
	end
end)

-- Local check (used only when the user presses the button and we think they don't own it)
local function ownsPassLocal(): boolean
	if owned then return true end
	local ok, has = pcall(function()
		return MarketplaceService:UserOwnsGamePassAsync(player.UserId, GAMEPASS_ID)
	end)
	if ok and has then
		owned = true
		--print("[2x] You own the 2x Wave Speed gamepass! âœ… (verified locally)")
		return true
	end
	return false
end

-- Click handler
local function onPressed()
	if debounce then return end
	debounce = true

	-- If they own it -> toggle on server; if not -> prompt purchase
	if ownsPassLocal() then
		ToggleFastForward:FireServer()
	else
		--print("[2x] Prompting purchase for 2x Wave Speed gamepass...")
		MarketplaceService:PromptGamePassPurchase(player, GAMEPASS_ID)
	end

	task.delay(0.15, function() debounce = false end)
end

-- Hook clicks on any GuiButton inside root (or the root if it is one)
local function hookButton(btn: GuiButton)
	btn.Activated:Connect(onPressed)
	if btn:IsA("TextButton") or btn:IsA("ImageButton") then
		(btn :: any).MouseButton1Click:Connect(onPressed)
	end
end

if root:IsA("GuiButton") then
	hookButton(root)
else
	local btn = root:FindFirstChildWhichIsA("GuiButton", true)
	if btn then hookButton(btn) end
	-- last resort: click on the container
	if root:IsA("GuiObject") then
		root.Active = true
		root.Selectable = true
		root.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1
				or input.UserInputType == Enum.UserInputType.Touch then
				onPressed()
			end
		end)
	end
end

-- IMPORTANT:
-- We intentionally do NOT set `owned = ownsPassLocal()` at startup.
-- The server should inform us via FastForwardUnlocked(isOwned:boolean),
-- and we only run a local check when the player actively clicks.

---

--- StarterGui.GUI.HUD.Left.SmallButtons.ChangeLog.ChangeLogBtnHandler (LocalScript) ---
--!strict
local Players = game:GetService("Players")

local button = script.Parent
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

button.Activated:Connect(function()
	local gui = playerGui:FindFirstChild("GUI")
	if not gui then return end

	local frames = gui:FindFirstChild("Frames")
	if not frames then return end

	local patchNotes = frames:WaitForChild("PatchNotes")
	if patchNotes and patchNotes:IsA("Frame") then
		patchNotes.Visible = true
	end
end)

---

--- StarterGui.GUI.HUD.Bottom2.Ammo.AmmoUIController (LocalScript) ---
--!strict
-- LocalScript controlling ammo UI
local Players = game:GetService("Players")
local CAS = game:GetService("ContextActionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local frame = script.Parent :: Frame
local ammoLbl = frame:WaitForChild("AmmoCount") :: TextLabel
local Events = ReplicatedStorage:WaitForChild("Events")
local GunUI = Events:WaitForChild("GunUI") :: RemoteEvent
local GunRequest = Events:WaitForChild("GunRequest") :: RemoteEvent

frame.Visible = false
local equipped = false
local ammo = 0
local clip = 0

local function render()
	ammoLbl.Text = string.format("%d/%d", ammo, clip)
end

local function show(v: boolean)
	frame.Visible = v
end

local function bindReload()
	CAS:BindAction("Reload", function(_, state)
		if state == Enum.UserInputState.Begin and equipped then
			GunRequest:FireServer("Reload")
		end
	end, false, Enum.KeyCode.R)
end

local function unbindReload()
	pcall(function() CAS:UnbindAction("Reload") end)
end

GunUI.OnClientEvent:Connect(function(kind, data)
	if kind == "Equipped" then
		equipped = true
		ammo = data.Ammo or 0
		clip = data.Clip or 0
		show(true)
		render()
		bindReload()

	elseif kind == "Unequipped" then
		equipped = false
		show(false)
		unbindReload()

	elseif kind == "Ammo" then
		ammo = data.Ammo or ammo
		clip = data.Clip or clip
		render()

	elseif kind == "Reloading" then
		if data.State then
			ammoLbl.Text = "Reloading..."
		else
			render()
		end
	end
end)

---

--- StarterGui.GUI.HUD.Right.Buttons.Rebirth.RebirthBtnHandler (LocalScript) ---
--!strict
-- LocalScript inside the Rebirth button

local Players = game:GetService("Players")

local button = script.Parent :: TextButton
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Try to find the Rebirth frame anywhere under PlayerGui
local rebirthFrame = playerGui:WaitForChild("ScreenGui"):WaitForChild("Rebirth")

if not rebirthFrame then
	warn("Rebirth frame not found under PlayerGui")
	return
end

-- Optional: find the close (x) button inside the Rebirth frame
local closeButton = rebirthFrame:FindFirstChild("xbutton", true) :: TextButton?

-- Start closed
rebirthFrame.Visible = false

-- Open on click
button.MouseButton1Click:Connect(function()
	rebirthFrame.Visible = true
end)

-- Close on X click
if closeButton then
	closeButton.MouseButton1Click:Connect(function()
		rebirthFrame.Visible = false
	end)
end

---

--- StarterGui.GUI.HUD.Bottom3.EnemyInventory.EnemyInvBtnHandler (LocalScript) ---
--!strict
-- EnemyInventoryBtnHandler
-- Parent: TextButton "EnemyInventory" in HUD.Bottom3

local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Modules           = ReplicatedStorage:WaitForChild("Modules")
local FrameManager      = require(Modules:WaitForChild("FrameManager"))
local PlacementHandler  = require(Modules:WaitForChild("PlacementHandler"))

local eventsFolder            = ReplicatedStorage:WaitForChild("Events")
local unequipWeaponRequest    = eventsFolder:WaitForChild("UnequipWeaponRequest") :: RemoteEvent
local equipLastWeaponRequest  = eventsFolder:WaitForChild("EquipLastWeaponRequest") :: RemoteEvent

local player  = Players.LocalPlayer
local button  = script.Parent :: TextButton

local playerGui = player:WaitForChild("PlayerGui")
local guiRoot   = playerGui:WaitForChild("GUI")
local hudRoot   = guiRoot:WaitForChild("HUD")
local bottomHud = hudRoot:WaitForChild("Bottom")

local function hudActive(): boolean
	return bottomHud.Visible == true
end

local function toggleEnemyInventory()
	if not hudActive() then return end

	unequipWeaponRequest:FireServer()
	PlacementHandler:ExitAllModes()

	-- Don't stack panels
	FrameManager.close("Inventory")
	FrameManager.close("InventoryTwo")

	if FrameManager.getOpenFrameName() == "EnemyInventory" then
		FrameManager.close("EnemyInventory")
		equipLastWeaponRequest:FireServer()
	else
		FrameManager.open("EnemyInventory")
	end
end

button.Activated:Connect(toggleEnemyInventory)

-- If someone closes it via ESC or another panel, give the weapon back
FrameManager.onFrameClosed(function(frameName: string)
	if frameName == "EnemyInventory" then
		equipLastWeaponRequest:FireServer()
	end
end)

---

--- StarterGui.GUI.HUD.Counters.CashDisplayHandler (LocalScript) ---
--!strict
-- CashDisplayHandler (FINAL VERSION)
-- Parent = GUI.HUD.Counters

local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService      = game:GetService("TweenService")
local RunService        = game:GetService("RunService")
local SocialService     = game:GetService("SocialService")

local player = Players.LocalPlayer

local NumberFormatter = require(ReplicatedStorage.Modules.NumberFormatter)

local Events    = ReplicatedStorage:WaitForChild("Events")
local Functions = ReplicatedStorage:WaitForChild("Functions")
local CashUpdated   = Events:WaitForChild("CashUpdated") :: RemoteEvent
local GetPlayerCash = Functions:WaitForChild("GetPlayerCash") :: RemoteFunction

-- UI ----------------------------------------------------
local counters         = script.Parent :: Frame
local moneyLabel       = counters:WaitForChild("Money") :: TextLabel
local friendBoostLabel = counters:WaitForChild("FriendBoost") :: TextLabel

-- State -------------------------------------------------
local oldCashValue = 0
local animConn: RBXScriptConnection? = nil
local currentFriendBoostPercent = 0

--------------------------------------------------
-- Helpers
--------------------------------------------------

local function setCashText(value: number)
	local formatted = NumberFormatter.formatNumber(value, "$")
	moneyLabel.Text = formatted
end

local function updateFriendBoostLabel()
	friendBoostLabel.Text = string.format("Friend boost : %d%%", currentFriendBoostPercent)
end

--------------------------------------------------
-- Friend boost (visual only)
--------------------------------------------------

local function recalcFriendBoost()
	local friendsInServer = 0

	for _, plr in ipairs(Players:GetPlayers()) do
		if plr ~= player then
			local ok, isFriend = pcall(function()
				return player:IsFriendsWith(plr.UserId)
			end)
			if ok and isFriend then
				friendsInServer += 1
			end
		end
	end

	currentFriendBoostPercent = math.clamp(friendsInServer * 10, 0, 30)
	updateFriendBoostLabel()
end

-- Hook into player list changes
recalcFriendBoost()
Players.PlayerAdded:Connect(recalcFriendBoost)
Players.PlayerRemoving:Connect(recalcFriendBoost)

--------------------------------------------------
-- Floating +cash popup (now inside moneyLabel)
--------------------------------------------------

local function showGainPopup(delta: number)
	if delta <= 0 then return end

	local popup = Instance.new("TextLabel")
	popup.BackgroundTransparency = 1
	popup.BorderSizePixel = 0
	popup.Font = moneyLabel.Font
	popup.TextScaled = true
	popup.Text = "+" .. NumberFormatter.formatNumber(delta, "$")
	popup.TextColor3 = Color3.fromRGB(80, 255, 80)
	popup.TextStrokeTransparency = 0.3
	popup.TextStrokeColor3 = Color3.new(0, 0, 0)

	-- parent INSIDE the Money label
	popup.Size = UDim2.fromScale(1, 1)
	popup.AnchorPoint = Vector2.new(0.5, 0.5)
	popup.Position = UDim2.fromScale(0.5, 0.5)
	popup.ZIndex = moneyLabel.ZIndex + 1
	popup.Parent = moneyLabel

	local tweenInfo = TweenInfo.new(0.7, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	local goal = {
		Position = UDim2.fromScale(0.5, 0.2), -- float upward
		TextTransparency = 1,
		TextStrokeTransparency = 1,
	}

	local tween = TweenService:Create(popup, tweenInfo, goal)
	tween:Play()
	tween.Completed:Connect(function()
		popup:Destroy()
	end)
end

--------------------------------------------------
-- Cash animations
--------------------------------------------------

local function animateCashIncrease(startValue: number, endValue: number)
	local duration = 0.5
	local startTime = os.clock()
	local delta = endValue - startValue

	if animConn then
		animConn:Disconnect()
	end

	animConn = RunService.Heartbeat:Connect(function()
		local elapsed = os.clock() - startTime
		local progress = math.min(elapsed / duration, 1)
		local alpha = TweenService:GetValue(progress, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)
		local current = math.floor(startValue + delta * alpha)

		setCashText(current)

		if progress >= 1 then
			setCashText(endValue)
			if animConn then
				animConn:Disconnect()
				animConn = nil
			end
		end
	end)
end

local function animateCashSnap(newValue: number)
	setCashText(newValue)
end

local function onCashChanged(newValue: number)
	if newValue > oldCashValue then
		local diff = newValue - oldCashValue
		showGainPopup(diff)
		animateCashIncrease(oldCashValue, newValue)
	elseif newValue < oldCashValue then
		animateCashSnap(newValue)
	else
		setCashText(newValue)
	end

	oldCashValue = newValue
end

--------------------------------------------------
-- FriendBoost label -> invite friends
--------------------------------------------------

friendBoostLabel.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		local ok, err = pcall(function()
			SocialService:PromptGameInvite(player)
		end)
		if not ok then
			warn("[CashDisplayHandler] Failed to open invite prompt:", err)
		end
	end
end)

--------------------------------------------------
-- Initialization
--------------------------------------------------

task.spawn(function()
	CashUpdated.OnClientEvent:Connect(function(newValue: number)
		onCashChanged(newValue)
	end)

	local success, initialCash = pcall(function()
		return GetPlayerCash:InvokeServer()
	end)

	if success and typeof(initialCash) == "number" then
		onCashChanged(initialCash)
	else
		warn("[CashDisplayHandler] Failed to get initial cash.")
		onCashChanged(0)
	end
end)

---

--- StarterGui.GUI.HUD.WeatherForecast.WeatherForecastHandler (LocalScript) ---
--!strict
-- StarterPlayerScripts/WeatherForecastHandler

local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService        = game:GetService("RunService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local gui = playerGui:WaitForChild("GUI")
local hud = gui:WaitForChild("HUD")

local rootFrame = hud:WaitForChild("WeatherForecast") :: Frame
local template = rootFrame:WaitForChild("WeatherTemplate") :: Frame

local eventsFolder = ReplicatedStorage:WaitForChild("Events")
local WeatherState = eventsFolder:WaitForChild("WeatherState") :: RemoteEvent

-- Internal state
type WeatherPayloadItem = {
	Id: string,
	ExpiresAt: number,
	DisplayName: string?,
	ImageId: string?,
}

local currentEvents: {[string]: WeatherPayloadItem} = {}
local rendered: {[string]: Frame} = {}
local heartbeatConn: RBXScriptConnection?

local function formatRemaining(seconds: number): string
	if seconds <= 0 then
		return "ENDING..."
	end

	local mins = math.floor(seconds / 60)
	local secs = seconds % 60

	if mins <= 0 then
		return string.format("%ds", secs)
	else
		return string.format("%dm %02ds", mins, secs)
	end
end

local function rebuildUI()
	-- Clean old frames
	for id, frame in pairs(rendered) do
		if not currentEvents[id] or currentEvents[id].ExpiresAt <= os.time() then
			frame:Destroy()
			rendered[id] = nil
		end
	end

	local count = 0
	for id, data in pairs(currentEvents) do
		if data.ExpiresAt > os.time() then
			count += 1
			local frame = rendered[id]
			if not frame then
				frame = template:Clone()
				frame.Name = data.Id
				frame.Visible = true
				frame.Parent = rootFrame
				rendered[id] = frame
			end

			local img = frame:FindFirstChild("WeatherImage") :: ImageLabel?
			local timerLabel = img and img:FindFirstChild("Timer") :: TextLabel?

			if img then
				if data.ImageId and data.ImageId ~= "" then
					img.Image = data.ImageId
				end
				if data.DisplayName and data.DisplayName ~= "" then
					img:SetAttribute("DisplayName", data.DisplayName)
				end
			end

			if timerLabel then
				local remaining = data.ExpiresAt - os.time()
				timerLabel.Text = formatRemaining(remaining)
			end
		end
	end

	rootFrame.Visible = (count > 0)
end

local function ensureHeartbeat()
	if heartbeatConn then
		heartbeatConn:Disconnect()
		heartbeatConn = nil
	end

	if next(currentEvents) == nil then
		rootFrame.Visible = false
		return
	end

	heartbeatConn = RunService.Heartbeat:Connect(function()
		local changed = false
		local n = os.time()

		for id, data in pairs(currentEvents) do
			if data.ExpiresAt <= n then
				currentEvents[id] = nil
				changed = true
			else
				local frame = rendered[id]
				if frame then
					local img = frame:FindFirstChild("WeatherImage") :: ImageLabel?
					local timerLabel = img and img:FindFirstChild("Timer") :: TextLabel?
					if timerLabel then
						timerLabel.Text = formatRemaining(data.ExpiresAt - n)
					end
				end
			end
		end

		if changed then
			rebuildUI()
			if next(currentEvents) == nil then
				ensureHeartbeat()
			end
		end
	end)
end

WeatherState.OnClientEvent:Connect(function(payload: {WeatherPayloadItem})
	-- Replace current state with server snapshot
	currentEvents = {}

	for _, entry in ipairs(payload) do
		if entry.Id and entry.ExpiresAt then
			currentEvents[entry.Id] = entry
		end
	end

	rebuildUI()
	ensureHeartbeat()
end)

-- Root frame starts hidden if no data yet
rootFrame.Visible = false
template.Visible = false

---

--- StarterGui.GUI.Frames.WeaponsShop.WeaponsShopHandler (LocalScript) ---
--!strict
-- Populates the weapons shop and handles purchase requests.
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local MarketplaceService = game:GetService("MarketplaceService")

local WeaponConfigurations = require(ReplicatedStorage.Modules.WeaponConfigurations)
local NumberFormatter = require(ReplicatedStorage.Modules.NumberFormatter)
local TopUp = require(ReplicatedStorage.Modules:WaitForChild("TopUpModule"))

local player = Players.LocalPlayer
local shopFrame = script.Parent
local scrollingFrame = shopFrame:WaitForChild("ScrollingFrame")
local itemTemplate = ReplicatedStorage.Templates:WaitForChild("WeaponsTemplate")
local designFrame = shopFrame:WaitForChild("Design")
local timerLabel = designFrame:WaitForChild("Timer")
local restockButton = designFrame:WaitForChild("RestockButton")

local purchaseItemEvent = ReplicatedStorage.Events:WaitForChild("PurchaseWeaponCrate")
local updateStocksEvent = ReplicatedStorage.Events:WaitForChild("UpdateWeaponStocks")
local getResetTime = ReplicatedStorage.Functions:WaitForChild("GetWeaponShopResetTime")
local getStocks = ReplicatedStorage.Functions:WaitForChild("GetWeaponShopStocks")
local crateDataUpdatedEvent = ReplicatedStorage.Events:WaitForChild("CrateDataUpdated")

local currentStocks: {[string]: number} = {}
local currentCrateCount = 0
local MAX_CRATES = 3
local timerConnection: RBXScriptConnection?
local robuxPricesCache: {[number]: string} = {}

-- Robust balance getter (supports Cash/Money/Coins/Balance in leaderstats/Leaderstats/Stats)
local function getLocalBalance(p: Player): number
	-- << MODIFIED >> Remove leaderstats check, use RemoteFunction instead.
	local getCashFunc = ReplicatedStorage.Functions:FindFirstChild("GetPlayerCash")
	if getCashFunc and getCashFunc:IsA("RemoteFunction") then
		local ok, cash = pcall(getCashFunc.InvokeServer, getCashFunc)
		if ok and typeof(cash) == "number" then
			return cash
		end
	end
	-- Fallback to 0 if server can't be reached
	return 0
end

local function formatRemaining(seconds: number): string
	if seconds <= 0 then return "00:00" end
	local min = math.floor(seconds / 60)
	local sec = seconds % 60
	return string.format("%02d:%02d", min, sec)
end

-- Treat broadcast restock time as authoritative; fetch only as fallback on first open.
local function startTimer(nextTime: number?)
	if timerConnection then timerConnection:Disconnect() end

	local function bind(ts: number)
		timerConnection = RunService.Heartbeat:Connect(function()
			if not shopFrame.Visible then
				if timerConnection then timerConnection:Disconnect(); timerConnection = nil end
				return
			end
			local remaining = ts - os.time()
			timerLabel.Text = formatRemaining(remaining)
		end)
	end

	if nextTime and typeof(nextTime) == "number" then
		bind(nextTime)
	else
		local ok, ts = pcall(getResetTime.InvokeServer, getResetTime)
		if ok and typeof(ts) == "number" then bind(ts) end
	end
end

local function populateShop()
	for _, child in ipairs(scrollingFrame:GetChildren()) do
		if not child:IsA("UILayout") then child:Destroy() end
	end

	local itemsToSort = {}
	for itemId, config in pairs(WeaponConfigurations.Crates) do
		if config.Price then
			table.insert(itemsToSort, {Id = itemId, Config = config})
		end
	end

	table.sort(itemsToSort, function(a, b) return a.Config.Price < b.Config.Price end)

	for _, itemData in ipairs(itemsToSort) do
		local itemId = itemData.Id
		local config = itemData.Config
		local item = itemTemplate:Clone()
		item.Name = itemId
		item.ItemImage.Image = config.ImageId
		item.ItemName.Text = config.DisplayName
		item.ItemPrice.Text = NumberFormatter.formatNumber(config.Price, "$")
		item.ItemStock.Text = "Stock: " .. tostring(currentStocks[itemId] or 0)

		item.BuyButton.MouseButton1Click:Connect(function()
			local balance = getLocalBalance(player)
			local cost = config.Price or 0
			if balance < cost then
				local opened = TopUp.PromptIfShort(cost, balance, function(purchased: boolean)
					if not purchased then
						if NotificationManager then
							NotificationManager.show("Not enough money!", "Error")
						else
							warn("Not enough money!")
						end
					end
				end)
				if not opened then
					-- Prompt couldn't open (bad product/universe/etc.)
					if NotificationManager then
						NotificationManager.show("Not enough money!", "Error")
					end
				end
				return
			end

			purchaseItemEvent:FireServer(itemId)


		end)

		local robuxButton = item:FindFirstChild("RobuxBuy")
		if robuxButton and robuxButton:IsA("GuiButton") then
			local priceLabel = robuxButton:FindFirstChild("Text")
			if priceLabel and priceLabel:IsA("TextLabel") then
				if config.ProductID and config.ProductID > 0 then
					robuxButton.Visible = true
					robuxButton.Active = (currentCrateCount < MAX_CRATES)

					if robuxPricesCache[config.ProductID] then
						priceLabel.Text = robuxPricesCache[config.ProductID]
					else
						priceLabel.Text = "..."
						task.spawn(function()
							local success, productInfo = pcall(function()
								return MarketplaceService:GetProductInfo(config.ProductID, Enum.InfoType.Product)
							end)
							if success and productInfo and item.Parent then
								local priceString = "î€‚" .. productInfo.PriceInRobux
								robuxPricesCache[config.ProductID] = priceString
								priceLabel.Text = priceString
							elseif item.Parent then
								priceLabel.Text = "N/A"
							end
						end)
					end

					robuxButton.MouseButton1Click:Connect(function()
						MarketplaceService:PromptProductPurchase(player, config.ProductID)
					end)
				else
					robuxButton.Visible = false
				end
			end
		end

		item.Parent = scrollingFrame
	end
end

crateDataUpdatedEvent.OnClientEvent:Connect(function(crateData: table)
	currentCrateCount = #crateData
	if shopFrame.Visible then
		populateShop()
	end
end)

-- Use the broadcast time directly.
updateStocksEvent.OnClientEvent:Connect(function(newStocks: {[string]: number}, newRestockTime: number?)
	currentStocks = newStocks
	if shopFrame.Visible then
		populateShop()
		startTimer(newRestockTime)
	end
end)

shopFrame:GetPropertyChangedSignal("Visible"):Connect(function()
	if shopFrame.Visible then
		populateShop()
		startTimer() -- fallback fetch on first open
	elseif timerConnection then
		timerConnection:Disconnect()
		timerConnection = nil
	end
end)

local restockConfig = WeaponConfigurations.ShopProducts.RestockWeaponsShop
if restockButton and restockConfig then
	local priceLabel = restockButton:FindFirstChild("Text")
	if priceLabel and priceLabel:IsA("TextLabel") then
		if robuxPricesCache[restockConfig.ProductID] then
			priceLabel.Text = robuxPricesCache[restockConfig.ProductID]
		else
			priceLabel.Text = "..."
			task.spawn(function()
				local success, productInfo = pcall(function()
					return MarketplaceService:GetProductInfo(restockConfig.ProductID, Enum.InfoType.Product)
				end)
				if success and productInfo and restockButton.Parent then
					local priceString = "î€‚" .. productInfo.PriceInRobux
					robuxPricesCache[restockConfig.ProductID] = priceString
					priceLabel.Text = priceString
				elseif restockButton.Parent then
					priceLabel.Text = "N/A"
				end
			end)
		end
	end

	restockButton.MouseButton1Click:Connect(function()
		MarketplaceService:PromptProductPurchase(player, restockConfig.ProductID)
	end)
end

local success, initialStocks = pcall(getStocks.InvokeServer, getStocks)
if success and initialStocks then currentStocks = initialStocks end

---

--- StarterGui.GUI.Frames.RobuxStore.RobuxStoreHandler (LocalScript) ---
--!strict
-- LOCATION: GUI/Frames/RobuxStore/RobuxStoreHandler.lua
-- Populates the Robux store UI for cash purchases.

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local MarketplaceService = game:GetService("MarketplaceService")

local WeaponConfigurations = require(ReplicatedStorage.Modules.WeaponConfigurations)
local NumberFormatter = require(ReplicatedStorage.Modules.NumberFormatter)

local player = Players.LocalPlayer
local storeFrame = script.Parent
local cashFrame = storeFrame:WaitForChild("ScrollingFrame"):WaitForChild("Cash")

local robuxPricesCache = {}

local function populateStore()
	for productName, productConfig in pairs(WeaponConfigurations.CashProducts) do
		local productFrame = cashFrame:FindFirstChild(productName)
		if not productFrame then continue end

		local buyButton = productFrame:FindFirstChild("BuyButton")
		local amountLabel = productFrame:FindFirstChild("Amount")

		if not (buyButton and amountLabel) then continue end

		-- Set the cash amount text
		amountLabel.Text = NumberFormatter.formatNumber(productConfig.CashAmount)

		-- Fetch and display the Robux price
		local priceLabel = buyButton:FindFirstChild("Text")
		if not (priceLabel and priceLabel:IsA("TextLabel")) then continue end

		if robuxPricesCache[productConfig.ProductID] then
			priceLabel.Text = robuxPricesCache[productConfig.ProductID]
		else
			priceLabel.Text = "..." -- Placeholder
			task.spawn(function()
				local success, productInfo = pcall(function()
					return MarketplaceService:GetProductInfo(productConfig.ProductID, Enum.InfoType.Product)
				end)
				if success and productInfo and productFrame.Parent then
					local priceString = "î€‚" .. productInfo.PriceInRobux
					robuxPricesCache[productConfig.ProductID] = priceString
					priceLabel.Text = priceString
				elseif productFrame.Parent then
					priceLabel.Text = "N/A"
				end
			end)
		end

		-- Connect the buy button
		buyButton.MouseButton1Click:Connect(function()
			MarketplaceService:PromptProductPurchase(player, productConfig.ProductID)
		end)
	end
end

populateStore()
---

--- StarterGui.GUI.Frames.RobuxStore.SoundHandler (LocalScript) ---
--!strict
--[[
	SCRIPT: SoundHandler (LocalScript)
	LOCATION: GUI.Frames.RobuxStore
	DESCRIPTION: Plays a sound when this frame becomes visible.
--]]

local frame = script.Parent
local storeSound: Sound? = frame:WaitForChild("StoreSound")

-- Check if the sound object exists and is a sound
if not storeSound or not storeSound:IsA("Sound") then
	warn("Could not find a valid 'StoreSound' object in the frame.")
	return
end

-- This function runs whenever a property of the frame changes
frame:GetPropertyChangedSignal("Visible"):Connect(function()
	-- If the property that changed was "Visible" and it's now true...
	if frame.Visible then
		-- ...play the sound.
		storeSound:Play()
	end
end)
---

--- StarterGui.GUI.Frames.RobuxStore.ScrollingFrame.AHighlights.Crate.BuyButton.ExtraCrateHandler (LocalScript) ---
--!strict
local MarketplaceService = game:GetService("MarketplaceService")
local Players = game:GetService("Players")

local GAMEPASS_EXTRA_CRATE_SLOTS = 1572988194

local button = script.Parent :: TextButton
local player = Players.LocalPlayer

button.Activated:Connect(function()
	if GAMEPASS_EXTRA_CRATE_SLOTS == 0 then return end
	MarketplaceService:PromptGamePassPurchase(player, GAMEPASS_EXTRA_CRATE_SLOTS)
end)

---

--- StarterGui.GUI.Frames.BlocksShop.BlocksShopHandler (LocalScript) ---
--!strict
-- Populates the blocks shop, handles category filtering,
-- and manages user interactions for purchasing items.
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local MarketplaceService = game:GetService("MarketplaceService")

local ItemConfigurations = require(ReplicatedStorage.Modules.ItemConfigurations)
local WeaponConfigurations = require(ReplicatedStorage.Modules.WeaponConfigurations)
local NumberFormatter = require(ReplicatedStorage.Modules.NumberFormatter)
local NotificationManager = require(ReplicatedStorage.Modules.NotificationManager)
local TopUp = require(ReplicatedStorage.Modules:WaitForChild("TopUpModule")) -- âœ… ADD

local player = Players.LocalPlayer
local shopFrame = script.Parent
local scrollingFrame = shopFrame:WaitForChild("ScrollingFrame")
local itemTemplate = ReplicatedStorage.Templates:WaitForChild("BlocksTemplate")
local designFrame = shopFrame:WaitForChild("Design")
local timerLabel = designFrame:WaitForChild("Timer")
local restockButton = designFrame:WaitForChild("RestockButton")
local buttonFrame = shopFrame:WaitForChild("Buttons")
local blocksButton = buttonFrame:WaitForChild("Blocks")
local turretsButton = buttonFrame:WaitForChild("Turrets")

local purchaseItemEvent = ReplicatedStorage.Events:WaitForChild("PurchaseBlockItem")
local updateStocksEvent = ReplicatedStorage.Events:WaitForChild("UpdateBlockStocks")
local getResetTime = ReplicatedStorage.Functions:WaitForChild("GetBlockShopResetTime")
local getStocks = ReplicatedStorage.Functions:WaitForChild("GetBlockShopStocks")

local currentStocks: {[string]: number} = {}
local isPopulating = false
local visualTimerConnection: RBXScriptConnection?
local robuxPricesCache: {[number]: string} = {}
local currentFilter: string = "Turrets"

-- âœ… Robust balance getter (Cash/Money/Coins/Balance in leaderstats/Leaderstats/Stats)
local function getLocalBalance(p: Player): number
	-- << MODIFIED >> Remove leaderstats check, use RemoteFunction instead.
	local getCashFunc = ReplicatedStorage.Functions:FindFirstChild("GetPlayerCash")
	if getCashFunc and getCashFunc:IsA("RemoteFunction") then
		local ok, cash = pcall(getCashFunc.InvokeServer, getCashFunc)
		if ok and typeof(cash) == "number" then
			return cash
		end
	end
	-- Fallback to 0 if server can't be reached
	return 0
end

local function formatRemaining(seconds: number): string
	if seconds <= 0 then return "00:00" end
	local min = math.floor(seconds / 60)
	local sec = seconds % 60
	return string.format("%02d:%02d", min, sec)
end

local function startTimer(nextTime: number?)
	if visualTimerConnection then visualTimerConnection:Disconnect() end

	local function bind(ts: number)
		visualTimerConnection = RunService.Heartbeat:Connect(function()
			if not shopFrame.Visible then
				if visualTimerConnection then visualTimerConnection:Disconnect(); visualTimerConnection = nil end
				return
			end
			local remaining = ts - os.time()
			timerLabel.Text = formatRemaining(remaining)
		end)
	end

	if nextTime and typeof(nextTime) == "number" then
		bind(nextTime)
	else
		local success, ts = pcall(getResetTime.InvokeServer, getResetTime)
		if success and typeof(ts) == "number" then bind(ts) end
	end
end

local function populateShop()
	if isPopulating then return end
	isPopulating = true

	-- wipe current cards
	for _, child in ipairs(scrollingFrame:GetChildren()) do
		if not child:IsA("UILayout") then child:Destroy() end
	end

	-- Gate to hide mutation variants and any intentionally hidden/not-purchasable entries
	local function shouldShow(config: any, filter: string): boolean
		if config.Type ~= filter then return false end
		if config.IsMutation == true then return false end
		if config.ShopHidden == true then return false end
		if config.Purchasable == false then return false end
		-- ensure price exists so sort/labels don't break
		if typeof(config.Price) ~= "number" then return false end
		return true
	end

	-- collect items for the active tab (Blocks/Turrets)
	local itemsToDisplay = {}
	for itemId, config in pairs(ItemConfigurations) do
		if shouldShow(config, currentFilter) then
			table.insert(itemsToDisplay, { Id = itemId, Config = config })
		end
	end

	-- cheapest first
	table.sort(itemsToDisplay, function(a, b)
		return (a.Config.Price or math.huge) < (b.Config.Price or math.huge)
	end)

	-- build cards
	for _, itemData in ipairs(itemsToDisplay) do
		local itemId = itemData.Id
		local config = itemData.Config

		local item = itemTemplate:Clone()
		item.Name = itemId

		local itemImage: ImageLabel? = item:FindFirstChild("ItemImage")
		if itemImage then itemImage.Image = config.ImageId end

		local itemName: TextLabel? = item:FindFirstChild("ItemName")
		if itemName then itemName.Text = config.DisplayName end

		local itemPrice: TextLabel? = item:FindFirstChild("ItemPrice")
		if itemPrice then itemPrice.Text = NumberFormatter.formatNumber(config.Price, "$") end

		local stockLabel: TextLabel? = item:FindFirstChild("ItemStock")
		if stockLabel then
			stockLabel.Text = "Stock: " .. tostring(currentStocks[itemId] or 0)
		end

		local buyButton: TextButton? = item:FindFirstChild("BuyButton")
		if buyButton then
			local isInStock = (currentStocks[itemId] or 0) > 0
			buyButton.Active = isInStock
			buyButton.TextColor3 = if isInStock then Color3.new(1,1,1) else Color3.fromRGB(200,200,200)

			buyButton.MouseButton1Click:Connect(function()
				if not isInStock then
					NotificationManager.show("This item is out of stock!", "Error")
					return
				end

				local balance = getLocalBalance(player)
				local cost = config.Price or 0
				if balance < cost then
					local opened = TopUp.PromptIfShort(cost, balance, function(purchased: boolean)
						if not purchased then
							NotificationManager.show("Not enough money!", "Error")
						end
					end)
					if not opened then
						NotificationManager.show("Not enough money!", "Error")
					end
					return
				end

				purchaseItemEvent:FireServer(itemId)
			end)
		end

		local robuxButton: TextButton? = item:FindFirstChild("RobuxButton")
		if robuxButton then
			if config.ProductID and config.ProductID > 0 then
				robuxButton.Visible = true
				local priceLabel = robuxButton:FindFirstChild("Text")
				if priceLabel and priceLabel:IsA("TextLabel") then
					if robuxPricesCache[config.ProductID] then
						priceLabel.Text = robuxPricesCache[config.ProductID]
					else
						priceLabel.Text = "..."
						task.spawn(function()
							local success, result = pcall(MarketplaceService.GetProductInfo, MarketplaceService, config.ProductID, Enum.InfoType.Product)
							if success and result and result.PriceInRobux and item.Parent then
								local priceString = "î€‚" .. result.PriceInRobux
								robuxPricesCache[config.ProductID] = priceString
								priceLabel.Text = priceString
							elseif item.Parent then
								priceLabel.Text = "N/A"
							end
						end)
					end
				end

				robuxButton.MouseButton1Click:Connect(function()
					MarketplaceService:PromptProductPurchase(player, config.ProductID)
				end)
			else
				robuxButton.Visible = false
			end
		end

		item.Parent = scrollingFrame
	end

	isPopulating = false
end


local function onFilterButtonClicked(filterName: string)
	if currentFilter == filterName then return end
	currentFilter = filterName
	populateShop()
end

blocksButton.MouseButton1Click:Connect(function() onFilterButtonClicked("Blocks") end)
turretsButton.MouseButton1Click:Connect(function() onFilterButtonClicked("Turrets") end)

-- Accept the broadcast restock time and use it.
updateStocksEvent.OnClientEvent:Connect(function(newStocks: {[string]: number}, newRestockTime: number?)
	currentStocks = newStocks
	if shopFrame.Visible then
		populateShop()
		startTimer(newRestockTime)
	end
end)

shopFrame:GetPropertyChangedSignal("Visible"):Connect(function()
	if shopFrame.Visible then
		populateShop()
		startTimer() -- fetch from server on open
	else
		if visualTimerConnection then visualTimerConnection:Disconnect(); visualTimerConnection = nil end
	end
end)

local restockConfig = WeaponConfigurations.ShopProducts.RestockBlocksShop
if restockButton and restockConfig then
	local priceLabel = restockButton:FindFirstChild("Text")
	if priceLabel and priceLabel:IsA("TextLabel") then
		if robuxPricesCache[restockConfig.ProductID] then
			priceLabel.Text = robuxPricesCache[restockConfig.ProductID]
		else
			priceLabel.Text = "..."
			task.spawn(function()
				local success, productInfo = pcall(function()
					return MarketplaceService:GetProductInfo(restockConfig.ProductID, Enum.InfoType.Product)
				end)
				if success and productInfo and restockButton.Parent then
					local priceString = "î€‚" .. productInfo.PriceInRobux
					robuxPricesCache[restockConfig.ProductID] = priceString
					priceLabel.Text = priceString
				elseif restockButton.Parent then
					priceLabel.Text = "N/A"
				end
			end)
		end
	end

	restockButton.MouseButton1Click:Connect(function()
		MarketplaceService:PromptProductPurchase(player, restockConfig.ProductID)
	end)
end

local ok, initialStocks = pcall(getStocks.InvokeServer, getStocks)
if ok and initialStocks then
	currentStocks = initialStocks
else
	warn("[BlocksShopHandler] Could not get initial stocks on startup.")
end

---

--- StarterGui.GUI.Frames.Inventory.InventoryHandler (LocalScript) ---
--!strict

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Modules
local ItemConfigurations = require(ReplicatedStorage.Modules.ItemConfigurations)
local PlacementHandler  = require(ReplicatedStorage.Modules:WaitForChild("PlacementHandler"))
local FrameManager = require(ReplicatedStorage.Modules.FrameManager)

-- UI, Events, and State
local player = Players.LocalPlayer
local inventoryFrame = script.Parent
local scrollingFrame = inventoryFrame:WaitForChild("ScrollingFrame")
local blocksInventoryTemplate = ReplicatedStorage.Templates:WaitForChild("BlocksInventoryTemplate")
local turretsInventoryTemplate = ReplicatedStorage.Templates:WaitForChild("TurretsInventoryTemplate")
local plotResetButton = inventoryFrame:WaitForChild("PlotReset")

local ResetPlotEvent = ReplicatedStorage.Events:WaitForChild("ResetPlot")

local function populateInventory()
	for _, child in ipairs(scrollingFrame:GetChildren()) do
		if child:IsA("UILayout") then continue end
		child:Destroy()
	end

	local inventoryData = PlacementHandler:GetInventory()

	local itemsToDisplay = {}
	for itemId, count in pairs(inventoryData) do
		local config = ItemConfigurations[itemId]
		if config and count > 0 then
			table.insert(itemsToDisplay, {Id = itemId, Config = config, Count = count})
		end
	end
	table.sort(itemsToDisplay, function(a, b) return a.Config.DisplayName < b.Config.DisplayName end)

	for _, itemData in ipairs(itemsToDisplay) do
		local config = itemData.Config
		local template = if config.Type == "Blocks" then blocksInventoryTemplate else turretsInventoryTemplate
		local item = template:Clone()
		item.Name = itemData.Id

		local itemImage: ImageLabel? = item:FindFirstChild("Image")
		if itemImage then itemImage.Image = config.ImageId end

		local itemText: TextLabel? = item:FindFirstChild("Text")
		if itemText then itemText.Text = `{config.DisplayName} (x{itemData.Count})` end

		item.MouseButton1Click:Connect(function()
			PlacementHandler:EnterPlacementMode(itemData.Id)
		end)

		item.Parent = scrollingFrame
	end
end

-- Listen for the state object to change to handle real-time updates.
PlacementHandler.InventoryState.Changed:Connect(function()
	if inventoryFrame.Visible then
		populateInventory()
	end
end)

inventoryFrame:GetPropertyChangedSignal("Visible"):Connect(function()
	if inventoryFrame.Visible then
		populateInventory()
	end
end)

plotResetButton.MouseButton1Click:Connect(function()
	ResetPlotEvent:FireServer()
	-- ## CHANGE APPLIED ## The line below was removed.
	-- FrameManager.close("Inventory")
end)
---

--- StarterGui.GUI.Frames.InventoryTwo.WeaponsInventoryHandler (LocalScript) ---
--!strict
-- Populates the weapon inventory UI and handles weapon selection.

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local WeaponConfigurations = require(ReplicatedStorage.Modules.WeaponConfigurations)

local player = Players.LocalPlayer
local inventoryFrame = script.Parent
local scrollingFrame = inventoryFrame:WaitForChild("ScrollingFrame")
local template = ReplicatedStorage.Templates:WaitForChild("WeaponsInventoryTemplate")

local setSelectedWeaponRequest = ReplicatedStorage.Events:WaitForChild("SetSelectedWeaponRequest")
local equipWeaponRequest = ReplicatedStorage.Events:WaitForChild("EquipWeaponRequest")

local myWeapons = {}
local selectedTemplate: GuiObject? = nil

-- ## MODIFIED ## Color definitions updated for Design background and Text stroke
local DEFAULT_FRAME_STROKE_COLOR = Color3.fromRGB(85, 0, 127)
local SELECTED_FRAME_STROKE_COLOR = Color3.fromRGB(0, 255, 0)
local DEFAULT_DESIGN_COLOR = Color3.fromRGB(170, 0, 255)
local SELECTED_DESIGN_COLOR = Color3.fromRGB(0, 255, 0)
local DEFAULT_TEXT_STROKE_COLOR = Color3.fromRGB(85, 0, 127)
local SELECTED_TEXT_STROKE_COLOR = Color3.fromRGB(0, 110, 0)


local function populateInventory()
	for _, child in ipairs(scrollingFrame:GetChildren()) do
		if not child:IsA("UILayout") then child:Destroy() end
	end
	selectedTemplate = nil

	local lastEquippedWeapon = player:GetAttribute("LastEquippedWeapon")

	for _, weaponId in ipairs(myWeapons) do
		local weaponConfig = WeaponConfigurations.Weapons[weaponId]
		if weaponConfig then
			local item = template:Clone()
			item.Name = weaponId

			-- Find all the necessary UI elements
			local textLabel = item:FindFirstChild("Text")
			local imageLabel = item:FindFirstChild("Image")
			local design = item:FindFirstChild("Design")
			local frameStroke = design and design:FindFirstChild("Stroke")
			local textStroke = textLabel and textLabel:FindFirstChild("Stroke")

			-- Set Text and Image
			if textLabel and textLabel:IsA("TextLabel") then
				textLabel.Text = weaponConfig.DisplayName
			end
			if imageLabel and imageLabel:IsA("ImageLabel") then
				imageLabel.Image = weaponConfig.ImageId
			end

			-- Check if this is the currently selected weapon to set initial colors
			if weaponId == lastEquippedWeapon then
				if frameStroke then frameStroke.Color = SELECTED_FRAME_STROKE_COLOR end
				if design then design.BackgroundColor3 = SELECTED_DESIGN_COLOR end
				if textStroke then textStroke.Color = SELECTED_TEXT_STROKE_COLOR end
				selectedTemplate = item
			end

			if item:IsA("GuiButton") then
				item.MouseButton1Click:Connect(function()
					-- Reset the previously selected item to default colors
					if selectedTemplate then
						local oldDesign = selectedTemplate:FindFirstChild("Design")
						local oldFrameStroke = oldDesign and oldDesign:FindFirstChild("Stroke")
						local oldTextLabel = selectedTemplate:FindFirstChild("Text")
						local oldTextStroke = oldTextLabel and oldTextLabel:FindFirstChild("Stroke")

						if oldFrameStroke then oldFrameStroke.Color = DEFAULT_FRAME_STROKE_COLOR end
						if oldDesign then oldDesign.BackgroundColor3 = DEFAULT_DESIGN_COLOR end
						if oldTextStroke then oldTextStroke.Color = DEFAULT_TEXT_STROKE_COLOR end
					end

					-- ## MODIFIED ## Highlight the new item using BackgroundColor and TextStroke
					if frameStroke then frameStroke.Color = SELECTED_FRAME_STROKE_COLOR end
					if design then design.BackgroundColor3 = SELECTED_DESIGN_COLOR end
					if textStroke then textStroke.Color = SELECTED_TEXT_STROKE_COLOR end
					selectedTemplate = item

					-- Tell the server about our new selection and to equip it
					setSelectedWeaponRequest:FireServer(weaponId)
					equipWeaponRequest:FireServer(weaponId)
				end)
			end
			item.Parent = scrollingFrame
		end
	end
end

ReplicatedStorage.Events.WeaponInventoryUpdated.OnClientEvent:Connect(function(newInventory)
	myWeapons = newInventory
	if inventoryFrame.Visible then
		populateInventory()
	end
end)

inventoryFrame:GetPropertyChangedSignal("Visible"):Connect(function()
	if inventoryFrame.Visible then
		populateInventory()
	end
end)

task.spawn(function()
	local getInventoryFunc = ReplicatedStorage.Functions:WaitForChild("GetWeaponInventory")
	local success, result = pcall(function()
		return getInventoryFunc:InvokeServer()
	end)
	if success and result then
		myWeapons = result
		if inventoryFrame.Visible then
			populateInventory()
		end
	else
		warn("WeaponsInventoryHandler: Could not get initial inventory. Error: " .. tostring(result))
	end
end)
---

--- StarterGui.GUI.Frames.PatchNotes.PatchNotesHandler (LocalScript) ---
--!strict
local Players = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")

local player = Players.LocalPlayer
local gui = player:WaitForChild("PlayerGui"):WaitForChild("GUI") :: ScreenGui

-- Force this ScreenGui to render above others

local frame = script.Parent :: Frame
local scroll = frame:WaitForChild("BodyScroll") :: ScrollingFrame
local text = scroll:WaitForChild("BodyText") :: TextLabel
local closeBtn = frame:FindFirstChild("Close")

-- Patch text source
local meta = RS:FindFirstChild("Meta") or Instance.new("Folder", RS)
meta.Name = "Meta"; meta.Parent = RS
local notes = meta:FindFirstChild("PatchNotes") :: StringValue
if not notes then
	notes = Instance.new("StringValue")
	notes.Name = "PatchNotes"
	notes.Value = "<b>Update Log</b>\n- Write your notes here."
	notes.Parent = meta
end

-- Hard fail-safes to MAKE IT VISIBLE
local function forceOnTop()
	-- Unclip every ancestor
	local a: Instance? = frame
	while a and a ~= gui do
		if a:IsA("GuiObject") then (a :: GuiObject).ClipsDescendants = false end
		a = a.Parent
	end

	-- Big safe size + center if needed
	frame.AnchorPoint = Vector2.new(0.5, 0.5)
	frame.Position = UDim2.fromScale(0.5, 0.5)
	if frame.AbsoluteSize.X < 50 or frame.AbsoluteSize.Y < 50 then
		frame.Size = UDim2.fromOffset(900, 560)
	end

	-- Ensure not fully transparent
	if frame.BackgroundTransparency >= 1 then frame.BackgroundTransparency = 0 end

	-- Brutally raise ZIndex for all children
	local function bumpZ(o: Instance, z: number)
		if o:IsA("GuiObject") then o.ZIndex = z end
		for _, d in ipairs(o:GetChildren()) do bumpZ(d, z) end
	end
	bumpZ(frame, 1000)

	-- Make sure text/images arenâ€™t invisible
	for _, d in ipairs(frame:GetDescendants()) do
		if d:IsA("TextLabel") or d:IsA("TextButton") then d.TextTransparency = 0 end
		if d:IsA("ImageLabel") or d:IsA("ImageButton") then d.ImageTransparency = 0 end
	end
end

-- Apply text + autosize scroll
local function refresh()
	text.RichText = true
	text.TextWrapped = true
	text.TextScaled = false
	text.Text = notes.Value
	task.wait() -- let TextBounds update
	text.Size = UDim2.new(1, -24, 0, math.max(24, text.TextBounds.Y))
	scroll.CanvasSize = UDim2.new(0, 0, 0, text.AbsoluteSize.Y + 24)
end

-- When someone sets Visible=true (your ChangeLog button), guarantee visibility
frame:GetPropertyChangedSignal("Visible"):Connect(function()
	if frame.Visible then
		forceOnTop()
		refresh()
	end
end)

-- Live updates to the text
notes:GetPropertyChangedSignal("Value"):Connect(function()
	if frame.Visible then refresh() end
end)

-- Close button
if closeBtn and (closeBtn:IsA("TextButton") or closeBtn:IsA("ImageButton")) then
	(closeBtn :: any).Activated:Connect(function() frame.Visible = false end)
end

-- ESC closes
UIS.InputBegan:Connect(function(i,gp)
	if gp then return end
	if i.KeyCode == Enum.KeyCode.Escape and frame.Visible then
		frame.Visible = false
	end
end)

-- start hidden
frame.Visible = false

---

--- StarterGui.GUI.Frames.EnemyInventory.EnemyInventoryHandler (LocalScript) ---
--!strict
-- EnemyInventoryHandler

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Modules = ReplicatedStorage:WaitForChild("Modules")
local EnemyConfigurations = require(Modules:WaitForChild("EnemyConfigurations"))

local player = Players.LocalPlayer

local inventoryFrame   = script.Parent :: Frame
local scrollingFrame   = inventoryFrame:WaitForChild("ScrollingFrame") :: ScrollingFrame
local autoSellSelector = inventoryFrame:WaitForChild("AutoSellSelector") :: Frame
local autoSellButton   = inventoryFrame:WaitForChild("AutoSell") :: TextButton

local templatesFolder = ReplicatedStorage:WaitForChild("Templates")
local enemyTemplate   = templatesFolder:WaitForChild("EnemyInventoryTemplate") :: TextButton

local eventsFolder              = ReplicatedStorage:WaitForChild("Events")
local enemyInvUpdatedEvent      = eventsFolder:WaitForChild("EnemyInventoryUpdated") :: RemoteEvent
local enemyAutoSellUpdatedEvent = eventsFolder:WaitForChild("EnemyAutoSellUpdated") :: RemoteEvent
local setEnemyAutoSellEvent     = eventsFolder:WaitForChild("SetEnemyAutoSell") :: RemoteEvent
local requestPlacementToolEvent = eventsFolder:WaitForChild("RequestEnemyPlacementTool") :: RemoteEvent

local myEnemies: {[string]: number} = {}
local autoSellState: {[string]: boolean} = {}

local RARITY_COLORS: {[string]: Color3} = {
	Common    = Color3.fromRGB(200, 200, 200),
	Rare      = Color3.fromRGB(80, 170, 255),
	Epic      = Color3.fromRGB(190, 90, 255),
	Legendary = Color3.fromRGB(255, 200, 80),
	Boss      = Color3.fromRGB(255, 80, 80),
	Secret    = Color3.fromRGB(80, 255, 200),
}

local function getRarityColor(rarity: string?): Color3
	if not rarity then return Color3.new(1, 1, 1) end
	return RARITY_COLORS[rarity] or Color3.new(1, 1, 1)
end

local function clearList()
	for _, child in ipairs(scrollingFrame:GetChildren()) do
		if child:IsA("GuiObject") then
			child:Destroy()
		end
	end
end

-- sort by ValuePerSecond (desc), then by name
local function getSortedEnemyIds(): {string}
	local list = {}
	for enemyId, count in pairs(myEnemies) do
		if count and count > 0 then
			table.insert(list, enemyId)
		end
	end

	local function getVps(id: string): number
		local cfg = EnemyConfigurations[id]
		return (cfg and (cfg :: any).ValuePerSecond) or 0
	end

	table.sort(list, function(a, b)
		local vA = getVps(a)
		local vB = getVps(b)
		if vA == vB then
			local cfgA = EnemyConfigurations[a]
			local cfgB = EnemyConfigurations[b]
			local nameA = (cfgA and cfgA.DisplayName) or a
			local nameB = (cfgB and cfgB.DisplayName) or b
			return nameA < nameB
		end
		return vA > vB
	end)

	return list
end

local function redraw()
	clearList()

	local sortedIds = getSortedEnemyIds()

	for _, enemyId in ipairs(sortedIds) do
		local count = myEnemies[enemyId]
		if count and count > 0 then
			local cfg    = EnemyConfigurations[enemyId]
			local rarity = cfg and cfg.Rarity
			local vps    = (cfg and cfg.ValuePerSecond) or 0

			local item = enemyTemplate:Clone()
			item.Name = enemyId
			item.Visible = true

			-- template tree:
			-- EnemyInventoryTemplate [TextButton]
			--   Design [Frame]
			--   Count [TextLabel]
			--   Image [ImageLabel]
			--   Ratio [UIAspectRatioConstraint]
			--   Name [TextLabel]

			local nameLabel  = item:FindFirstChild("Name")
			local countLabel = item:FindFirstChild("Count")
			local imageLabel = item:FindFirstChild("Image")

			if nameLabel and nameLabel:IsA("TextLabel") then
				nameLabel.Text = (cfg and cfg.DisplayName) or enemyId
				nameLabel.TextColor3 = getRarityColor(rarity)
			end

			if countLabel and countLabel:IsA("TextLabel") then
				countLabel.Text = "x" .. tostring(count)
			end

			if imageLabel and imageLabel:IsA("ImageLabel") and cfg and cfg.ImageId then
				imageLabel.Image = cfg.ImageId
			end

			-- If you later add Rarity / Vps labels to the template, you can find
			-- them here and set text, but for now we only have Name / Count / Image.

			-- click = ask server to give placement tool for that enemy
			item.Activated:Connect(function()
				requestPlacementToolEvent:FireServer(enemyId)
			end)

			item.Parent = scrollingFrame
		end
	end
end

local function setAutoSellButtonVisual(btn: TextButton, enabled: boolean)
	btn.BackgroundTransparency = enabled and 0 or 0.5
end

local function syncAutoSellButtons()
	for _, child in ipairs(autoSellSelector:GetChildren()) do
		if child:IsA("TextButton") then
			local rarityName = child.Name
			local enabled = autoSellState[rarityName] == true
			setAutoSellButtonVisual(child, enabled)
		end
	end
end

--------------------------------------------------
-- REMOTE LISTENERS
--------------------------------------------------

enemyInvUpdatedEvent.OnClientEvent:Connect(function(data: {[string]: number}?)
	-- update local data and ALWAYS redraw
	myEnemies = data or {}
	redraw()
end)

enemyAutoSellUpdatedEvent.OnClientEvent:Connect(function(data: {[string]: boolean}?)
	autoSellState = data or {}
	syncAutoSellButtons()
end)

--------------------------------------------------
-- VISIBILITY CHANGE
--------------------------------------------------

inventoryFrame:GetPropertyChangedSignal("Visible"):Connect(function()
	if inventoryFrame.Visible then
		-- frame just opened -> redraw with latest myEnemies + auto-sell visuals
		redraw()
		syncAutoSellButtons()
	end
end)

--------------------------------------------------
-- INITIAL FETCH FROM SERVER
--------------------------------------------------

task.spawn(function()
	local functionsFolder = ReplicatedStorage:WaitForChild("Functions")
	local fn = functionsFolder:FindFirstChild("GetEnemyInventory") :: RemoteFunction?
	if not fn then
		warn("[EnemyInventoryHandler] GetEnemyInventory not found")
		return
	end

	local ok, result = pcall(function()
		return fn:InvokeServer()
	end)

	if ok and typeof(result) == "table" then
		myEnemies = result :: {[string]: number}
		redraw()
	else
		warn("[EnemyInventoryHandler] GetEnemyInventory failed:", result)
	end
end)

--------------------------------------------------
-- UI INTERACTIONS
--------------------------------------------------

autoSellButton.Activated:Connect(function()
	autoSellSelector.Visible = not autoSellSelector.Visible
end)

for _, child in ipairs(autoSellSelector:GetChildren()) do
	if child:IsA("TextButton") then
		local rarityName = child.Name
		child.Activated:Connect(function()
			local newState = not (autoSellState[rarityName] == true)
			autoSellState[rarityName] = newState
			setAutoSellButtonVisual(child, newState)
			setEnemyAutoSellEvent:FireServer(rarityName, newState)
		end)
	end
end

---

--- StarterGui.GUI.Frames.ConfirmPopup.ConfirmHandler (LocalScript) ---
--!strict
local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer

local frame        = script.Parent :: Frame
local messageLabel = frame:WaitForChild("Message") :: TextLabel
local acceptBtn    = frame:WaitForChild("AcceptBtn") :: TextButton
local denyBtn      = frame:WaitForChild("DenyBtn") :: TextButton

local events            = ReplicatedStorage:WaitForChild("Events")
local promptCageUnlock  = events:WaitForChild("PromptCageUnlock") :: RemoteEvent
local confirmCageUnlock = events:WaitForChild("ConfirmCageUnlock") :: RemoteEvent

local pendingIndex: number? = nil

local function close()
	frame.Visible = false
	pendingIndex = nil
end

promptCageUnlock.OnClientEvent:Connect(function(index: number, cost: number)
	pendingIndex = index
	messageLabel.Text = string.format(
		"Are you sure you want to unlock cage #%d for $%d?",
		index,
		cost
	)
	frame.Visible = true
end)

acceptBtn.Activated:Connect(function()
	if pendingIndex then
		confirmCageUnlock:FireServer(pendingIndex)
	end
	close()
end)

denyBtn.Activated:Connect(close)

frame.Visible = false

---

--- StarterGui.MutationsGui.LevelUpHandler (LocalScript) ---
--!strict
-- Client Level-Up handler (UI + billboard + interactions)

local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace         = game:GetService("Workspace")
local RunService        = game:GetService("RunService")
local UserInputService  = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local PlayerGui   = LocalPlayer:WaitForChild("PlayerGui")

-- World objects
local Machine        = Workspace:WaitForChild("MutationMachine")
local TouchZone      = Machine:WaitForChild("TouchZone") :: BasePart
local Board          = Machine:WaitForChild("Board")
local Attach         = Board:WaitForChild("Attachment")
local Billboard      = Attach:WaitForChild("TextBillboard")
local BillboardTitle = Billboard:WaitForChild("Title") :: TextLabel
local BillboardTimer = Billboard:WaitForChild("Timer") :: TextLabel

-- UI roots
local Gui            = PlayerGui:WaitForChild("MutationsGui") :: ScreenGui
Gui.ZIndexBehavior   = Enum.ZIndexBehavior.Sibling

local MutationFrame  = Gui:WaitForChild("MutationFrame") :: Frame
local AfterFrame     = Gui:WaitForChild("AfterFrame") :: Frame
local Scroll         = AfterFrame:WaitForChild("ScrollingFrame") :: ScrollingFrame
local PickerCloseBtn = AfterFrame:WaitForChild("CloseButton") :: GuiButton

-- Description
local DescFrame = MutationFrame:WaitForChild("DescriptionFrame") :: Frame
local DescCash  = DescFrame:WaitForChild("Gems")  :: TextLabel -- reused label
local DescTime  = DescFrame:WaitForChild("Time")  :: TextLabel
local DescUnits = DescFrame:WaitForChild("Units") :: TextLabel
local DescTitle = DescFrame:WaitForChild("Title") :: TextLabel

-- Input (left)
local InputFrame     = MutationFrame:WaitForChild("InputFrame") :: Frame
local AddButton      = InputFrame:WaitForChild("AddButton") :: GuiButton
local InputUnitImage = InputFrame:WaitForChild("UnitImageLabel") :: ImageLabel
local InputAddText   = InputFrame:WaitForChild("Add") :: TextLabel

-- Output (right)
local OutputFrame     = MutationFrame:WaitForChild("OutputFrame") :: Frame
local OutputUnitImage = OutputFrame:WaitForChild("UnitsImageLabel") :: ImageLabel
local OutputTitle     = OutputFrame:WaitForChild("Title") :: TextLabel

-- Footer
local CloseBtn      = MutationFrame:WaitForChild("CloseButton") :: GuiButton
local MutateBtn     = MutationFrame:WaitForChild("MutateButton") :: GuiButton
local QuestionMark  = MutationFrame:WaitForChild("QuestionMark") :: GuiButton
local NotEnoughCard = MutationFrame:FindFirstChild("NotEnough") :: ImageLabel?
local NotEnoughText = NotEnoughCard and NotEnoughCard:FindFirstChild("Text")

-- Template row
local ItemTemplate: Frame = (function()
	for _, c in Scroll:GetChildren() do
		if c:IsA("Frame") and c.Name == "ItemFrame" then
			c.Visible = false
			return c
		end
	end
	local f = Instance.new("Frame")
	f.Name = "ItemFrame"
	f.Size = UDim2.new(1, 0, 0, 72)

	local img = Instance.new("ImageLabel")
	img.Name = "UnitsImageLabel"
	img.BackgroundTransparency = 1
	img.Size = UDim2.fromOffset(64,64)
	img.Position = UDim2.fromOffset(6,4)
	img.Parent = f

	local t = Instance.new("TextLabel")
	t.Name = "Title"
	t.BackgroundTransparency = 1
	t.TextXAlignment = Enum.TextXAlignment.Left
	t.TextColor3 = Color3.fromRGB(255,255,255)
	t.Font = Enum.Font.Gotham
	t.TextSize = 20
	t.Position = UDim2.fromOffset(80, 0)
	t.Size = UDim2.new(1, -90, 1, 0)
	t.Parent = f

	local btn = Instance.new("TextButton")
	btn.Name = "SelectButton"
	btn.Text = ""
	btn.BackgroundTransparency = 1
	btn.Size = UDim2.fromScale(1,1)
	btn.Parent = f

	f.Visible = false
	f.Parent = Scroll
	return f
end)()

-- Modules & remotes
local Modules             = ReplicatedStorage:WaitForChild("Modules")
local Config              = require(Modules:WaitForChild("LevelUpConfiguration"))
local ItemConfigurations  = require(Modules:WaitForChild("ItemConfigurations"))
local NotificationManager = require(Modules:WaitForChild("NotificationManager"))

local Events        = ReplicatedStorage:WaitForChild("Events")
local RF_List       = Events:WaitForChild("LevelUp_List")  :: RemoteFunction
local RE_Start      = Events:WaitForChild("LevelUp_Start") :: RemoteEvent
local RF_Claim      = Events:WaitForChild("LevelUp_Claim") :: RemoteFunction
local RE_Job        = Events:WaitForChild("LevelUp_JobUpdated") :: RemoteEvent
local RE_PromptSkip = Events:WaitForChild("PromptLevelUpSkipPurchase") :: RemoteEvent

-- Helpers for images/names
local function imageForId(id: string): string
	local cfg = ItemConfigurations[id]
	return (cfg and cfg.ImageId) or "rbxassetid://0"
end

local function displayNameFor(id: string): string
	local c = ItemConfigurations[id]
	return (c and (c.DisplayName or c.Title or c.Name)) or id
end

-- State
local selectedBase: string? = nil
local currentTier = 1
local currentJob: {[string]: any}? = nil
local listData: {[string]: any}? = nil
local hbConn: RBXScriptConnection? = nil
local lastStillNotify = 0
local STILL_COOLDOWN = 6
local pendingStartUntil = 0
local skipPrompt: ProximityPrompt? = nil

-- ===== Time formatting & billboard =====
local function formatSeconds(s: number): string
	if s < 0 then s = 0 end
	local m = math.floor(s / 60)
	local sec = s % 60
	if m >= 60 then
		local h = math.floor(m / 60)
		local mm = m % 60
		return string.format("%dh %dm", h, mm)
	elseif m > 0 then
		return string.format("%dm %ds", m, sec)
	else
		return string.format("%ds", sec)
	end
end

local function setBillboard(title: string, timer: string, color: Color3)
	BillboardTitle.Text = title
	BillboardTimer.Text = timer
	BillboardTitle.TextColor3 = color
	BillboardTimer.TextColor3 = color
end

local function setBillboardReady()
	setBillboard("LEVEL UP", "READY", Color3.fromRGB(255, 75, 75))
end

local function setBillboardDone()
	setBillboard("LEVEL UP", "DONE",  Color3.fromRGB(75, 255, 75))
end

local function stopBillboardTimerLoop()
	if hbConn then
		hbConn:Disconnect()
		hbConn = nil
	end
end

local function ensureSkipPrompt(on: boolean, remaining: number?)
	if on then
		if not skipPrompt or not skipPrompt.Parent then
			skipPrompt = Instance.new("ProximityPrompt")
			skipPrompt.Name = "SkipLevelUpPrompt"
			skipPrompt.ActionText = "Skip Timer"
			skipPrompt.ObjectText = "Level Up"
			skipPrompt.KeyboardKeyCode = Enum.KeyCode.E
			skipPrompt.HoldDuration = 1
			skipPrompt.RequiresLineOfSight = false
			skipPrompt.MaxActivationDistance = 12
			skipPrompt.ClickablePrompt = true
			skipPrompt.Parent = TouchZone
			skipPrompt.Triggered:Connect(function()
				RE_PromptSkip:FireServer()
			end)
		end
		if typeof(remaining) == "number" then
			skipPrompt.ObjectText = ("Skip (%s)"):format(formatSeconds(math.max(0, remaining)))
		end
	else
		if skipPrompt then
			skipPrompt:Destroy()
			skipPrompt = nil
		end
	end
end

local function startBillboardTimerLoop(finishesAt: number)
	stopBillboardTimerLoop()
	if not finishesAt or finishesAt <= os.time() then
		setBillboardDone()
		ensureSkipPrompt(false)
		return
	end
	hbConn = RunService.Heartbeat:Connect(function()
		local remaining = finishesAt - os.time()
		if remaining <= 0 then
			setBillboardDone()
			ensureSkipPrompt(false)
			stopBillboardTimerLoop()
		else
			setBillboard("LEVELING", formatSeconds(remaining), Color3.fromRGB(255,255,75))
			ensureSkipPrompt(true, remaining)
		end
	end)
end

-- ===== Costs / afford check =====
local function costFor(baseId: string, tier: number)
	local rules = Config.RULES[baseId]
	if not rules then return nil end
	tier = tonumber(tier) or 1
	local r = rules[tier]
	if not r then return nil end

	local consumeId = (tier > 1) and Config.ResultId(baseId, tier - 1) or baseId
	local seconds   = Config.TIER_SECONDS[math.clamp(tier, 1, #Config.TIER_SECONDS)] or 0

	return {
		consumeId = consumeId,
		units     = r.units,
		cash      = r.cash or 0,
		seconds   = seconds,
	}
end

local function haveCounts(consumeId: string)
	local cash = (listData and listData.cash) or 0
	local inv  = (listData and listData.inv) or {}
	return cash, tonumber(inv[consumeId] or 0) or 0
end

local function canAfford(baseId: string, tier: number)
	local c = costFor(baseId, tier)
	if not c then return false, 0, 0, 0, 0 end
	local haveCash, haveUnits = haveCounts(c.consumeId)
	return (haveCash >= c.cash and haveUnits >= c.units), haveCash, haveUnits, c.cash, c.units
end

-- ===== UI enable/disable =====
local function setMutateEnabled(affordable: boolean, reasonText: string?)
	MutateBtn.Visible = affordable
	if NotEnoughCard then
		NotEnoughCard.Visible = not affordable
		if NotEnoughText and typeof(reasonText) == "string" then
			(NotEnoughText :: TextLabel).Text = reasonText
		end
	end
end

local function showRequirements(baseId: string, tier: number)
	local c = costFor(baseId, tier)
	if not c then
		DescCash.Text  = "Cash: --"
		DescUnits.Text = "Units: --"
		DescTime.Text  = "Time: --"
		setMutateEnabled(false, "Select a guard")
		return
	end

	local ok, haveCash, haveUnits, needCash, needUnits = canAfford(baseId, tier)
	local cashMark = (haveCash >= needCash) and "âœ“" or "âœ•"
	local unitMark = (haveUnits >= needUnits) and "âœ“" or "âœ•"

	DescCash.Text  = string.format("%s Cash: %d  (You: %d)",  cashMark,  needCash,  haveCash)
	DescUnits.Text = string.format("%s Units: %d  (You: %d)", unitMark, needUnits, haveUnits)
	DescTime.Text  = "Time: " .. formatSeconds(c.seconds)

	setMutateEnabled(ok, ok and "" or "Requirements not met")
end

-- ===== Main card visuals =====
local function refreshVisuals()
	if not selectedBase then
		InputUnitImage.Image = ""
		InputUnitImage.Visible = false
		InputUnitImage.ImageTransparency = 1

		OutputUnitImage.Image = ""
		OutputUnitImage.Visible = false
		OutputUnitImage.ImageTransparency = 1

		OutputTitle.Text = "â€”"
		InputAddText.Visible = true
		setMutateEnabled(false, "Select a guard")
		return
	end

	local c = costFor(selectedBase, currentTier)
	if not c then
		setMutateEnabled(false, "Invalid tier")
		return
	end

	-- Real from/to ids based on cost and config
	local fromId = c.consumeId
	local toId   = Config.ResultId(selectedBase, currentTier)

	-- Left (consumed)
	InputUnitImage.Image = imageForId(fromId)
	InputUnitImage.Visible = true
	InputUnitImage.ImageTransparency = 0
	InputAddText.Visible = false

	-- Right (result)
	OutputUnitImage.Image = imageForId(toId)
	OutputUnitImage.Visible = true
	OutputUnitImage.ImageTransparency = 0

	-- Text: "Revolver Cowboy L3 â†’ Revolver Cowboy L4"
	OutputTitle.Text = string.format("%s â†’ %s", displayNameFor(fromId), displayNameFor(toId))

	showRequirements(selectedBase, currentTier)
end

local function applySelection(baseId: string, tier: number)
	selectedBase = baseId
	currentTier  = math.clamp(tier, 1, (Config.MAX_TIER or 4))
	refreshVisuals()
end

-- ===== Scroll setup =====
Scroll.Active = true
Scroll.ScrollingEnabled = true
Scroll.ScrollingDirection = Enum.ScrollingDirection.Y
Scroll.ElasticBehavior = Enum.ElasticBehavior.WhenScrollable
Scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
Scroll.CanvasSize = UDim2.new(0,0,0,0)
Scroll.ScrollBarThickness = 8
Scroll.ClipsDescendants = true

local listLayout = Scroll:FindFirstChildOfClass("UIListLayout")
if not listLayout then
	listLayout = Instance.new("UIListLayout")
	listLayout.Padding = UDim.new(0, 8)
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.Parent = Scroll
end

local listPadding = Scroll:FindFirstChildOfClass("UIPadding")
if not listPadding then
	listPadding = Instance.new("UIPadding")
	listPadding.PaddingTop = UDim.new(0, 8)
	listPadding.PaddingLeft = UDim.new(0, 8)
	listPadding.PaddingRight = UDim.new(0, 8)
	listPadding.PaddingBottom = UDim.new(0, 8)
	listPadding.Parent = Scroll
end

-- ===== Picker helpers =====
local nextOrder = 1
local function clearPicker()
	for _, c in ipairs(Scroll:GetChildren()) do
		if c:IsA("Frame") and c.Name == "ItemFrame" and c ~= ItemTemplate then
			c:Destroy()
		end
	end
	nextOrder = 1
end

local function addRow(labelText: string, imgId: string, onPick: () -> ())
	local row = ItemTemplate:Clone()
	row.Visible = true
	row.LayoutOrder = nextOrder
	nextOrder += 1

	local unitsImg = row:FindFirstChild("UnitsImageLabel", true)
	if unitsImg and unitsImg:IsA("ImageLabel") then
		unitsImg.Image = imgId
	end
	local titleObj = row:FindFirstChild("Title", true)
	if titleObj and titleObj:IsA("TextLabel") then
		titleObj.Text = labelText
		titleObj.TextTransparency = 0
	end
	local selectBtn = row:FindFirstChild("SelectButton", true)
	if selectBtn and selectBtn:IsA("GuiButton") then
		selectBtn.AutoButtonColor = true
		selectBtn.BackgroundTransparency = 1
		selectBtn.Activated:Connect(onPick)
	end
	row.Parent = Scroll
end

local function populatePicker()
	clearPicker()
	Scroll.CanvasPosition = Vector2.new()

	listData = RF_List:InvokeServer()

	-- job / billboard
	currentJob = listData and listData.job or nil
	if currentJob then
		local remaining = currentJob.finishesAt - os.time()
		if remaining <= 0 then
			currentJob = nil
			setBillboardDone()
			ensureSkipPrompt(false)
		else
			startBillboardTimerLoop(currentJob.finishesAt)
		end
	else
		setBillboardReady()
		ensureSkipPrompt(false)
		stopBillboardTimerLoop()
	end

	local invMap = (listData and listData.inv) or {}

	local function addChoice(idShown: string, label: string, onPickTier: number, previewId: string)
		addRow(label, previewId, function()
			applySelection(idShown, onPickTier)
			AfterFrame.Visible = false
			MutationFrame.Visible = true
			refreshVisuals()
		end)
	end

	for _, baseId in ipairs(Config.MUTABLE) do
		local baseCount = tonumber(invMap[baseId] or 0) or 0
		if baseCount > 0 then
			addChoice(baseId, string.format("%s x%d", displayNameFor(baseId), baseCount), 1, imageForId(baseId))
		end

		local rules = Config.RULES[baseId] or {}
		local maxTier = #rules
		for t = 1, maxTier do
			local mid = Config.ResultId(baseId, t)
			local cnt = tonumber(invMap[mid] or 0) or 0
			-- We only show levels that can still be leveled further (t < MAX_TIER)
			if cnt > 0 and t < Config.MAX_TIER then
				-- t=1 => L2, t=2 => L3, etc. We use t+1 as "level number".
				local label = string.format("%s L%d x%d", displayNameFor(baseId), t + 1, cnt)
				addChoice(baseId, label, t + 1, imageForId(mid))
			end
		end
	end
end

-- ===== Open / close =====
local function openMain()
	if MutationFrame.Visible then return end
	MutationFrame.Visible = true

	InputUnitImage.Image = ""
	InputUnitImage.Visible = false
	InputUnitImage.ImageTransparency = 1

	OutputUnitImage.Image = ""
	OutputUnitImage.Visible = false
	OutputUnitImage.ImageTransparency = 1

	OutputTitle.Text = "â€”"
	InputAddText.Visible = true
	setMutateEnabled(false, "Select a guard")
	populatePicker()
end

local function closeMain()
	MutationFrame.Visible = false
	AfterFrame.Visible = false
end

CloseBtn.Activated:Connect(closeMain)

local function togglePicker(show: boolean?)
	local s = (show ~= nil) and show or not AfterFrame.Visible
	AfterFrame.Visible = s
	MutationFrame.Visible = not s
	if s then
		populatePicker()
	end
end

PickerCloseBtn.Activated:Connect(function()
	togglePicker(false)
end)

AddButton.Activated:Connect(function()
	if not MutationFrame.Visible and not AfterFrame.Visible then
		MutationFrame.Visible = true
	end
	togglePicker(true)
end)

InputFrame.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.UserInputType == Enum.UserInputType.MouseButton1
		or input.UserInputType == Enum.UserInputType.Touch then
		if not MutationFrame.Visible and not AfterFrame.Visible then
			MutationFrame.Visible = true
		end
		togglePicker(true)
	end
end)

-- Tier stepper (scroll wheel over output)
local function stepTier(delta: number)
	if not selectedBase then return end
	local maxT = math.min((Config.MAX_TIER or 4), #(Config.RULES[selectedBase] or {}))
	if maxT <= 0 then return end
	currentTier = ((currentTier - 1 + delta) % maxT) + 1
	refreshVisuals()
end

OutputFrame.InputChanged:Connect(function(input, gpe)
	if gpe then return end
	if input.UserInputType == Enum.UserInputType.MouseWheel then
		local d = input.Position.Z > 0 and 1 or -1
		stepTier(d)
	end
end)

-- ===== Mutate button =====
MutateBtn.Activated:Connect(function()
	if currentJob then return end
	if not selectedBase then
		NotificationManager.show("Select a guard first.", "Error")
		togglePicker(true)
		return
	end
	local ok = select(1, canAfford(selectedBase, currentTier))
	if not ok then
		NotificationManager.show("You don't meet the requirements.", "Error")
		return
	end

	local c = costFor(selectedBase, currentTier)
	local fromId = c and c.consumeId or selectedBase
	local toId   = Config.ResultId(selectedBase, currentTier)

	pendingStartUntil = os.clock() + 1.5
	closeMain()
	RE_Start:FireServer(selectedBase, currentTier)

	NotificationManager.show(
		string.format("Level up started: %s â†’ %s!", displayNameFor(fromId), displayNameFor(toId)),
		"Normal"
	)

	setBillboard("LEVELING", "â€¦", Color3.fromRGB(255,255,75))
end)

-- ===== Auto-claim on touch =====
local function autoClaimIfReady()
	if os.clock() < pendingStartUntil then return end
	local data = RF_List:InvokeServer()
	local job = data and data.job
	if not job then
		openMain()
		return
	end
	local remaining = job.finishesAt - os.time()
	if remaining <= 0 then
		local ok, _ = RF_Claim:InvokeServer()
		if ok then
			currentJob = nil
			setBillboardReady()
			ensureSkipPrompt(false)
			stopBillboardTimerLoop()
			NotificationManager.show("Level up complete! Claimed new unit.", "Success")
			populatePicker()
		end
	else
		if os.clock() - lastStillNotify >= STILL_COOLDOWN then
			lastStillNotify = os.clock()
			NotificationManager.show(("Still leveling... %s left."):format(formatSeconds(remaining)), "Normal")
		end
		startBillboardTimerLoop(job.finishesAt)
	end
end

local touchDebounce = false
TouchZone.Touched:Connect(function(hit)
	if touchDebounce then return end
	local char = hit and hit.Parent
	if not char then return end
	local p = Players:GetPlayerFromCharacter(char)
	if p ~= LocalPlayer then return end
	touchDebounce = true
	task.delay(0.6, function() touchDebounce = false end)
	autoClaimIfReady()
end)

-- ===== Live updates =====
RE_Job.OnClientEvent:Connect(function(payload)
	if payload and payload.claimed then
		currentJob = nil
		setBillboardReady()
		ensureSkipPrompt(false)
		stopBillboardTimerLoop()
		populatePicker()
		return
	end
	if payload and payload.finishesAt then
		currentJob = { finishesAt = payload.finishesAt }
		startBillboardTimerLoop(payload.finishesAt)
	end
end)

-- Cash change â†’ refresh requirements
local function onCashChanged()
	if selectedBase then
		showRequirements(selectedBase, currentTier)
	end
end

task.spawn(function()
	local leaderstats = LocalPlayer:WaitForChild("leaderstats", 5)
	if leaderstats then
		local cashStat = leaderstats:FindFirstChild("Cash")
		if cashStat and cashStat:IsA("IntValue") then
			cashStat:GetPropertyChangedSignal("Value"):Connect(onCashChanged)
		end
	end
end)

local CashUpdated = Events:FindFirstChild("CashUpdated")
if CashUpdated and CashUpdated:IsA("RemoteEvent") then
	CashUpdated.OnClientEvent:Connect(function()
		onCashChanged()
	end)
end

-- Init
Gui.Enabled = true
MutationFrame.Visible = false
AfterFrame.Visible = false
DescTitle.Text = "Requirements"
setBillboardReady()
ensureSkipPrompt(false)
stopBillboardTimerLoop()

QuestionMark.Activated:Connect(function()
	-- TODO: tutorial later
end)

---

--- StarterGui.ScreenGui.Settings.SettingsHandler (LocalScript) ---
--!strict
-- SettingsHandler (client)
-- Binds UI immediately; fetches server settings asynchronously (no blocking).

local Players                = game:GetService("Players")
local CollectionService      = game:GetService("CollectionService")
local Lighting               = game:GetService("Lighting")
local ReplicatedStorage      = game:GetService("ReplicatedStorage")
local ContextActionService   = game:GetService("ContextActionService")
local RunService             = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local Root      = LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("ScreenGui"):WaitForChild("Settings")
local OPTIONS   = Root:WaitForChild("Options")
local CloseBtn  = Root:WaitForChild("Close") :: ImageButton

local GREEN = Color3.fromRGB(38, 238, 35)
local RED   = Color3.fromRGB(175, 22, 11)

local Events             = ReplicatedStorage:WaitForChild("Events")
local GetPlayerSettings  = Events:WaitForChild("GetPlayerSettings") :: RemoteFunction
local SavePlayerSettings = Events:WaitForChild("SavePlayerSettings") :: RemoteEvent

-- ============ UI helpers ============
local function setPill(btn: TextButton, enabled: boolean)
	btn.Text = enabled and "Enabled" or "Disabled"
	btn.BackgroundColor3 = enabled and GREEN or RED
	local grad = btn:FindFirstChildOfClass("UIGradient")
	if grad then
		if enabled then
			grad.Color = ColorSequence.new({
				ColorSequenceKeypoint.new(0, Color3.fromRGB(20, 160, 18)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(38, 238, 35)),
			})
		else
			grad.Color = ColorSequence.new({
				ColorSequenceKeypoint.new(0, Color3.fromRGB(120, 10, 6)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(175, 22, 11)),
			})
		end
	end
end

local function rememberBaseVolume(snd: Sound)
	if snd:GetAttribute("BaseVolume") == nil then
		snd:SetAttribute("BaseVolume", snd.Volume)
	end
end

local function applyWeaponSFX(enabled: boolean)
	for _, snd: Sound in ipairs(CollectionService:GetTagged("WeaponSound")) do
		rememberBaseVolume(snd)
		if enabled then
			local base = snd:GetAttribute("BaseVolume")
			if typeof(base) == "number" then snd.Volume = base end
		else
			snd.Volume = 0
		end
	end
end

local function hookWeaponSound(snd: Sound, enabled: boolean)
	rememberBaseVolume(snd)
	if not enabled then snd.Volume = 0 end
end

local function applyMusic(enabled: boolean)
	for _, snd: Sound in ipairs(CollectionService:GetTagged("BGM")) do
		rememberBaseVolume(snd)
		if enabled then
			local base = snd:GetAttribute("BaseVolume")
			if typeof(base) == "number" then snd.Volume = base end
			snd.Looped = true
			if not snd.IsLoaded then snd.Loaded:Wait() end
			if not snd.Playing then snd:Play() end
		else
			snd.Volume = 0
		end
	end
end

local function hookMusicSound(snd: Sound, enabled: boolean)
	rememberBaseVolume(snd)
	if not enabled then
		snd.Volume = 0
	else
		local base = snd:GetAttribute("BaseVolume")
		if typeof(base) == "number" then snd.Volume = base end
	end
end

-- ==== SAFE quality toggles (no permission errors) ====

local function setQualityLow()
	-- Lighting + post FX
	Lighting.GlobalShadows = false
	for _, child in ipairs(Lighting:GetChildren()) do
		if child:IsA("PostEffect") then
			child.Enabled = false
		end
	end

	-- Effects in the world
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") then
			obj.Enabled = false
		elseif obj:IsA("SurfaceAppearance") then
			obj.AlphaMode = Enum.AlphaMode.Overlay
		end
	end

	local terrain = workspace:FindFirstChildOfClass("Terrain")
	if terrain then
		terrain.WaterWaveSize = 0
		terrain.WaterWaveSpeed = 0
		terrain.WaterReflectance = 0
		terrain.WaterTransparency = 1
	end
end

local function setQualityAuto()
	Lighting.GlobalShadows = true
	for _, child in ipairs(Lighting:GetChildren()) do
		if child:IsA("PostEffect") then
			child.Enabled = true
		end
	end

	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") then
			obj.Enabled = true
		elseif obj:IsA("SurfaceAppearance") then
			obj.AlphaMode = Enum.AlphaMode.Overlay
		end
	end

	local terrain = workspace:FindFirstChildOfClass("Terrain")
	if terrain then
		terrain.WaterWaveSize = 0.15
		terrain.WaterWaveSpeed = 10
		terrain.WaterReflectance = 0.25
		terrain.WaterTransparency = 0.3
	end
end

local function applyPerformanceMode(enabled: boolean)
	if enabled then
		setQualityLow()
	else
		setQualityAuto()
	end
end

-- === UI bindings ===
local GunRow  = OPTIONS:WaitForChild("GunAudio") :: Frame
local MusicRow= OPTIONS:WaitForChild("MusicAudio") :: Frame
local QualRow = OPTIONS:WaitForChild("Quality") :: Frame
local GunBtn  = GunRow:WaitForChild("ActivateButton") :: TextButton
local MusicBtn= MusicRow:WaitForChild("ActivateButton") :: TextButton
local QualBtn = QualRow:WaitForChild("ActivateButton") :: TextButton

local function doClose() Root.Visible = false end
CloseBtn.Active = true
CloseBtn.MouseButton1Click:Connect(doClose)
CloseBtn.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.Touch then
		doClose()
	end
end)
ContextActionService:BindAction("CloseSettingsEsc", function(_, state, input)
	if state == Enum.UserInputState.Begin and Root.Visible then
		if input.KeyCode == Enum.KeyCode.Escape or input.KeyCode == Enum.KeyCode.ButtonA then
			doClose()
		end
	end
end, false, Enum.KeyCode.Escape, Enum.KeyCode.ButtonA)

-- === State & application ===
local state = { WeaponSounds = true, Music = true, Performance = false }

local function pushAttributes()
	LocalPlayer:SetAttribute("Setting_WeaponSounds", state.WeaponSounds)
	LocalPlayer:SetAttribute("Setting_Music", state.Music)
	LocalPlayer:SetAttribute("Setting_PerformanceMode", state.Performance)
end

local function applyAll()
	setPill(GunBtn, state.WeaponSounds)
	setPill(MusicBtn, state.Music)
	setPill(QualBtn, state.Performance)
	applyWeaponSFX(state.WeaponSounds)
	applyMusic(state.Music)
	applyPerformanceMode(state.Performance)
	pushAttributes()
end

GunBtn.MouseButton1Click:Connect(function()
	state.WeaponSounds = not state.WeaponSounds
	setPill(GunBtn, state.WeaponSounds)
	applyWeaponSFX(state.WeaponSounds)
	pushAttributes()
	SavePlayerSettings:FireServer(state)
end)

MusicBtn.MouseButton1Click:Connect(function()
	state.Music = not state.Music
	setPill(MusicBtn, state.Music)
	applyMusic(state.Music)
	pushAttributes()
	SavePlayerSettings:FireServer(state)
end)

QualBtn.MouseButton1Click:Connect(function()
	state.Performance = not state.Performance
	setPill(QualBtn, state.Performance)
	applyPerformanceMode(state.Performance)
	pushAttributes()
	SavePlayerSettings:FireServer(state)
end)

-- React to new sounds created after opening
CollectionService:GetInstanceAddedSignal("WeaponSound"):Connect(function(obj)
	if obj:IsA("Sound") then hookWeaponSound(obj, state.WeaponSounds) end
end)
CollectionService:GetInstanceAddedSignal("BGM"):Connect(function(obj)
	if obj:IsA("Sound") then hookMusicSound(obj, state.Music) end
end)

-- Apply defaults immediately so the menu is responsive
applyAll()

task.spawn(function()
	local ok, result = pcall(function()
		return GetPlayerSettings:InvokeServer()
	end)
	if ok and typeof(result) == "table" then
		state = result
		applyAll()
	else
		warn("[Settings] GetPlayerSettings failed/timed out; using defaults")
	end
end)

---

--- StarterGui.ScreenGui.Gift.GiftHandler (LocalScript) ---
--!strict
-- GiftHandler
-- LOCATION: ScreenGui.Gift.GiftHandler (LocalScript)
-- Step 1: list devproducts to gift
-- Step 2: repopulate same list with players for the chosen product

local Players            = game:GetService("Players")
local ReplicatedStorage  = game:GetService("ReplicatedStorage")
local MarketplaceService = game:GetService("MarketplaceService")

local localPlayer  = Players.LocalPlayer
local playerGui    = localPlayer:WaitForChild("PlayerGui")
local screenGui    = playerGui:WaitForChild("ScreenGui")
local giftFrame    = screenGui:WaitForChild("Gift") :: Frame
local shopFrame    = screenGui:WaitForChild("Shop") :: Frame

local EventsFolder             = ReplicatedStorage:WaitForChild("Events")
local GiftProductSelectedEvent = EventsFolder:WaitForChild("GiftProductSelected") :: RemoteEvent

----------------------------------------------------------------
-- Product IDs (must match ShopHandler + ShopController)
----------------------------------------------------------------

local PRODUCT_CASH_5K        = 3433108028
local PRODUCT_CASH_25K       = 3433108213
local PRODUCT_CASH_100K      = 3433108417
local PRODUCT_CASH_300K      = 3433108573

local PRODUCT_SERVERLUCK_X2  = 3446300267
local PRODUCT_SERVERLUCK_X4  = 3446300425
local PRODUCT_SERVERLUCK_X10 = 3446300596

-- All giftable devproducts
local GIFT_PRODUCTS = {
	{
		productId = PRODUCT_CASH_5K,
		label    = "5,000 Cash",
	},
	{
		productId = PRODUCT_CASH_25K,
		label    = "25,000 Cash",
	},
	{
		productId = PRODUCT_CASH_100K,
		label    = "100,000 Cash",
	},
	{
		productId = PRODUCT_CASH_300K,
		label    = "300,000 Cash",
	},
	{
		productId = PRODUCT_SERVERLUCK_X2,
		label    = "x2 Server Luck (15 min)",
	},
	{
		productId = PRODUCT_SERVERLUCK_X4,
		label    = "x4 Server Luck (15 min)",
	},
	{
		productId = PRODUCT_SERVERLUCK_X10,
		label    = "MAX Server Luck (15+ min)",
	},
}

----------------------------------------------------------------
-- UI refs
----------------------------------------------------------------

local container = giftFrame:WaitForChild("Container") :: ScrollingFrame

-- Find one Template we will use as a base
local baseTemplate: Frame? = nil
for _, child in ipairs(container:GetChildren()) do
	if child:IsA("Frame") and child.Name == "Template" then
		baseTemplate = child
		break
	end
end

if not baseTemplate then
	warn("[GiftHandler] No Template found under Gift.Container")
	return
end

baseTemplate.Visible = false -- we never show this original

-- Title label (for mode text)
local function setTitle(text: string)
	local titleRoot = giftFrame:FindFirstChild("Title")
	if titleRoot and titleRoot:IsA("TextLabel") then
		local inner = titleRoot:FindFirstChild("Title")
		if inner and inner:IsA("TextLabel") then
			inner.Text = text
		else
			titleRoot.Text = text
		end
	end
end

----------------------------------------------------------------
-- State
----------------------------------------------------------------

type Mode = "Products" | "Players"

local currentMode: Mode = "Products"
local selectedProductId: number? = nil
local selectedProductLabel: string? = nil

----------------------------------------------------------------
-- Helpers
----------------------------------------------------------------

local function clearRows()
	for _, child in ipairs(container:GetChildren()) do
		if child:IsA("Frame") and child ~= baseTemplate then
			if child:GetAttribute("GiftRow") == true then
				child:Destroy()
			end
		end
	end
end

----------------------------------------------------------------
-- Phase 1: list products
----------------------------------------------------------------

local function populateProducts()
	currentMode = "Products"
	selectedProductId = nil
	selectedProductLabel = nil

	setTitle("Choose what you want to gift")

	clearRows()

	for _, cfg in ipairs(GIFT_PRODUCTS) do
		local row = baseTemplate:Clone()
		row.Visible = true
		row.Parent = container
		row.Name = "GiftProductRow"
		row:SetAttribute("GiftRow", true)

		local settingLabel = row:FindFirstChild("Setting")
		if settingLabel and settingLabel:IsA("TextLabel") then
			settingLabel.Text = cfg.label
		end

		local button = row:FindFirstChild("Button")
		if button and button:IsA("TextButton") then
			local innerFrame = button:FindFirstChild("Frame")
			if innerFrame and innerFrame:IsA("Frame") then
				local textLabel = innerFrame:FindFirstChild("TextLabel")
				if textLabel and textLabel:IsA("TextLabel") then
					textLabel.Text = "Select"
				end
			end

			button.MouseButton1Click:Connect(function()
				-- Go to player selection for this product
				selectedProductId = cfg.productId
				selectedProductLabel = cfg.label
				populatePlayers()
			end)
		end
	end
end

----------------------------------------------------------------
-- Phase 2: list players
----------------------------------------------------------------

function populatePlayers()
	currentMode = "Players"

	local label = selectedProductLabel or "this item"
	setTitle("Choose who receives " .. label)

	clearRows()

	for _, plr in ipairs(Players:GetPlayers()) do
		if plr ~= localPlayer then
			local row = baseTemplate:Clone()
			row.Visible = true
			row.Parent = container
			row.Name = "GiftPlayerRow"
			row:SetAttribute("GiftRow", true)

			local settingLabel = row:FindFirstChild("Setting")
			if settingLabel and settingLabel:IsA("TextLabel") then
				settingLabel.Text = plr.DisplayName .. " (@" .. plr.Name .. ")"
			end

			-- Optional avatar
			local avatarImage = row:FindFirstChild("ImageLabel")
			if avatarImage and avatarImage:IsA("ImageLabel") then
				local thumb, isReady = Players:GetUserThumbnailAsync(
					plr.UserId,
					Enum.ThumbnailType.HeadShot,
					Enum.ThumbnailSize.Size100x100
				)
				if isReady then
					avatarImage.Image = thumb
				end
			end

			local button = row:FindFirstChild("Button")
			if button and button:IsA("TextButton") then
				local innerFrame = button:FindFirstChild("Frame")
				if innerFrame and innerFrame:IsA("Frame") then
					local textLabel = innerFrame:FindFirstChild("TextLabel")
					if textLabel and textLabel:IsA("TextLabel") then
						textLabel.Text = "Gift"
					end
				end

				button.MouseButton1Click:Connect(function()
					if not selectedProductId then return end

					-- Tell server which product + target
					GiftProductSelectedEvent:FireServer(selectedProductId, plr.UserId)

					-- Prompt purchase for local player
					MarketplaceService:PromptProductPurchase(localPlayer, selectedProductId)

					-- After clicking, go back to products + close Gift
					giftFrame.Visible = false
					shopFrame.Visible = true
					populateProducts()
				end)
			end
		end
	end
end

----------------------------------------------------------------
-- UI wiring
----------------------------------------------------------------

-- Close button on Gift frame
do
	local closeButton = giftFrame:FindFirstChild("xbutton")
	if closeButton and closeButton:IsA("TextButton") then
		closeButton.MouseButton1Click:Connect(function()
			-- Reset to product selection on close
			populateProducts()
			giftFrame.Visible = false
			shopFrame.Visible = true
		end)
	end
end

-- When Gift becomes visible, always start at product list
giftFrame:GetPropertyChangedSignal("Visible"):Connect(function()
	if giftFrame.Visible then
		populateProducts()
	end
end)

-- Ensure hidden at start
giftFrame.Visible = false

---

--- StarterGui.ScreenGui.Rebirth.RebirthHandler (LocalScript) ---
--!strict

local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer

local rebirthFrame = script.Parent :: Frame
local container    = rebirthFrame:WaitForChild("Container") :: Frame

-- TOP "You Will Unlock"
local unlockHolder   = container:WaitForChild("Frame"):WaitForChild("Unlock") :: Frame
local unlockTemplate = unlockHolder:WaitForChild("Template") :: Frame

-- BOTTOM "Requirements"
local requirementsFrame   = container:WaitForChild("Requirements") :: Frame
local reqUnlockHolder     = requirementsFrame:WaitForChild("Unlock") :: Frame
local reqTemplate         = reqUnlockHolder:WaitForChild("Template") :: Frame

-- Progress bar inside Requirements
local bar         = requirementsFrame:WaitForChild("Bar") :: Frame
local canvasGroup = bar:WaitForChild("CanvasGroup") :: CanvasGroup
local barFill     = canvasGroup:WaitForChild("Frame") :: Frame
local barText     = canvasGroup:WaitForChild("TextLabel") :: TextLabel

local rebirthButton = container:WaitForChild("Rebirth") :: TextButton

local Modules         = ReplicatedStorage:WaitForChild("Modules")
local NumberFormatter = require(Modules:WaitForChild("NumberFormatter"))

local Functions       = ReplicatedStorage:WaitForChild("Functions")
local GetRebirthState = Functions:WaitForChild("GetRebirthState") :: RemoteFunction

local Events          = ReplicatedStorage:WaitForChild("Events")
local RebirthRequested = Events:WaitForChild("RebirthRequested") :: RemoteEvent

-- Icons
local CASH_ICON = "rbxassetid://80550982841733"
local LUCK_ICON = "rbxassetid://74485910606028"

export type RebirthState = {
	CurrentRebirth: number,
	MaxRebirth: number,
	Cash: number,
	RequiredCash: number,
	MoneyMultiplier: number,
	LuckMultiplier: number,
	CanRebirth: boolean,
	NextIndex: number,
	NextConfig: {
		RequiredCash: number,
		MoneyBonusPercent: number,
		LuckBonusPercent: number,
		UnlockCages: {number}?,
	}?,
}

local currentState: RebirthState? = nil

-- utils --------------------------------------------------------------------

local function clearList(holder: Frame, template: Frame)
	for _, child in ipairs(holder:GetChildren()) do
		if child:IsA("Frame") and child ~= template then
			child:Destroy()
		end
	end
end

local function setTemplateCommon(
	clone: Frame,
	titleText: string,
	amountText: string,
	iconImage: string?
)
	local itemTitle   = clone:FindFirstChild("ItemTitle") :: TextLabel?
	local amountLabel = clone:FindFirstChild("AmountLabel") :: TextLabel?
	local itemImage   = (clone:FindFirstChild("ItemLabel") or clone:FindFirstChild("Item")) :: ImageLabel?

	if itemTitle then
		itemTitle.Text = titleText
	end
	if amountLabel then
		amountLabel.Text = amountText
	end
	if itemImage and iconImage then
		itemImage.Image = iconImage
	end
end

-- top â€œYou Will Unlockâ€ cards ----------------------------------------------

local function populateUnlocks(nextCfg: any, nextIndex: number)
	clearList(unlockHolder, unlockTemplate)
	unlockTemplate.Visible = false
	if not nextCfg then return end

	type Reward = { Title: string, Amount: string, Icon: string? }
	local rewards: {Reward} = {}

	if (nextCfg.MoneyBonusPercent or 0) > 0 then
		table.insert(rewards, {
			Title  = "Money Boost",
			Amount = ("+%d%% Money"):format(nextCfg.MoneyBonusPercent),
			Icon   = CASH_ICON,
		})
	end

	if (nextCfg.LuckBonusPercent or 0) > 0 then
		table.insert(rewards, {
			Title  = "Luck Boost",
			Amount = ("+%d%% Luck"):format(nextCfg.LuckBonusPercent),
			Icon   = LUCK_ICON,
		})
	end

	if nextCfg.UnlockCages then
		for _, cageIdx in ipairs(nextCfg.UnlockCages) do
			table.insert(rewards, {
				Title  = ("Cage %d"):format(cageIdx),
				Amount = "Unlocked",
				Icon   = CASH_ICON, -- or some â€œcageâ€ icon if you make one later
			})
		end
	end

	for _, r in ipairs(rewards) do
		local clone = unlockTemplate:Clone()
		clone.Visible = true
		clone.Name = "Reward"

		setTemplateCommon(clone, r.Title, r.Amount, r.Icon)

		clone.Parent = unlockHolder
	end
end

-- bottom â€œRequirementsâ€ cards ---------------------------------------------

local function populateRequirements(state: RebirthState?)
	clearList(reqUnlockHolder, reqTemplate)
	reqTemplate.Visible = false

	if not state then return end

	local requiredCash = state.RequiredCash or 0
	if requiredCash <= 0 then
		return
	end

	local clone = reqTemplate:Clone()
	clone.Visible = true
	clone.Name = "Requirement"

	local amountText = ("$%s")
		:format(NumberFormatter.formatNumber(requiredCash))

	setTemplateCommon(clone, "Cash", amountText, CASH_ICON)

	clone.Parent = reqUnlockHolder
end

-- main refresh -------------------------------------------------------------

local function refreshUI()
	local state = GetRebirthState:InvokeServer() :: RebirthState?
	currentState = state

	if not state then
		barFill.Size = UDim2.new(0, 0, 1, 0)
		barText.Text = "$0/0"
		clearList(unlockHolder, unlockTemplate)
		clearList(reqUnlockHolder, reqTemplate)
		rebirthButton.AutoButtonColor = false
		rebirthButton.Active = false
		return
	end

	local cash     = state.Cash or 0
	local required = state.RequiredCash or 0
	local frac     = 0
	if required > 0 then
		frac = math.clamp(cash / required, 0, 1)
	end

	barFill.Size = UDim2.new(frac, 0, 1, 0)
	barText.Text = ("$%s / %s")
		:format(NumberFormatter.formatNumber(cash), NumberFormatter.formatNumber(required))

	populateUnlocks(state.NextConfig, state.NextIndex)
	populateRequirements(state)

	if state.CanRebirth then
		rebirthButton.AutoButtonColor = true
		rebirthButton.Active = true
	else
		rebirthButton.AutoButtonColor = false
		rebirthButton.Active = false
	end
end

-- events -------------------------------------------------------------------

rebirthButton.MouseButton1Click:Connect(function()
	if not currentState or not currentState.CanRebirth then return end
	RebirthRequested:FireServer()
	task.delay(0.1, refreshUI)
end)

rebirthFrame:GetPropertyChangedSignal("Visible"):Connect(function()
	if rebirthFrame.Visible then
		refreshUI()
	end
end)

task.delay(1, refreshUI)

---

--- StarterGui.ScreenGui.Shop.ShopHandler (LocalScript) ---
--!strict
-- ShopHandler
-- LOCATION: ScreenGui.Shop.ShopHandler (LocalScript)
-- Wires the new Shop UI to MarketplaceService.

local Players            = game:GetService("Players")
local ReplicatedStorage  = game:GetService("ReplicatedStorage")
local MarketplaceService = game:GetService("MarketplaceService")

local Modules            = ReplicatedStorage:WaitForChild("Modules")
local NumberFormatter    = require(Modules:WaitForChild("NumberFormatter"))

local EventsFolder         = ReplicatedStorage:WaitForChild("Events")
local ServerLuckStateEvent = EventsFolder:WaitForChild("ServerLuckState") :: RemoteEvent

local player     = Players.LocalPlayer
local playerGui  = player:WaitForChild("PlayerGui")
local screenGui  = playerGui:WaitForChild("ScreenGui")
local shopFrame  = script.Parent :: Frame
local giftFrame  = screenGui:FindFirstChild("Gift") :: Frame?

-- Cache for prices
local robuxPricesCache: {[number]: string} = {}

----------------------------------------------------------------
-- Helpers
----------------------------------------------------------------

local function setPriceLabel(label: TextLabel, id: number, infoType: Enum.InfoType)
	if id == 0 then
		label.Text = "N/A"
		return
	end

	if robuxPricesCache[id] then
		label.Text = robuxPricesCache[id]
		return
	end

	label.Text = "..."

	task.spawn(function()
		local success, info = pcall(function()
			return MarketplaceService:GetProductInfo(id, infoType)
		end)

		if success and info and label.Parent then
			local priceText = "î€‚" .. tostring(info.PriceInRobux)
			robuxPricesCache[id] = priceText
			label.Text = priceText
		elseif label.Parent then
			label.Text = "N/A"
		end
	end)
end

local function wireDevProductButton(
	button: TextButton,
	priceLabel: TextLabel,
	productId: number
)
	setPriceLabel(priceLabel, productId, Enum.InfoType.Product)

	button.MouseButton1Click:Connect(function()
		if productId == 0 then
			warn("[ShopHandler] DevProductId = 0, button has no product set:", button:GetFullName())
			return
		end

		MarketplaceService:PromptProductPurchase(player, productId)
	end)
end

local function wireGamepassButton(
	button: TextButton,
	priceLabel: TextLabel,
	gamePassId: number
)
	setPriceLabel(priceLabel, gamePassId, Enum.InfoType.GamePass)

	button.MouseButton1Click:Connect(function()
		if gamePassId == 0 then
			warn("[ShopHandler] GamePassId = 0, button has no gamepass set:", button:GetFullName())
			return
		end

		MarketplaceService:PromptGamePassPurchase(player, gamePassId)
	end)
end

----------------------------------------------------------------
-- CONFIG
----------------------------------------------------------------

local DEV_PRODUCTS = {
	-- Cash
	Money = {
		One = {
			productId = 3433108028, -- 5k cash
			cashAmount = 5_000,
		},
		Two = {
			productId = 3433108213, -- 25k cash
			cashAmount = 25_000,
		},
		Three = {
			productId = 3433108417, -- 100k cash
			cashAmount = 100_000,
		},
	},
	Money2 = {
		Four = {
			productId = 3433108573, -- 300k cash
			cashAmount = 300_000,
		},
		MoneyOffer = {
			productId = 3466012642, -- Test Devproduct (special offer)
			cashAmount = 0,
		},
	},

	-- Potions (Money, Luck, Damage) â€“ all using Test Devproduct for now
	Potions = {
		MoneyPotion  = 3466012642,
		LuckPotion   = 3466012642,
		DamagePotion = 3466012642,
	},

	-- Limited eggs â€“ all Test Devproduct for now
	Limited = {
		BuyOne   = 3466012642,
		BuyThree = 3466012642,
		BuyTen   = 3466012642,
	},
}

-- Server luck product ids
local SERVER_LUCK_PRODUCTS = {
	X2 = {
		productId = 3446300267, -- 2x (299R$)
	},
	X4 = {
		productId = 3446300425, -- 4x (799R$)
	},
	X10 = {
		productId = 3446300596, -- Max (x10, 999R$)
	},
}

-- GAMEPASSES â€“ wired IDs
local GAMEPASSES = {
	VIP = {
		gamePassId = 1603639665, -- VIP
	},
	["2xMoney"] = {
		gamePassId = 0, -- TODO: 2x money gamepass ID (if you add one)
	},
	ExtraCrateSlots = {
		gamePassId = 0, -- TODO: extra crate slots gamepass ID (if you add one)
	},
	SmallLuck = {
		gamePassId = 1605301776, -- Small luck boost
	},
	BigLuck = {
		gamePassId = 1604617757, -- Godly (huge) luck boost
	},
}

----------------------------------------------------------------
-- Wiring: Money
----------------------------------------------------------------

local container = shopFrame:WaitForChild("Container") :: ScrollingFrame

local function setupMoney()
	local moneyFrame = container:WaitForChild("Money") :: Frame
	local money2Frame = container:WaitForChild("Money2") :: Frame

	-- Money.One (5k)
	do
		local cfg = DEV_PRODUCTS.Money.One
		local card = moneyFrame:WaitForChild("One") :: Frame

		local buy = card:WaitForChild("Buy") :: TextButton
		local buyFrame = buy:WaitForChild("Frame") :: Frame
		local priceLabel = buyFrame:WaitForChild("Amount") :: TextLabel

		local icon = card:WaitForChild("Icon") :: ImageLabel
		local amountLabel = icon:WaitForChild("Amount") :: TextLabel
		amountLabel.Text = NumberFormatter.formatNumber(cfg.cashAmount)

		wireDevProductButton(buy, priceLabel, cfg.productId)
	end

	-- Money.Two (25k)
	do
		local cfg = DEV_PRODUCTS.Money.Two
		local card = moneyFrame:WaitForChild("Two") :: Frame

		local buy = card:WaitForChild("Buy") :: TextButton
		local buyFrame = buy:WaitForChild("Frame") :: Frame
		local priceLabel = buyFrame:WaitForChild("Amount") :: TextLabel

		local icon = card:WaitForChild("Icon") :: ImageLabel
		local amountLabel = icon:WaitForChild("Amount") :: TextLabel
		amountLabel.Text = NumberFormatter.formatNumber(cfg.cashAmount)

		wireDevProductButton(buy, priceLabel, cfg.productId)
	end

	-- Money.Three (100k)
	do
		local cfg = DEV_PRODUCTS.Money.Three
		local card = moneyFrame:WaitForChild("Three") :: Frame

		local buy = card:WaitForChild("Buy") :: TextButton
		local buyFrame = buy:WaitForChild("Frame") :: Frame
		local priceLabel = buyFrame:WaitForChild("TextLabel") :: TextLabel

		local icon = card:WaitForChild("Icon") :: ImageLabel
		local amountLabel = icon:WaitForChild("TextLabel") :: TextLabel
		amountLabel.Text = NumberFormatter.formatNumber(cfg.cashAmount)

		wireDevProductButton(buy, priceLabel, cfg.productId)
	end

	-- Money2.Four (300k)
	do
		local cfg = DEV_PRODUCTS.Money2.Four
		local card = money2Frame:WaitForChild("Four") :: Frame

		local buy = card:WaitForChild("Buy") :: TextButton
		local buyFrame = buy:WaitForChild("Frame") :: Frame
		local priceLabel = buyFrame:WaitForChild("Amount") :: TextLabel

		local icon = card:WaitForChild("Icon") :: ImageLabel
		local amountLabel = icon:WaitForChild("Amount") :: TextLabel
		amountLabel.Text = NumberFormatter.formatNumber(cfg.cashAmount)

		wireDevProductButton(buy, priceLabel, cfg.productId)
	end

	-- Money2.MoneyOffer (special offer, Test Devproduct)
	do
		local cfg = DEV_PRODUCTS.Money2.MoneyOffer
		local card = money2Frame:WaitForChild("MoneyOffer") :: Frame

		local buy = card:WaitForChild("Buy") :: TextButton
		local buyFrame = buy:WaitForChild("Frame") :: Frame
		local priceLabel = buyFrame:WaitForChild("Amount") :: TextLabel

		if cfg.cashAmount > 0 then
			local icon = card:WaitForChild("Icon") :: ImageLabel
			local amountLabel = icon:WaitForChild("Amount") :: TextLabel
			amountLabel.Text = NumberFormatter.formatNumber(cfg.cashAmount)
		end

		wireDevProductButton(buy, priceLabel, cfg.productId)
	end
end

----------------------------------------------------------------
-- Wiring: Server Luck (upgrade path 2x -> 4x -> MAX, with time left)
----------------------------------------------------------------

local function setupServerLuck()
	local frame = container:WaitForChild("ServerLuck") :: Frame
	local holder = frame:WaitForChild("Holder") :: Frame
	local luckLabel = holder:WaitForChild("Luck") :: TextLabel
	local timeLabel = holder:WaitForChild("Time") :: TextLabel

	local buy = frame:WaitForChild("Buy") :: TextButton
	local buyFrame = buy:WaitForChild("Frame") :: Frame
	local priceLabel = buyFrame:WaitForChild("Amount") :: TextLabel

	local currentMulti = 1
	local remainingSeconds = 0
	local countdownRunning = false

	local function getTimeText(): string
		if remainingSeconds <= 0 then
			return "15 minutes"
		end
		local minutes = math.ceil(remainingSeconds / 60)
		return string.format("%d minutes left", minutes)
	end

	local function refresh()
		local nextProductId: number? = nil

		if currentMulti < 2 then
			-- Base -> 2x
			luckLabel.Text = "x2 Server Luck"
			timeLabel.Text = getTimeText()
			nextProductId = SERVER_LUCK_PRODUCTS.X2.productId

		elseif currentMulti < 4 then
			-- 2x -> 4x
			luckLabel.Text = "2x > 4x Server Luck"
			timeLabel.Text = getTimeText()
			nextProductId = SERVER_LUCK_PRODUCTS.X4.productId

		elseif currentMulti < 10 then
			-- 4x -> MAX
			luckLabel.Text = "4x > MAX Server Luck"
			timeLabel.Text = getTimeText()
			nextProductId = SERVER_LUCK_PRODUCTS.X10.productId

		else
			-- Already maxed (10x); can still buy more time with MAX product
			luckLabel.Text = "MAX Server Luck"
			timeLabel.Text = getTimeText()
			nextProductId = SERVER_LUCK_PRODUCTS.X10.productId
		end

		buy.AutoButtonColor = true
		buy.Active = true
		buy:SetAttribute("ProductId", nextProductId)

		if nextProductId then
			setPriceLabel(priceLabel, nextProductId, Enum.InfoType.Product)
		else
			priceLabel.Text = "N/A"
		end
	end

	local function startCountdown()
		if countdownRunning then return end
		countdownRunning = true

		task.spawn(function()
			while true do
				if remainingSeconds <= 0 then
					countdownRunning = false
					break
				end
				task.wait(1)
				remainingSeconds -= 1
				if remainingSeconds < 0 then remainingSeconds = 0 end
				refresh()
			end
		end)
	end

	-- Sync from server attributes at start (in case buff is already active)
	do
		local multAttr = ReplicatedStorage:GetAttribute("ServerLuckMultiplier")
		local expAttr  = ReplicatedStorage:GetAttribute("ServerLuckExpiresAt")

		if typeof(multAttr) == "number" then
			currentMulti = multAttr :: number
		end

		if typeof(expAttr) == "number" then
			local now = os.time()
			remainingSeconds = math.max(0, (expAttr :: number) - now)
		end
	end

	-- When server tells us the multiplier/time changed, update the card
	ServerLuckStateEvent.OnClientEvent:Connect(function(mult: number, remaining: number)
		if typeof(mult) == "number" then
			currentMulti = mult
		end
		if typeof(remaining) == "number" then
			remainingSeconds = math.max(0, remaining)
		end
		refresh()
		if remainingSeconds > 0 then
			startCountdown()
		end
	end)

	-- Clicking the Buy button buys the "next tier" (or extends MAX)
	buy.MouseButton1Click:Connect(function()
		local productId = buy:GetAttribute("ProductId")
		if typeof(productId) == "number" and productId > 0 then
			MarketplaceService:PromptProductPurchase(player, productId)
		end
	end)

	-- Initial UI
	refresh()
	if remainingSeconds > 0 then
		startCountdown()
	end
end

----------------------------------------------------------------
-- Wiring: Potions (Money / Luck / Damage) â€“ all Test Devproduct
----------------------------------------------------------------

local function setupPotions()
	local gears = container:WaitForChild("Gears") :: Frame

	-- MoneyPotion
	do
		local card = gears:WaitForChild("MoneyPotion") :: Frame
		local buy = card:WaitForChild("Buy") :: TextButton
		local buyFrame = buy:WaitForChild("Frame") :: Frame
		local priceLabel = buyFrame:WaitForChild("Labels") :: TextLabel

		local productId = DEV_PRODUCTS.Potions.MoneyPotion
		wireDevProductButton(buy, priceLabel, productId)
	end

	-- LuckPotion
	do
		local card = gears:WaitForChild("LuckPotion") :: Frame
		local buy = card:WaitForChild("Buy") :: TextButton
		local buyFrame = buy:WaitForChild("Frame") :: Frame
		local priceLabel = buyFrame:WaitForChild("Labels") :: TextLabel

		local productId = DEV_PRODUCTS.Potions.LuckPotion
		wireDevProductButton(buy, priceLabel, productId)
	end

	-- DamagePotion
	do
		local card = gears:WaitForChild("DamagePotion") :: Frame
		local buy = card:WaitForChild("Buy") :: TextButton
		local buyFrame = buy:WaitForChild("Frame") :: Frame
		local priceLabel = buyFrame:WaitForChild("Labels") :: TextLabel

		local productId = DEV_PRODUCTS.Potions.DamagePotion
		wireDevProductButton(buy, priceLabel, productId)
	end

	-- Optional: OfferTemplate in Gears uses Test devproduct as well
	local offerTemplate = gears:FindFirstChild("OfferTemplate")
	if offerTemplate and offerTemplate:IsA("Frame") then
		local buy = offerTemplate:WaitForChild("Buy") :: TextButton
		local buyFrame = buy:WaitForChild("Frame") :: Frame
		local priceLabel = buyFrame:WaitForChild("Amount") :: TextLabel
		wireDevProductButton(buy, priceLabel, 3466012642)
	end
end

----------------------------------------------------------------
-- Wiring: Limited eggs (all Test Devproduct for now)
----------------------------------------------------------------

local function setupLimited()
	local limited = container:WaitForChild("Limited") :: Frame
	local buyOptions = limited:WaitForChild("BuyOptions") :: Frame

	-- BuyOne
	do
		local button = buyOptions:WaitForChild("BuyOne") :: TextButton
		local frame = button:WaitForChild("Frame") :: Frame
		local priceLabel = frame:WaitForChild("Amount") :: TextLabel
		wireDevProductButton(button, priceLabel, DEV_PRODUCTS.Limited.BuyOne)
	end

	-- BuyThree
	do
		local button = buyOptions:WaitForChild("BuyThree") :: TextButton
		local frame = button:WaitForChild("Frame") :: Frame
		local priceLabel = frame:WaitForChild("Amount") :: TextLabel
		wireDevProductButton(button, priceLabel, DEV_PRODUCTS.Limited.BuyThree)
	end

	-- BuyTen
	do
		local button = buyOptions:WaitForChild("Buy10") :: TextButton
		local frame = button:WaitForChild("Frame") :: Frame
		local priceLabel = frame:WaitForChild("Amount") :: TextLabel
		wireDevProductButton(button, priceLabel, DEV_PRODUCTS.Limited.BuyTen)
	end
end

----------------------------------------------------------------
-- Wiring: Gamepasses
----------------------------------------------------------------

local function setupGamepasses()
	-- VIP big card
	do
		local vipCard = container:WaitForChild("VIPGamepass") :: Frame
		local buy = vipCard:WaitForChild("Buy") :: TextButton
		local buyFrame = buy:WaitForChild("Frame") :: Frame
		local priceLabel = buyFrame:WaitForChild("Amount") :: TextLabel

		wireGamepassButton(buy, priceLabel, GAMEPASSES.VIP.gamePassId)
	end

	-- Other gamepasses in the Gamepasses frame (2xMoney, ExtraCrateSlots, SmallLuck, BigLuck)
	local gpasses = container:WaitForChild("Gamepasses") :: Frame

	-- 2xMoney
	do
		local card = gpasses:WaitForChild("2xMoney") :: Frame
		local buy = card:WaitForChild("Buy") :: TextButton
		local buyFrame = buy:WaitForChild("Frame") :: Frame
		local priceLabel = buyFrame:WaitForChild("Labels") :: TextLabel

		wireGamepassButton(buy, priceLabel, GAMEPASSES["2xMoney"].gamePassId)
	end

	-- ExtraCrateSlots
	do
		local card = gpasses:WaitForChild("ExtraCrateSlots") :: Frame
		local buy = card:WaitForChild("Buy") :: TextButton
		local buyFrame = buy:WaitForChild("Frame") :: Frame
		local priceLabel = buyFrame:WaitForChild("Labels") :: TextLabel

		wireGamepassButton(buy, priceLabel, GAMEPASSES.ExtraCrateSlots.gamePassId)
	end

	-- SmallLuck
	do
		local card = gpasses:WaitForChild("SmallLuck") :: Frame
		local buy = card:WaitForChild("Buy") :: TextButton
		local buyFrame = buy:WaitForChild("Frame") :: Frame
		local priceLabel = buyFrame:WaitForChild("Labels") :: TextLabel

		wireGamepassButton(buy, priceLabel, GAMEPASSES.SmallLuck.gamePassId)
	end

	-- BigLuck
	do
		local card = gpasses:WaitForChild("BigLuck") :: Frame
		local buy = card:WaitForChild("Buy") :: TextButton
		local buyFrame = buy:WaitForChild("Frame") :: Frame
		local priceLabel = buyFrame:WaitForChild("Labels") :: TextLabel

		wireGamepassButton(buy, priceLabel, GAMEPASSES.BigLuck.gamePassId)
	end
end

----------------------------------------------------------------
-- Gift + Close buttons (simple wiring)
----------------------------------------------------------------

local function setupFrameButtons()
	-- Close button (xbutton)
	local closeButton = shopFrame:FindFirstChild("xbutton")
	if closeButton and closeButton:IsA("TextButton") then
		closeButton.MouseButton1Click:Connect(function()
			shopFrame.Visible = false
		end)
	end

	-- Gift button (open Gift frame)
	local giftButton = shopFrame:FindFirstChild("Gift")
	if giftButton and giftButton:IsA("TextButton") and giftFrame then
		giftButton.MouseButton1Click:Connect(function()
			shopFrame.Visible = false
			giftFrame.Visible = true
		end)
	end
end

----------------------------------------------------------------
-- Init
----------------------------------------------------------------

setupMoney()
setupServerLuck()
setupPotions()
setupLimited()
setupGamepasses()
setupFrameButtons()

---

--- StarterGui.ScreenGui.Shop.StoreSoundHandler (LocalScript) ---
--!strict
-- StoreSoundHandler
-- LOCATION: ScreenGui.Shop.StoreSoundHandler (LocalScript)
-- Plays a sound when the Shop frame becomes visible.

local frame = script.Parent :: Instance
if not frame:IsA("Frame") then
	warn("[StoreSoundHandler] Parent is not a Frame:", frame:GetFullName())
	return
end

-- Put a Sound named "StoreSound" directly under the Shop frame
local storeSound = frame:FindFirstChild("StoreSound")
if not storeSound or not storeSound:IsA("Sound") then
	warn("[StoreSoundHandler] Could not find a valid 'StoreSound' under", frame:GetFullName())
	return
end

frame:GetPropertyChangedSignal("Visible"):Connect(function()
	if frame.Visible then
		storeSound:Play()
	end
end)

---

--- StarterGui.ScreenGui.AdminPanel.AdminPanelHandler (LocalScript) ---
--!strict
-- StarterGui.ScreenGui.AdminPanel.AdminPanelHandler

local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer

----------------------------------------------------------------
-- Admin whitelist (CLIENT-SIDE UI access)
----------------------------------------------------------------
local ADMIN_USER_IDS: {[number]: boolean} = {
	[936563031] = true, -- you
	[102527104] = true, -- Chuffy
}

-- If not admin, hide panel + kill script
local panel = script.Parent :: Frame
if not ADMIN_USER_IDS[player.UserId] then
	panel.Visible = false
	script.Disabled = true
	return
end

----------------------------------------------------------------
-- Remotes
----------------------------------------------------------------
local eventsFolder = ReplicatedStorage:WaitForChild("Events")
local AdminCommand = eventsFolder:WaitForChild("AdminCommand") :: RemoteEvent

----------------------------------------------------------------
-- UI refs (match your UI tree)
----------------------------------------------------------------
local TitleLabel          = panel:WaitForChild("Title") :: TextLabel

local GiveCashButton      = panel:WaitForChild("GiveCashButton") :: TextButton
local CashAmountBox       = panel:WaitForChild("CashAmount") :: TextBox
local CashTargetBox       = panel:WaitForChild("CashTarget") :: TextBox

local GiveUnitButton      = panel:WaitForChild("GiveUnitButton") :: TextButton
local UnitIdBox           = panel:WaitForChild("UnitId") :: TextBox
local UnitAmountBox       = panel:WaitForChild("UnitAmount") :: TextBox
local UnitTargetBox       = panel:WaitForChild("UnitTarget") :: TextBox

local GiveCowboyButton    = panel:WaitForChild("GiveCowboyButton") :: TextButton
local CowboyIdBox         = panel:WaitForChild("CowboyId") :: TextBox
local CowboyAmountBox     = panel:WaitForChild("CowboyAmount") :: TextBox
local CowboyTargetBox     = panel:WaitForChild("CowboyTarget") :: TextBox

local ForceStockButton    = panel:WaitForChild("ForceStockButton") :: TextButton
local StockWhichBox       = panel:WaitForChild("StockWhich") :: TextBox
local StockTargetBox      = panel:WaitForChild("StockTarget") :: TextBox

local SunshineButton      = panel:WaitForChild("SunshineButton") :: TextButton
local FestiveButton       = panel:WaitForChild("FestiveButton") :: TextButton
local BothWeatherButton   = panel:WaitForChild("BothWeatherButton") :: TextButton
local ClearWeatherButton  = panel:WaitForChild("ClearWeatherButton") :: TextButton

TitleLabel.Text = "ADMIN PANEL"

----------------------------------------------------------------
-- Helpers
----------------------------------------------------------------
local function scopeFromBox(box: TextBox): (string, string?)
	local txt = string.lower(box.Text or "")
	if txt == "" or txt == "all" or txt == "*" then
		return "All", nil
	end
	return "Player", box.Text
end

----------------------------------------------------------------
-- Buttons
----------------------------------------------------------------

-- Give Cash
GiveCashButton.MouseButton1Click:Connect(function()
	local amount = tonumber(CashAmountBox.Text) or 0
	if amount <= 0 then return end

	local scope, targetName = scopeFromBox(CashTargetBox)

	AdminCommand:FireServer({
		Type = "GiveCash",
		Args = {
			scope      = scope,
			playerName = targetName,
			amount     = amount,
		},
	})
end)

-- Give Unit
GiveUnitButton.MouseButton1Click:Connect(function()
	local unitId = UnitIdBox.Text
	if unitId == "" then return end

	local amount = tonumber(UnitAmountBox.Text) or 1
	if amount <= 0 then amount = 1 end

	local scope, targetName = scopeFromBox(UnitTargetBox)

	AdminCommand:FireServer({
		Type = "GiveUnit",
		Args = {
			scope      = scope,
			playerName = targetName,
			unitId     = unitId,
			amount     = amount,
		},
	})
end)

-- Give Cowboy (turret)
GiveCowboyButton.MouseButton1Click:Connect(function()
	local unitId = CowboyIdBox.Text
	if unitId == "" then return end

	local amount = tonumber(CowboyAmountBox.Text) or 1
	if amount <= 0 then amount = 1 end

	local scope, targetName = scopeFromBox(CowboyTargetBox)

	AdminCommand:FireServer({
		Type = "GiveCowboy",
		Args = {
			scope      = scope,
			playerName = targetName,
			unitId     = unitId,
			amount     = amount,
		},
	})
end)

-- Force shop stock
ForceStockButton.MouseButton1Click:Connect(function()
	local which = StockWhichBox.Text
	if which == "" then which = "Both" end -- default

	local scope, targetName = scopeFromBox(StockTargetBox)

	AdminCommand:FireServer({
		Type = "ForceShopStock",
		Args = {
			scope      = scope,
			playerName = targetName,
			which      = which, -- "Blocks", "Weapons" or "Both"
		},
	})
end)

-- Weather buttons
SunshineButton.MouseButton1Click:Connect(function()
	AdminCommand:FireServer({
		Type = "ForceWeather",
		Args = { mode = "Sunshine" },
	})
end)

FestiveButton.MouseButton1Click:Connect(function()
	AdminCommand:FireServer({
		Type = "ForceWeather",
		Args = { mode = "Festive" },
	})
end)

BothWeatherButton.MouseButton1Click:Connect(function()
	AdminCommand:FireServer({
		Type = "ForceWeather",
		Args = { mode = "Both" },
	})
end)

ClearWeatherButton.MouseButton1Click:Connect(function()
	AdminCommand:FireServer({
		Type = "ForceWeather",
		Args = { mode = "Clear" },
	})
end)

-- Close button
local closeBtn = panel:WaitForChild("CloseButton")
closeBtn.MouseButton1Click:Connect(function()
	panel.Visible = false
end)


----------------------------------------------------------------
-- Chat command to open/close: "/Chuffy"
----------------------------------------------------------------
panel.Visible = false

player.Chatted:Connect(function(message: string)
	if string.lower(message) == "/chuffy" then
		panel.Visible = not panel.Visible
	end
end)

---