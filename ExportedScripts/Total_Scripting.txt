
--- BadgeConfigurations (ModuleScript) :
--!strict
-- Central place for all badge IDs

export type BadgeKey =
	"You played!" |
"Acquired Revolver Cowboy" |
"Acquired Akimbo Cowboy" |
"Acquired Uzi Cowboy" |
"Acquired Shotgun Cowboy" |
"Acquired Heavy Gunner" |
"Acquired Rifle Cowboy" |
"Acquired Mortar Cowboy" |
"First Mutation"

local BadgeCatalog: {[BadgeKey]: number} = {
	["You played!"]                 = 3052525153404258,
	["Acquired Revolver Cowboy"]    = 591671251623280,
	["Acquired Akimbo Cowboy"]      = 3467287377539020,
	["Acquired Uzi Cowboy"]         = 583789044141476,
	["Acquired Shotgun Cowboy"]     = 84885666466521,
	["Acquired Heavy Gunner"]       = 2468150254651967,
	["Acquired Rifle Cowboy"]       = 3063311694654024,
	["Acquired Mortar Cowboy"]      = 801395319305690,
	["First Mutation"]              = 1504419190804543,
}

return BadgeCatalog

---

--- DamageHandler (ModuleScript) :
--!strict
-- Located in: ReplicatedStorage/Modules/DamageHandler.lua

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local HighlightZombie = ReplicatedStorage.Events:WaitForChild("HighlightZombie")

local DamageHandler = {}

function DamageHandler.dealDamage(source: Instance, target: Instance, damageAmount: number): boolean
	if not target or not target.Parent then return false end

	local humanoid = target:FindFirstChildOfClass("Humanoid")
	local healthAttribute = target:GetAttribute("Health")

	if humanoid then
		humanoid:TakeDamage(damageAmount)

		-- Only highlight if the target is still alive
		if humanoid.Health > 0 then
			HighlightZombie:FireAllClients(target)
		end

		return humanoid.Health <= 0

	elseif typeof(healthAttribute) == "number" then
		local newHealth = healthAttribute - damageAmount
		target:SetAttribute("Health", newHealth)

		if newHealth <= 0 then
			if target.Name ~= "PlotHealth" then
				target:Destroy()
			end
			return true
		end
	end

	return false
end

return DamageHandler
---

--- EnemyConfigurations (ModuleScript) :
--!strict
-- This module contains data for each enemy type.

local EnemyConfigurations = {
	["Normal Zombie"] = {
		CashReward = 5,
		MaxHealth = 85,
		Damage = 10,
	},
	["Ghost Zombie"] = {
		CashReward = 10,
		MaxHealth = 100,
		Damage = 15,
	},
	["Ice Zombie"] = {
		CashReward = 15,
		MaxHealth = 150,
		Damage = 20,
	},
	["Fire Zombie"] = {
		CashReward = 20,
		MaxHealth = 190,
		Damage = 25,
	},
	["Toxic Zombie"] = {
		CashReward = 25,
		MaxHealth = 240,
		Damage = 30,
	},
	["Skeleton"] = {
		CashReward = 10,
		MaxHealth = 90,
		Damage = 15,
	},
	["Angry Miner"] = {
		CashReward = 13,
		MaxHealth = 135,
		Damage = 15,
	},
	["Half Skeletal"] = {
		CashReward = 20,
		MaxHealth = 105,
		Damage = 20,
	},
	["Explosive Boy"] = {
		CashReward = 40,
		MaxHealth = 245,
		Damage = 35,
	},
	["RogueCowboy"] = {
		CashReward = 25,
		MaxHealth = 130,
		Damage = 25,
	},
	["SkullHead"] = {
		CashReward = 20,
		MaxHealth = 135,
		Damage = 25,
	},
	["Looter Caravan"] = {
		CashReward = 30,
		MaxHealth = 300,
		Damage = 40,
	},
	["Alien Bandit"] = {
		CashReward = 30,
		MaxHealth = 250,
		Damage = 65,
	},
	["Rider Villain"] = {
		CashReward = 30,
		MaxHealth = 250,
		Damage = 65,
	},
	["Ghost Cowboy"] = {
		CashReward = 33,
		MaxHealth = 160,
		Damage = 70,
	},
	
	
	
	-- BOSS
	["Ghost Rider"] = {
		CashReward = 1100,
		MaxHealth = 1640,
		Damage = 60,
	},
	["Noob Boss"] = {
		CashReward = 950,
		MaxHealth = 1640,
		Damage = 55,
	},
	["Jandel Boss"] = {
		CashReward = 1300,
		MaxHealth = 1640,
		Damage = 65,
	},
	["Shedletsky Boss"] = {
		CashReward = 1000,
		MaxHealth = 1640,
		Damage = 60,
	},
	["Drooling Zombie"] = {
		CashReward = 1050,
		MaxHealth = 1640,
		Damage = 64,
	},
	["Zombie Boss"] = {
		CashReward = 950,
		MaxHealth = 1640,
		Damage = 60,
	},
	["Void Boss"] = {
		CashReward = 1500,
		MaxHealth = 1640,
		Damage = 63,
	},
	["Bacon Boss"] = {
		CashReward = 950,
		MaxHealth = 1640,
		Damage = 56,
	},
	["Pumpkin Alien"] = {
		CashReward = 1050,
		MaxHealth = 1640,
		Damage = 65,
	},
	["Pumpkin Reaper"] = {
		CashReward = 1050,
		MaxHealth = 1640,
		Damage = 65,
	},
}

return EnemyConfigurations
---

--- FrameManager (ModuleScript) :
--!strict

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local FrameManager = {}

-- Event system to broadcast frame state changes
local frameOpenedCallbacks = {}
local frameClosedCallbacks = {}

function FrameManager.onFrameOpened(callback: (frameName: string) -> ())
	table.insert(frameOpenedCallbacks, callback)
end

function FrameManager.onFrameClosed(callback: (frameName: string) -> ())
	table.insert(frameClosedCallbacks, callback)
end

local playerGui: PlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
local framesContainer: Folder = playerGui:WaitForChild("GUI"):WaitForChild("Frames")
local TWEEN_INFO: TweenInfo = TweenInfo.new(0.4, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)

local currentlyOpenFrame: Frame? = nil
local framePositions: {[Frame]: UDim2} = {}
local activeTweens: {[Frame]: {Animation: Tween, CleanupThread: thread?}} = {} -- ## ADDED ##

-- ## NEW FUNCTION ## Safely cancels any ongoing tween and its cleanup task for a given frame.
local function cancelActiveTween(frame: Frame)
	local activeTweenInfo = activeTweens[frame]
	if activeTweenInfo then
		activeTweenInfo.Animation:Cancel()
		if activeTweenInfo.CleanupThread then
			task.cancel(activeTweenInfo.CleanupThread)
		end
		activeTweens[frame] = nil
	end
end

function FrameManager.getOpenFrameName()
	if currentlyOpenFrame and currentlyOpenFrame.Parent then
		return currentlyOpenFrame.Name
	end
	return nil
end

local function initializeFrame(frame: Frame)
	if not framePositions[frame] then
		framePositions[frame] = frame.Position
		local hiddenPosition: UDim2 = UDim2.new(framePositions[frame].X.Scale, framePositions[frame].X.Offset, 1.5, 0)
		frame.Position = hiddenPosition
		frame.Visible = false
	end
end

function FrameManager.close(frameName: string)
	local targetFrame: Frame? = framesContainer:FindFirstChild(frameName)
	if not targetFrame then return end

	-- Do nothing if it's already invisible and not the open frame (avoids closing an already closed frame)
	if not targetFrame.Visible and currentlyOpenFrame ~= targetFrame then return end

	cancelActiveTween(targetFrame) -- Cancel any other tweens on this frame

	if currentlyOpenFrame == targetFrame then
		currentlyOpenFrame = nil
	end

	for _, callback in ipairs(frameClosedCallbacks) do
		task.spawn(callback, frameName)
	end

	initializeFrame(targetFrame)
	local hiddenPosition: UDim2 = UDim2.new(framePositions[targetFrame].X.Scale, framePositions[targetFrame].X.Offset, 1.5, 0)
	local slideOutTween: Tween = TweenService:Create(targetFrame, TWEEN_INFO, {Position = hiddenPosition})

	-- Create a cleanup thread that will run after the animation
	local cleanupThread = task.spawn(function()
		slideOutTween.Completed:Wait()
		targetFrame.Visible = false
		activeTweens[targetFrame] = nil -- Remove from active list once done
	end)

	-- Track the new animation and its cleanup thread
	activeTweens[targetFrame] = {Animation = slideOutTween, CleanupThread = cleanupThread}
	slideOutTween:Play()
end

function FrameManager.open(frameName: string)
	local targetFrame: Frame? = framesContainer:FindFirstChild(frameName)
	if not targetFrame or currentlyOpenFrame == targetFrame then return end

	cancelActiveTween(targetFrame) -- Cancel any other tweens on this frame

	initializeFrame(targetFrame)
	if currentlyOpenFrame then
		FrameManager.close(currentlyOpenFrame.Name)
	end
	targetFrame.Visible = true
	local originalPosition: UDim2 = framePositions[targetFrame]
	local slideInTween: Tween = TweenService:Create(targetFrame, TWEEN_INFO, {Position = originalPosition})

	-- Track the new animation
	activeTweens[targetFrame] = {Animation = slideInTween}
	slideInTween:Play()

	currentlyOpenFrame = targetFrame

	for _, callback in ipairs(frameOpenedCallbacks) do
		task.spawn(callback, frameName)
	end
end

function FrameManager.connect(button: TextButton | ImageButton, frameName: string, action: "Toggle" | "Open" | "Close"?)
	local targetFrame: Frame? = framesContainer:FindFirstChild(frameName)
	if not button or not targetFrame then return end
	action = action or "Toggle"
	initializeFrame(targetFrame)
	button.MouseButton1Click:Connect(function()
		if action == "Close" then
			FrameManager.close(frameName)
		elseif action == "Open" then
			FrameManager.open(frameName)
		else -- Toggle
			if currentlyOpenFrame == targetFrame then
				FrameManager.close(frameName)
			else
				FrameManager.open(frameName)
			end
		end
	end)
end

return FrameManager
---

--- HitboxClass (ModuleScript) :
--!strict

-----------------------------------------------------------------------
--                         HitboxClass v1.1A                         --
-----------------------------------------------------------------------
-- License:                                                          --
--   Licensed under the MIT license.                                 --
--                                                                   --
-- Author:                                                           --
--   RedTrio (VulkanAPI) - January 12, 2024 - Created the module.    --
--                                                                   --
-- Uses Signal by sleitnick.                                         --
-----------------------------------------------------------------------

-- Let me know if you come across any bugs or errors!

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterPlayer = game:GetService("StarterPlayer")
local Players = game:GetService("Players")

local moduleSettings = script.Settings

-- Initial error checking

assert(moduleSettings:FindFirstChild("Alive Folder"), "No Alive Folder setting found in HitboxClass settings! Make an object value and name it 'Alive Folder' and parent it there!")

local aliveFolder = moduleSettings["Alive Folder"].Value

assert(moduleSettings:FindFirstChild("Projectile Folder"), "No Projectile Folder setting found in HitboxClass settings! Make an object value and name it 'Projectile Folder' and parent it there!")

local projectileFolder = moduleSettings["Projectile Folder"].Value

local velocityConstant = moduleSettings:FindFirstChild("Velocity Prediction Constant")

if not velocityConstant then
	warn("Velocity Constant Setting has been deleted! 6 will be used as a default. (HitboxClass)")
end

assert(aliveFolder ~= nil, "Set the alive characters folder in the HitboxClass settings!")
assert(projectileFolder ~= nil, "Set the projectiles folder in the HitboxClass settings!")
assert(aliveFolder:IsDescendantOf(workspace), "The alive folder must be a descendant of workspace! (HitboxClass)")
assert(projectileFolder:IsDescendantOf(workspace), "The projectile folder must be a descendant of workspace! (HitboxClass)")

-- now we initialize the class
local Types = require(script.Types)
local signal = require(script.Signal)
local Timer = require(script.Timer)

local overlapParamsHumanoid = OverlapParams.new()
overlapParamsHumanoid.FilterDescendantsInstances = {aliveFolder}
overlapParamsHumanoid.FilterType = Enum.RaycastFilterType.Include

local overlapParamsObject = OverlapParams.new()
overlapParamsObject.FilterDescendantsInstances = {projectileFolder}
overlapParamsObject.FilterType =  Enum.RaycastFilterType.Exclude

local CFrameZero = CFrame.new(Vector3.zero)

local RunService = game:GetService("RunService")

local HitboxRemote = nil

local function SetupClients()
	local newRemoteEvent = Instance.new("RemoteEvent")
	newRemoteEvent.Name = "HitboxClassRemote"
	newRemoteEvent.Parent = ReplicatedStorage
	HitboxRemote = newRemoteEvent

	local newLocalScript = script.HitboxClassLocal:Clone()
	local newSignalModule = script.Signal:Clone()
	
	local newReference = Instance.new("ObjectValue")
	newReference.Value = script
	newReference.Name = "HitboxClass Module"
	newReference.Parent = newLocalScript

	newSignalModule.Parent = newLocalScript

	newLocalScript.Parent = StarterPlayer:FindFirstChildOfClass("StarterPlayerScripts")

	task.spawn(function()
		for i, Player : Player in pairs(Players:GetChildren()) do

			local ScreenGUI = Instance.new("ScreenGui")
			ScreenGUI.Name = "HitboxClassContainer"
			ScreenGUI.ResetOnSpawn = false

			local newScriptClone = newLocalScript:Clone()
			newScriptClone.Parent = ScreenGUI
			newScriptClone.Enabled = true

			ScreenGUI.Parent = Player:WaitForChild("PlayerGui")

		end
	end)

	newLocalScript.Enabled = true

end

if RunService:IsServer() then
	SetupClients()
else
	HitboxRemote = ReplicatedStorage:FindFirstChild("HitboxClassRemote")
	if not HitboxRemote then
		warn("HitboxClass must be initialized on the server before using it on the client! Waiting for RemoteEvent!")
		HitboxRemote = ReplicatedStorage:WaitForChild("HitboxClassRemote")
	end
end

local Hitbox = {} :: Types.Hitbox

local HitboxCache = {} :: {Types.Hitbox}

local function DeepCopyTable(tableToCopy : {})
	local copy = {}	

	for key, value in pairs(tableToCopy) do	
		if type(value) == "table" then		
			copy[key] = DeepCopyTable(value)		
		else	
			copy[key] = value	
		end
	end

	return copy
end

function Hitbox.new(HitboxParams : Types.HitboxParams)
	local self = (setmetatable({}, {__index = Hitbox}) :: unknown) :: Types.Hitbox

	self.TaggedChars = {}
	self.TaggedObjects = {}
	self.SendingChars = {}
	self.SendingObjects = {}
	self.DelayThreads = {}

	if RunService:IsClient() and HitboxParams._Tick then
		self.TickVal = HitboxParams._Tick
	else
		self.TickVal = workspace:GetServerTimeNow()
	end

	if HitboxParams.ID then
		self.ID = HitboxParams.ID
	end

	self.Blacklist = HitboxParams.Blacklist

	self.HitSomeone = signal.new()
	self.HitObject = signal.new()

	self.DebugMode = HitboxParams.Debug or false
	
	self.Lifetime = HitboxParams.Debris or 0
	
	self.LookingFor = HitboxParams.LookingFor or "Humanoid"

	if HitboxParams.UseClient then

		self.Client = HitboxParams.UseClient

		-- copy the params
		local newDictionary  = DeepCopyTable(HitboxParams) :: Types.HitboxParams

		-- get rid of the UseClient parameter
		newDictionary.UseClient = nil

		-- set the tickval to be the same as the hitbox's tickval
		newDictionary._Tick = self.TickVal

		-- fire to the client and wait for a response to ensure they got their hitbox set up
		local readyToGo = false

		local tempWaitEvent : RBXScriptConnection

		tempWaitEvent = HitboxRemote.OnServerEvent:Connect(function(player, tickVal)
			if player ~= self.Client then return end
			if tickVal ~= self.TickVal then return end

			readyToGo = true

		end)

		assert(self.Client)

		local startWaitTime = workspace:GetServerTimeNow()

		HitboxRemote:FireClient(self.Client, "New", newDictionary)

		repeat task.wait() until readyToGo or workspace:GetServerTimeNow() - startWaitTime >= 1.5

		tempWaitEvent:Disconnect()

		if not readyToGo then return self, false end

	else
		self.Position = HitboxParams.InitialPosition or CFrameZero
		self.DebounceTime = HitboxParams.DebounceTime or 0
		self.VelocityPrediction = HitboxParams.VelocityPrediction

		if self.VelocityPrediction == nil then
			self.VelocityPrediction = true
		end

		self.DotProductRequirement = HitboxParams.DotProductRequirement

		self.DebugMode = HitboxParams.Debug or false

		if typeof(HitboxParams.SizeOrPart) == "Vector3" then

			self.SpatialOption = HitboxParams.SpatialOption or "InBox"

			assert(self.SpatialOption ~= "InRadius", "You can't use InRadius as the SpatialOption if a Vector3 is passed! Only InPart and InBox! (HitboxClass)")

			self.Mode =  "Part"
			self.Size = HitboxParams.SizeOrPart

			if self.SpatialOption == "InPart" then
				self:_GeneratePart()
			end

		elseif type(HitboxParams.SizeOrPart) == "number" then

			self.SpatialOption = HitboxParams.SpatialOption or "Magnitude"

			if self.SpatialOption == "InRadius" then
				self.Mode = "Part"
				self.Size = HitboxParams.SizeOrPart
			elseif self.SpatialOption == "InPart" then
				self.Mode = "Part"
				self.Size = Vector3.new(HitboxParams.SizeOrPart, HitboxParams.SizeOrPart, HitboxParams.SizeOrPart)
				self:_GeneratePart()
			elseif self.SpatialOption == "InBox" then
				self.Mode = "Part"
				self.Size = Vector3.new(HitboxParams.SizeOrPart, HitboxParams.SizeOrPart, HitboxParams.SizeOrPart)
			else
				self.Mode =  "Magnitude"
				self.Size = HitboxParams.SizeOrPart
			end

		else 
			self.Mode =  "Part"
			self.Size = HitboxParams.SizeOrPart.Size
			self.Part = HitboxParams.SizeOrPart:Clone()


			self.SpatialOption = "InPart"

			assert(self.Part, "No part provided?")

			assert(self.Part and self.Part:IsA("Part"))

			self.Part.Color = Color3.new(1,0,0)
			self.Part.Name = "Hitbox"..self.TickVal
		end	

		if self.DebugMode then
			self:SetDebug(true)
		end

	end

	table.insert(HitboxCache, self)

	return self, true

end

function Hitbox:ClearTaggedChars()
	if self.Client then
		HitboxRemote:FireClient(self.Client, "ClrTag", {_Tick = self.TickVal})
	else
		table.clear(self.TaggedChars)
	end

end

function Hitbox:Start()
	
	-- if the lifetime is greater than 0
	if self.Lifetime > 0 then
		-- check to see if there's a timer, if there is one, then start it
		if not self.Timer then
			-- make a new timer
			self.Timer = Timer.new(0.1, function()
				self.Lifetime -= 0.1
				if self.Lifetime <= 0 then
					self:Destroy()
				end
			end)
			
		else
			self.Timer:On()
		end
		
	end

	if self.Client then

		self.ClientConnection = HitboxRemote.OnServerEvent:Connect(function(player : Player, tickVal : number, HitTable)
			if HitTable == nil then return end
			if player ~= self.Client then return end
			if tickVal ~= self.TickVal then return end	
			if type(HitTable) ~= "table" then return end
			
			if self.LookingFor == "Humanoid" then
				-- remove all HitTable that isn't a model, isn't a descendant of the alive folder, or doesn't have a humanoid, or is nil entirely
				for i = #HitTable, 1, -1 do
					if (not HitTable[i]) or (typeof(HitTable[i]) ~= "Instance") or (not HitTable[i]:IsDescendantOf(aliveFolder)) or (not HitTable[i]:FindFirstChildOfClass("Humanoid")) or (not HitTable[i]:IsA("Model")) then
						table.remove(HitTable, i)
					end

					-- if everything else is valid, double check to make sure the model passed in is not in the hitbox's blacklist
					if self.Blacklist then
						if table.find(self.Blacklist, HitTable[i]) then
							table.remove(HitTable, i)
						end
					end

				end

				-- if after everything is said and done there's nothing left, don't fire the signal
				if #HitTable <= 0 then return end

				self.HitSomeone:Fire(HitTable)
			elseif self.LookingFor == "Object" then
				for i = #HitTable, 1, -1 do
					if (not HitTable[i]) or (typeof(HitTable[i]) ~= "Instance") or (not HitTable[i]:IsA("BasePart")) then
						table.remove(HitTable, i)
						continue
					end

					-- if everything else is valid, double check to make sure the model passed in is not in the hitbox's blacklist
					if self.Blacklist then
						for _, blacklisted in pairs(self.Blacklist) do
							if HitTable[i] == blacklisted or HitTable[i]:IsDescendantOf(blacklisted) then
								table.remove(HitTable, i)
							end
						end
					end

				end
				
				-- if after everything is said and done there's nothing left, don't fire the signal
				if #HitTable <= 0 then return end
				
				self.HitObject:Fire(HitTable)
			end
			
		end)

		HitboxRemote:FireClient(self.Client, "Start", {_Tick = self.TickVal})

	elseif self.Mode == "Magnitude" then

		assert(typeof(self.Size) == "number", "Magnitude hitbox wasn't given a number! Type given: "..typeof(self.Size))

		if self.Part and self.DebugMode then

			self.Part.Parent = projectileFolder
		end

		self.RunServiceConnection = RunService.Heartbeat:Connect(function(DT)

			if self.PartWeld then
				self:SetPosition(self.PartWeld.CFrame * (self.PartWeldOffset or CFrameZero))
			end

			-- go through the alive folder
			for i, Character : Instance in pairs(aliveFolder:GetChildren()) do

				-- check to see if it's a model with a primary part that also has a humanoid
				if Character:IsA("Model") and Character.PrimaryPart ~= nil and Character:FindFirstChildOfClass("Humanoid") then
					local magnitude = (self.Position.Position - Character.PrimaryPart.Position).Magnitude

					-- if they're greater than the distance of the hitbox, skip them
					if magnitude > self.Size then continue end

					-- if they're in the blacklist, skip them
					if self.Blacklist then
						if table.find(self.Blacklist, Character) then
							continue
						end
					end

					-- check the dot product if one is given
					if self.DotProductRequirement then
						local VectorToCompare = (Character.PrimaryPart.CFrame.Position - self.DotProductRequirement.PartForVector.CFrame.Position).Unit

						local VectorOfUser : Vector3

						-- changed to a long if statement block cause strict mode was throwing a hissy fit
						-- "attempting a dynamic property access on type 'CFrame' is unsafe and may cause exceptions at runtime"

						if self.DotProductRequirement.VectorType then
							if self.DotProductRequirement.VectorType == "LookVector" then
								VectorOfUser = self.DotProductRequirement.PartForVector.CFrame.LookVector
							elseif self.DotProductRequirement.VectorType == "UpVector" then
								VectorOfUser = self.DotProductRequirement.PartForVector.CFrame.UpVector
							elseif self.DotProductRequirement.VectorType == "RightVector" then
								VectorOfUser = self.DotProductRequirement.PartForVector.CFrame.RightVector
							end
						else
							VectorOfUser = self.DotProductRequirement.PartForVector.CFrame.LookVector
						end

						if self.DotProductRequirement.Negative then
							VectorOfUser *= -1
						end

						if VectorToCompare:Dot(VectorOfUser) < self.DotProductRequirement.DotProduct then
							continue
						end

					end

					-- if they've already been tagged, skip them
					if self.TaggedChars[Character] then continue end

					if magnitude <= self.Size then
						table.insert(self.SendingChars, Character)
					end

				end

			end


			self:_SiftThroughSendingCharsAndFire()

		end)	
		
	else

		if (self.SpatialOption == "InPart") or (self.Part and self.DebugMode == true) then
			self.Part.Parent = projectileFolder
		end

		self.RunServiceConnection = RunService.Heartbeat:Connect(function(DT)

			if self.PartWeld then
				self:SetPosition(self.PartWeld.CFrame * (self.PartWeldOffset or CFrameZero))
			end

			local results

			if self.SpatialOption == "InBox" then
				if self.LookingFor == "Humanoid" then
					results = workspace:GetPartBoundsInBox(self.Position, self.Size, overlapParamsHumanoid)
				else
					results = workspace:GetPartBoundsInBox(self.Position, self.Size, overlapParamsObject)
				end
			elseif self.SpatialOption == "InRadius" then
				if self.LookingFor == "Humanoid" then
					results = workspace:GetPartBoundsInRadius(self.Position.Position, self.Size, overlapParamsHumanoid)
				else
					results = workspace:GetPartBoundsInRadius(self.Position.Position, self.Size, overlapParamsObject)
				end
			else
				if self.LookingFor == "Humanoid" then
					results = workspace:GetPartsInPart(self.Part, overlapParamsHumanoid)
				else
					results = workspace:GetPartsInPart(self.Part, overlapParamsObject)
				end
			end

			for i, Part : BasePart in pairs(results) do

				if not Part.Parent then continue end
				
				if self.LookingFor == "Humanoid" then
					local Character = Part.Parent

					if not Character:IsA("Model") then continue end

					if Character.PrimaryPart == nil or not Character:FindFirstChildOfClass("Humanoid") then continue end

					if self.Blacklist then
						if table.find(self.Blacklist, Character) then
							continue
						end
					end


					if not table.find(self.SendingChars, Character) and not self.TaggedChars[Character] then	

						table.insert(self.SendingChars, Character)

					end
				else
					
					local BlacklistFound = false
					
					if self.Blacklist then
						-- go through the blacklist and flip the bool and break if the part is found
						-- in the blacklist
						for i = #self.Blacklist, 1, -1 do

							local checkingPart = self.Blacklist[i]
							
							if Part == checkingPart or Part:IsDescendantOf(checkingPart) then
								BlacklistFound = true
								break
							end
						end
					end
					

					if not table.find(self.SendingObjects, Part) and not self.TaggedObjects[Part] and not BlacklistFound then

						table.insert(self.SendingObjects, Part)

					end
				end
				
				
			end

			if self.LookingFor == "Humanoid" then
				self:_SiftThroughSendingCharsAndFire()
			elseif self.LookingFor == "Object" then
				self:_SiftThroughSendingObjectsAndFire()
			end
			

		end)
		
	end
	
end

function Hitbox:Stop()
	
	if self.Timer then
		self.Timer:Off()
	end
	
	if self.Client then
		if self.ClientConnection then
			self.ClientConnection:Disconnect()
			self.ClientConnection = nil
		end
		HitboxRemote:FireClient(self.Client, "Stop", {_Tick = self.TickVal})
	else
		if self.Part then
			self.Part:Remove()
		end

		if self.RunServiceConnection then
			self.RunServiceConnection:Disconnect()
			self.RunServiceConnection = nil
		end
	end

end

function Hitbox:SetPosition(newPosition : CFrame)

	if self.Client then
		HitboxRemote:FireClient(self.Client, "PosCh", {_Tick = self.TickVal, Position = newPosition})
	end

	local constant

	if velocityConstant then
		constant = velocityConstant.Value or 6
	else
		constant = 6
	end

	if RunService:IsServer() and self.PartWeld and self.VelocityPrediction then
		local velocityVector =  newPosition:VectorToObjectSpace(self.PartWeld.AssemblyLinearVelocity) / constant
		newPosition = newPosition * CFrame.new(velocityVector)
	end


	self.Position = newPosition

	if self.Part then
		self.Part.CFrame = newPosition
	end
end

function Hitbox:WeldTo(PartToWeldTo : BasePart, OffsetCFrame : CFrame?)

	if self.Client then
		HitboxRemote:FireClient(self.Client, "Weld", {_Tick = self.TickVal, WeldTo = PartToWeldTo, Offset = OffsetCFrame})
	end

	self.PartWeld = PartToWeldTo
	self.PartWeldOffset = OffsetCFrame

end

function Hitbox:Unweld()
	if self.Client then
		HitboxRemote:FireClient(self.Client, "Unweld", {_Tick = self.TickVal})
	end

	self.PartWeld = nil
	self.PartWeldOffset = nil

end

function Hitbox:ChangeWeldOffset(OffsetCFrame : CFrame)

	if self.Client then
		HitboxRemote:FireClient(self.Client, "WeldOfs", {_Tick = self.TickVal, Offset = OffsetCFrame})
	end

	self.PartWeldOffset = OffsetCFrame
end

function Hitbox:SetVelocityPrediction(state : boolean)
	self.VelocityPrediction = state
end

function Hitbox:SetDebug(state : boolean)
	self.DebugMode = state

	if self.Client then
		HitboxRemote:FireClient(self.Client, "Dbg", {_Tick = self.TickVal, Debug = state})
		return
	end

	if self.DebugMode then
		if not self.Part then
			self:_GeneratePart()
			assert(self.Part, "Part wasn't generated after the GeneratePart method?")
			
			if self.RunServiceConnection then
				self.Part.Parent = projectileFolder
			end

		else
			self.Part.Transparency = 0.45

			if self.SpatialOption ~= "InPart" and self.RunServiceConnection then
				self.Part.Parent = projectileFolder
			end

		end
	else
		if self.Part then

			if self.SpatialOption ~= "InPart" then
				self.Part:Remove()
			end

			self.Part.Transparency = 1
		end
	end
end

function Hitbox.ClearHitboxesWithID(ID : number | string)
	if RunService:IsClient() then return end

	-- go through the cache and destroy any hitboxes with the ID provided
	for i = #HitboxCache, 1, -1 do

		local checkingHitbox = HitboxCache[i]

		if checkingHitbox.ID and checkingHitbox.ID == ID then
			pcall(function()
				checkingHitbox:Destroy()
			end)
		end
	end

end

function Hitbox.ClearClientHitboxes(client : Player)

	if RunService:IsClient() then return end

	-- go through the cache and destroy any hitboxes associated with the client
	for i = #HitboxCache, 1, -1 do

		local checkingHitbox = HitboxCache[i]

		if checkingHitbox.Client and checkingHitbox.Client == client then
			pcall(function()
				checkingHitbox:Destroy()
			end)
		end
	end

	-- make sure everything is cleared on the client
	HitboxRemote:FireClient(client, "Clr")
end

function Hitbox.GetHitboxCache()
	return HitboxCache
end

function Hitbox:_SiftThroughSendingObjectsAndFire()
	if #self.SendingObjects <= 0 then return end

	local shallowObjectTable = {}

	for i, Object in pairs(self.SendingObjects) do
		table.insert(shallowObjectTable, Object)

		self.TaggedObjects[Object] = true

		if self.DebounceTime > 0 then
			local newThread = task.delay(self.DebounceTime, function()

				self.TaggedObjects[Object] = nil

			end)

			table.insert(self.DelayThreads, newThread)

		end

	end


	if #shallowObjectTable > 0 then
		if RunService:IsClient() then
			HitboxRemote:FireServer(self.TickVal, shallowObjectTable)
		end

		self.HitObject:Fire(shallowObjectTable)
	end

	if self.SendingObjects then
		table.clear(self.SendingObjects)
	end
end

function Hitbox:_SiftThroughSendingCharsAndFire()
	
	if #self.SendingChars <= 0 then return end
	
	local shallowObjectTable = {}
	
	for i, Object : Model in pairs(self.SendingChars) do
		table.insert(shallowObjectTable, Object)
		
		self.TaggedChars[Object] = true

		if self.DebounceTime > 0 then
			local newThread = task.delay(self.DebounceTime, function()
				
				self.TaggedChars[Object] = nil
				
			end)
			
			table.insert(self.DelayThreads, newThread)

		end

	end


	if #shallowObjectTable > 0 then
		if RunService:IsClient() then
			HitboxRemote:FireServer(self.TickVal, shallowObjectTable)
		end

		self.HitSomeone:Fire(shallowObjectTable)

	end

	if self.SendingChars then
		table.clear(self.SendingChars)
	end

end

function Hitbox:_GeneratePart()

	if self.Part then return end

	if typeof(self.Size) == "Vector3" then
		self.Mode =  "Part"
		self.Part = Instance.new("Part")


		assert(self.Part, "Part was nil!")
		assert(typeof(self.Size) == "Vector3", "self.Size wasn't a vector3 when making a part!") -- you shouldn't get here, but just in case

		self.Part.Color = Color3.new(1, 0, 0)

		if self.DebugMode then
			self.Part.Transparency = 0.45
		else
			self.Part.Transparency = 1
		end

		self.Part.Anchored = true
		self.Part.Massless = true
		self.Part.CanCollide = false

		self.Part.Size = self.Size
		self.Part.CFrame = self.Position

		self.Part.Name = "Hitbox"..self.TickVal
	elseif type(self.Size) == "number" then
		self.Part = Instance.new("Part")

		assert(self.Part and self.Part:IsA("Part"))
		assert(typeof(self.Size) == "number", "self.Size wasn't a number when making a sphere part!") -- you shouldn't get here, but just in case

		self.Part.Shape = Enum.PartType.Ball
		self.Part.Anchored = true
		self.Part.Massless = true
		self.Part.CanCollide = false
		self.Part.Size = Vector3.new(self.Size * 2, self.Size * 2, self.Size * 2)
		self.Part.Transparency = 0.45
		self.Part.Color = Color3.new(1, 0, 0)
		self.Part.CFrame = self.Position
		self.Part.Name = "Hitbox"..self.TickVal
	end
end

function Hitbox:Destroy()

	-- remove the hitbox from the cache
	table.remove(HitboxCache, table.find(HitboxCache, self))

	-- tell the client to destroy the hitbox on their end
	if self.Client then
		HitboxRemote:FireClient(self.Client, "Des", {_Tick = self.TickVal})
	end

	-- stop the hitbox
	if self.Client then
		if self.ClientConnection then
			self.ClientConnection:Disconnect()
			self.ClientConnection = nil
		end
	else
		if self.Part then
			self.Part:Remove()
		end

		if self.RunServiceConnection then
			self.RunServiceConnection:Disconnect()
			self.RunServiceConnection = nil
		end
	end

	-- disconnect all connections to the HitSomeone signal
	pcall(function()
		self.HitSomeone:Destroy()
	end)
	
	-- disconnect all connections to the HitObject signal
	pcall(function()
		self.HitObject:Destroy()
	end)
	
	-- if there's a timer, destroy it
	pcall(function()
		if self.Timer then
			self.Timer:Destroy()
		end
	end)

	-- cancel all debounce threads
	if self.DelayThreads then
		for i, thread in pairs(self.DelayThreads) do
			pcall(function()
				task.cancel(thread)
			end)
		end
	end
	
	-- if there's a part, destroy it
	if self.Part then
		self.Part:Destroy()
	end

	-- clear out all tables
	pcall(function()
		table.clear(self.TaggedChars)
	end)

	pcall(function()
		table.clear(self.SendingChars)
	end)

	pcall(function()
		table.clear(self)
	end)

end

return Hitbox
---

--- HitboxClassLocal (LocalScript) :
--!strict

local require = require
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local signal = require(script:WaitForChild("Signal"))
local HitboxClassRemote = ReplicatedStorage:WaitForChild("HitboxClassRemote") :: RemoteEvent
local HitboxClass = require(script["HitboxClass Module"].Value)

local currentHitboxes = {}

HitboxClassRemote.OnClientEvent:Connect(function(mode, packet)
	
	if mode == "Clr" then
		for i, Hitbox in pairs(currentHitboxes) do
			Hitbox:Destroy()
			currentHitboxes[i] = nil
		end
		return
	end
	
	if mode ~= "New" and not currentHitboxes[packet._Tick] then warn("No hitbox found on the client for tick value sent. Don't change the tick value manually, change the ID instead. (HitboxClass)") return end
	
	if mode == "New" then
		local newHitbox = HitboxClass.new(packet)
		currentHitboxes[packet._Tick] = newHitbox
		HitboxClassRemote:FireServer(packet._Tick)
	end
	
	if mode == "Start" then
		currentHitboxes[packet._Tick]:Start()
	end
	
	if mode == "Stop" then
		currentHitboxes[packet._Tick]:Stop()
	end
	
	if mode == "ClrTag" then
		currentHitboxes[packet._Tick]:ClearTaggedChars()
	end
	
	if mode == "Weld" then
		currentHitboxes[packet._Tick]:WeldTo(packet.WeldTo, packet.Offset)
	end
	
	if mode == "WeldOfs" then
		currentHitboxes[packet._Tick]:ChangeWeldOffset(packet.Offset)
	end
	
	if mode == "Unweld" then
		currentHitboxes[packet._Tick]:Unweld()
	end
	
	if mode == "PosCh" then
		currentHitboxes[packet._Tick]:SetPosition(packet.Position)
	end
	
	if mode == "Dbg" then
		currentHitboxes[packet._Tick]:SetDebug(packet.Debug)
	end
	
	if mode == "Des" then
		currentHitboxes[packet._Tick]:Destroy()
		currentHitboxes[packet._Tick] = nil
	end
	
end)
---

--- Signal (ModuleScript) :
-- -----------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- License:                                                                   --
--   Licensed under the MIT license.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--   sleitnick - August 3rd, 2021 - Modified for Knit.                        --
-- -----------------------------------------------------------------------------

-- Signal types
export type Connection = {
	Disconnect: (self: Connection) -> (),
	Destroy: (self: Connection) -> (),
	Connected: boolean,
}

export type Signal<T...> = {
	Fire: (self: Signal<T...>, T...) -> (),
	FireDeferred: (self: Signal<T...>, T...) -> (),
	Connect: (self: Signal<T...>, fn: (T...) -> ()) -> Connection,
	Once: (self: Signal<T...>, fn: (T...) -> ()) -> Connection,
	DisconnectAll: (self: Signal<T...>) -> (),
	GetConnections: (self: Signal<T...>) -> { Connection },
	Destroy: (self: Signal<T...>) -> (),
	Wait: (self: Signal<T...>) -> T...,
}

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread(...)
	acquireRunnerThreadAndCallEventHandler(...)
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

--[=[
	@within Signal
	@interface SignalConnection
	.Connected boolean
	.Disconnect (SignalConnection) -> ()

	Represents a connection to a signal.
	```lua
	local connection = signal:Connect(function() end)
	print(connection.Connected) --> true
	connection:Disconnect()
	print(connection.Connected) --> false
	```
]=]

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection:Disconnect()
	if not self.Connected then
		return
	end
	self.Connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end

Connection.Destroy = Connection.Disconnect

-- Make Connection strict
setmetatable(Connection, {
	__index = function(_tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

--[=[
	@within Signal
	@type ConnectionFn (...any) -> ()

	A function connected to a signal.
]=]

--[=[
	@class Signal

	A Signal is a data structure that allows events to be dispatched
	and observed.

	This implementation is a direct copy of the de facto standard, [GoodSignal](https://devforum.roblox.com/t/lua-signal-class-comparison-optimal-goodsignal-class/1387063),
	with some added methods and typings.

	For example:
	```lua
	local signal = Signal.new()

	-- Subscribe to a signal:
	signal:Connect(function(msg)
		print("Got message:", msg)
	end)

	-- Dispatch an event:
	signal:Fire("Hello world!")
	```
]=]
local Signal = {}
Signal.__index = Signal

--[=[
	Constructs a new Signal

	@return Signal
]=]
function Signal.new<T...>(): Signal<T...>
	local self = setmetatable({
		_handlerListHead = false,
		_proxyHandler = nil,
		_yieldedThreads = nil,
	}, Signal)

	return self
end

--[=[
	Constructs a new Signal that wraps around an RBXScriptSignal.

	@param rbxScriptSignal RBXScriptSignal -- Existing RBXScriptSignal to wrap
	@return Signal

	For example:
	```lua
	local signal = Signal.Wrap(workspace.ChildAdded)
	signal:Connect(function(part) print(part.Name .. " added") end)
	Instance.new("Part").Parent = workspace
	```
]=]
function Signal.Wrap<T...>(rbxScriptSignal: RBXScriptSignal): Signal<T...>
	assert(
		typeof(rbxScriptSignal) == "RBXScriptSignal",
		"Argument #1 to Signal.Wrap must be a RBXScriptSignal; got " .. typeof(rbxScriptSignal)
	)

	local signal = Signal.new()
	signal._proxyHandler = rbxScriptSignal:Connect(function(...)
		signal:Fire(...)
	end)

	return signal
end

--[=[
	Checks if the given object is a Signal.

	@param obj any -- Object to check
	@return boolean -- `true` if the object is a Signal.
]=]
function Signal.Is(obj: any): boolean
	return type(obj) == "table" and getmetatable(obj) == Signal
end

--[=[
	@param fn ConnectionFn
	@return SignalConnection

	Connects a function to the signal, which will be called anytime the signal is fired.
	```lua
	signal:Connect(function(msg, num)
		print(msg, num)
	end)

	signal:Fire("Hello", 25)
	```
]=]
function Signal:Connect(fn)
	local connection = setmetatable({
		Connected = true,
		_signal = self,
		_fn = fn,
		_next = false,
	}, Connection)

	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end

	return connection
end

--[=[
	@deprecated v1.3.0 -- Use `Signal:Once` instead.
	@param fn ConnectionFn
	@return SignalConnection
]=]
function Signal:ConnectOnce(fn)
	return self:Once(fn)
end

--[=[
	@param fn ConnectionFn
	@return SignalConnection

	Connects a function to the signal, which will be called the next time the signal fires. Once
	the connection is triggered, it will disconnect itself.
	```lua
	signal:Once(function(msg, num)
		print(msg, num)
	end)

	signal:Fire("Hello", 25)
	signal:Fire("This message will not go through", 10)
	```
]=]
function Signal:Once(fn)
	local connection
	local done = false

	connection = self:Connect(function(...)
		if done then
			return
		end

		done = true
		connection:Disconnect()
		fn(...)
	end)

	return connection
end

function Signal:GetConnections()
	local items = {}

	local item = self._handlerListHead
	while item do
		table.insert(items, item)
		item = item._next
	end

	return items
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
--[=[
	Disconnects all connections from the signal.
	```lua
	signal:DisconnectAll()
	```
]=]
function Signal:DisconnectAll()
	local item = self._handlerListHead
	while item do
		item.Connected = false
		item = item._next
	end
	self._handlerListHead = false

	local yieldedThreads = rawget(self, "_yieldedThreads")
	if yieldedThreads then
		for thread in yieldedThreads do
			if coroutine.status(thread) == "suspended" then
				warn(debug.traceback(thread, "signal disconnected; yielded thread cancelled", 2))
				task.cancel(thread)
			end
		end
		table.clear(self._yieldedThreads)
	end
end

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
--[=[
	@param ... any

	Fire the signal, which will call all of the connected functions with the given arguments.
	```lua
	signal:Fire("Hello")

	-- Any number of arguments can be fired:
	signal:Fire("Hello", 32, {Test = "Test"}, true)
	```
]=]
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item.Connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

--[=[
	@param ... any

	Same as `Fire`, but uses `task.defer` internally & doesn't take advantage of thread reuse.
	```lua
	signal:FireDeferred("Hello")
	```
]=]
function Signal:FireDeferred(...)
	local item = self._handlerListHead
	while item do
		local conn = item
		task.defer(function(...)
			if conn.Connected then
				conn._fn(...)
			end
		end, ...)
		item = item._next
	end
end

--[=[
	@return ... any
	@yields

	Yields the current thread until the signal is fired, and returns the arguments fired from the signal.
	Yielding the current thread is not always desirable. If the desire is to only capture the next event
	fired, using `Once` might be a better solution.
	```lua
	task.spawn(function()
		local msg, num = signal:Wait()
		print(msg, num) --> "Hello", 32
	end)
	signal:Fire("Hello", 32)
	```
]=]
function Signal:Wait()
	local yieldedThreads = rawget(self, "_yieldedThreads")
	if not yieldedThreads then
		yieldedThreads = {}
		rawset(self, "_yieldedThreads", yieldedThreads)
	end

	local thread = coroutine.running()
	yieldedThreads[thread] = true

	self:Once(function(...)
		yieldedThreads[thread] = nil
		task.spawn(thread, ...)
	end)

	return coroutine.yield()
end

--[=[
	Cleans up the signal.

	Technically, this is only necessary if the signal is created using
	`Signal.Wrap`. Connections should be properly GC'd once the signal
	is no longer referenced anywhere. However, it is still good practice
	to include ways to strictly clean up resources. Calling `Destroy`
	on a signal will also disconnect all connections immediately.
	```lua
	signal:Destroy()
	```
]=]
function Signal:Destroy()
	self:DisconnectAll()

	local proxyHandler = rawget(self, "_proxyHandler")
	if proxyHandler then
		proxyHandler:Disconnect()
	end
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(_tb, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

return table.freeze({
	new = Signal.new,
	Wrap = Signal.Wrap,
	Is = Signal.Is,
})

---

--- Timer (ModuleScript) :
--!strict

local RunService = game:GetService("RunService")
local Signal = require(script.Parent.Signal)

export type IntervalTimer = {
	
	-- fields
	TimeOut : number,
	TimeElapsed : number,
	Callback : (number) -> (),
	HeartbeatConnection :  RBXScriptConnection,
	Elapsed : Signal.Signal<>,
	
	-- methods
	new : (timeOut : number, callback : () -> ()) -> IntervalTimer,
	On : (self : IntervalTimer) -> (),
	Off : (self : IntervalTimer) -> (),
	Destroy : (self : IntervalTimer) -> (),
	
	-- private methods
	_Interval : (self : IntervalTimer, deltaTime : number) -> (),
}

local Timer = {}

-- this timer is only reliable on 0.1 timeout threshold or above
function Timer.new(TimeOut : number, Callback : () -> ())
	local self = (setmetatable({}, {__index = Timer}) :: unknown) :: IntervalTimer
	
	-- set up fields
	self.TimeOut = TimeOut
	self.Callback = Callback
	self.TimeElapsed = 0
	self.Elapsed = Signal.new()
	
	self.Elapsed:Connect(Callback)
	
	-- set up connection to heartbeat
	self.HeartbeatConnection = RunService.Heartbeat:Connect(function(DT)
		self:_Interval(DT)
	end)
	
	return self
end

function Timer._Interval(self : IntervalTimer, deltaTime : number)

	-- add the elapsed time to the timer
	self.TimeElapsed += deltaTime

	-- if there's something crazy going on and this hasn't been called in over 10 times the timeout threshold
	-- we want to reset the time elapsed field to prevent the timer from running the callback over 10 times in a row
	if self.TimeElapsed >= self.TimeOut * 10 then
		-- get the amount of timeouts skipped and then multiply by the timeout threshold
		-- subtract this from time elapsed
		self.TimeElapsed -= math.floor(self.TimeElapsed / self.TimeOut) * self.TimeOut

		return
	end

	-- if the elapsed time meets the threshold for the timeout
	-- then get rid of the elapsed time and run the callback
	if self.TimeElapsed >= self.TimeOut then
		self.TimeElapsed -= self.TimeOut
		self.Elapsed:Fire()
	end

end

function Timer.On(self : IntervalTimer)
	-- if connection exists and is connected, don't do anything
	if self.HeartbeatConnection and self.HeartbeatConnection.Connected then return end
	
	-- make a new connection to heartbeat
	self.HeartbeatConnection = RunService.Heartbeat:Connect(function(DT)
		self:_Interval(DT)
	end)
	
end

function Timer.Off(self : IntervalTimer)
	-- if there's not connection, don't do anything
	if not self.HeartbeatConnection then return end

	-- disconnect the connection
	self.HeartbeatConnection:Disconnect()
end

function Timer.Destroy(self : IntervalTimer)
	
	-- disconnect the connection
	self:Off()
	
	-- destroy the signal
	self.Elapsed:Destroy()
	
	-- clear self
	table.clear(self)
	
end

return Timer
---

--- Types (ModuleScript) :
local Types = {}

-- temp signal to make the types
local signal = require(script.Parent.Signal)
local timer = require(script.Parent.Timer)
local newSignal = signal.new()

export type SignalType<T...> = typeof(newSignal)

export type SignalConnection = typeof(newSignal:Connect())

export type DotProductRequirement = {
	DotProduct : number,
	PartForVector : BasePart,
	VectorType : ("LookVector" | "UpVector" | "RightVector")?,
	Negative : boolean?
}

export type HitboxParams = {
	SizeOrPart : Vector3 | number | BasePart,
	SpatialOption : ("InBox" | "InRadius" | "InPart")?,
	InitialPosition : CFrame?,
	Blacklist : {Model}?,
	DebounceTime : number?,
	DotProductRequirement : DotProductRequirement?,
	UseClient : Player?,
	ID : (string | number)?,
	VelocityPrediction : boolean?,
	Debug : boolean?,
	Debris : number?,
	LookingFor : ("Humanoid" | "Object")?,
	
	-- Private fields
	_Tick : number?
}

export type Hitbox = {

	-- Fields

	Size : Vector3 | number,
	Mode : "Magnitude" | "Part",
	SpatialOption : "InBox" | "InRadius" | "InPart" | "Magnitude",
	LookingFor : "Humanoid" | "Object",
	DebounceTime : number,
	Part : BasePart?,
	Position : CFrame,
	DotProductRequirement : DotProductRequirement?,
	TaggedChars : {[Model] : boolean},
	TaggedObjects : {[BasePart] : boolean},
	ID : (string | number)?,
	TickVal : number,
	Blacklist : {}?,
	SendingChars : {Model},
	SendingObjects : {BasePart},
	DelayThreads : {thread},
	HitSomeone : signal.Signal<{Model}>,
	HitObject : signal.Signal<{BasePart}>,
	RunServiceConnection : RBXScriptConnection?,
	ClientConnection : RBXScriptConnection?,
	PartWeld : BasePart?,
	PartWeldOffset : CFrame?,
	Client : Player?,
	VelocityPrediction : boolean?,
	DebugMode : boolean,
	Lifetime : number,
	

	-- Methods

	new : (HitboxParams) -> (Hitbox, boolean),
	ClearClientHitboxes : (Client : Player) -> (),
	ClearHitboxesWithID : (ID : string | number) -> (),
	GetHitboxCache : () -> {Hitbox},
	ClearTaggedChars : (self : Hitbox) -> (),
	Start : (self : Hitbox) -> (),
	Stop : (self : Hitbox) -> (),
	SetPosition : (self : Hitbox, Position : CFrame) -> (),
	Destroy : (self : Hitbox) -> (),
	WeldTo : (self : Hitbox , PartToWeldTo : BasePart, OffsetCFrame : CFrame?) -> (),
	Unweld : (self : Hitbox) -> (),
	ChangeWeldOffset : (self : Hitbox, OffsetCFrame : CFrame) -> (),
	SetVelocityPrediction : (self : Hitbox, state : boolean) -> (),
	SetDebug : (self : Hitbox, state : boolean) -> (),

	-- Private Methods (Don't touch unless you know what you're doing!)

	_SiftThroughSendingCharsAndFire : (self : Hitbox) -> (),
	_SiftThroughSendingObjectsAndFire : (self : Hitbox) -> (),
	_GeneratePart : (self : Hitbox) -> (),
	
	-- Private Fields (Don't touch unless you know what you're doing!)
	Timer : timer.IntervalTimer?,
	
}

return Types

---

--- ItemConfigurations (ModuleScript) :
--[[
	ItemConfigurations Module
	
	Description: Contains all data for purchasable items in the BlocksShop,
	including their type, price, stock chance, and appearance.
	
	Location: ReplicatedStorage/Modules
]]
--!strict

local ItemConfigurations = {
	-- == BLOCKS ==
	WoodenFence = {
		DisplayName = "Wooden Fence",
		Type = "Blocks",
		Price = 50,
		ImageId = "rbxassetid://129846047182862",
		ProductID = 3433103620,
		Unlimited = false,
		Chance = 60,
		StockAmount = {Min = 1, Max = 5},
		Health = 50,
	},

	Crate = {
		DisplayName = "Crate",
		Type = "Blocks",
		Price = 250,
		ImageId = "rbxassetid://120065601385140",
		ProductID = 3433103879,
		Unlimited = false,
		Chance = 47,
		StockAmount = {Min = 1, Max = 5},
		Health = 75,
	},

	Barrel = {
		DisplayName = "Barrel",
		Type = "Blocks",
		Price = 950,
		ImageId = "rbxassetid://85433095978867",
		ProductID = 3433104247,
		Unlimited = false,
		Chance = 45,
		StockAmount = {Min = 1, Max = 5},
		Health = 120,
	},

	Sandbag = {
		DisplayName = "Sandbag",
		Type = "Blocks",
		Price = 2200,
		ImageId = "rbxassetid://95530712312968",
		ProductID = 3433104602,
		Unlimited = false,
		Chance = 36,
		StockAmount = {Min = 1, Max = 5},
		Health = 155,
	},

	SteelFence = {
		DisplayName = "Steel Fence",
		Type = "Blocks",
		Price = 4500,
		ImageId = "rbxassetid://125202399347349",
		ProductID = 3433105403,
		Unlimited = false,
		Chance = 34,
		StockAmount = {Min = 1, Max = 5},
		Health = 250,
	},

	Titanium = {
		DisplayName = "Titanium",
		Type = "Blocks",
		Price = 9000,
		ImageId = "rbxassetid://112393753455351",
		ProductID = 3433551311,
		Unlimited = false,
		Chance = 27,
		StockAmount = {Min = 1, Max = 4},
		Health = 700,
	},
	
	Cobblestone = {
		DisplayName = "Cobblestone",
		Type = "Blocks",
		Price = 1200,
		ImageId = "rbxassetid://87565106525483",
		ProductID = 3451485533,
		Unlimited = false,
		Chance = 43,
		StockAmount = {Min = 1, Max = 5},
		Health = 100,
	},
	
	Diamond = {
		DisplayName = "Diamond",
		Type = "Blocks",
		Price = 25000,
		ImageId = "rbxassetid://90412412707609",
		ProductID = 3451485298,
		Unlimited = false,
		Purchasable = false,           
		ShopHidden  = true,            
		Chance = 24,
		StockAmount = {Min = 1, Max = 3},
		Health = 1600,
	},
	
	WoodenSpike = {
		DisplayName = "WoodenSpike",
		Type = "Blocks",
		Price = 3500,
		ImageId = "rbxassetid://132026303434953",
		ProductID = 3451486230,
		Unlimited = false,
		Chance = 45,
		StockAmount = {Min = 1, Max = 5},
		Health = 80,
	},
	
	MetalSpike = {
		DisplayName = "MetalSpike",
		Type = "Blocks",
		Price = 6000,
		ImageId = "rbxassetid://125231362028631",
		ProductID = 3451485825,
		Unlimited = false,
		Chance = 38,
		StockAmount = {Min = 1, Max = 4},
		Health = 250,
	},
	
	ToxicSpike = {
		DisplayName = "ToxicSpike",
		Type = "Blocks",
		Price = 30000,
		ImageId = "rbxassetid://115198885487974",
		ProductID = 3451486014,
		Unlimited = false,
		Purchasable = false,           
		ShopHidden  = true, 
		Chance = 24,
		StockAmount = {Min = 1, Max = 3},
		Health = 550,
	},
	
	
	
	
	
	



	-- == TURRETS ==
	RevolverGuard = {
		DisplayName = "Revolver Cowboy",
		Type = "Turrets",
		Price = 200,
		ImageId = "rbxassetid://101587176998545",
		ProductID = 3433094679,
		Unlimited = false,
		Chance = 60,
		StockAmount = {Min = 2, Max = 4},
		Damage = 40,
		Range = 18,
		FireRate = 1.5, -- shots per second
		Health = 100, -- ## ADDED ##
	},

	DualRevolverGuard = {
		DisplayName = "Akimbo Cowboy",
		Type = "Turrets",
		Price = 750,
		ImageId = "rbxassetid://90537702528376",
		ProductID = 3433095524,
		Unlimited = false,
		Chance = 54,
		StockAmount = {Min = 1, Max = 3},
		Damage = 52,
		Range = 20,
		FireRate = 1.7, -- shots per second
		Health = 150, -- ## ADDED ##
	},

	SubmachineGunGuard = {
		DisplayName = "Uzi Cowboy",
		Type = "Turrets",
		Price = 3000,
		ImageId = "rbxassetid://85967954170361",
		ProductID = 3434416170,
		Unlimited = false,
		Chance = 45,
		StockAmount = {Min = 1, Max = 4},
		Damage = 23,
		Range = 24,
		FireRate = 4, -- shots per second
		Health = 150, -- ## ADDED ##
	},

	RifleGuard = {
		DisplayName = "Rifle Cowboy",
		Type = "Turrets",
		Price = 20000,
		ImageId = "rbxassetid://97972248199343",
		ProductID = 3433095916,
		Unlimited = false,
		Chance = 42,
		StockAmount = {Min = 1, Max = 3},
		Damage = 52,
		Range = 32,
		FireRate = 2.4, -- shots per second
		Health = 200, -- ## ADDED ##
	},

	ShotgunGuard = {
		DisplayName = "Shotgun Cowboy",
		Type = "Turrets",
		Price = 60000,
		ImageId = "rbxassetid://120607492947002",
		ProductID = 3433096316,
		Unlimited = false,
		Chance = 36,
		StockAmount = {Min = 1, Max = 3},
		Damage = 12,
		Range = 25,
		FireRate = 0.6, -- shots per second
		Health = 250, -- ## ADDED ##
	},


	GatlingGuard = {
		DisplayName = "Heavy Gunner",
		Type = "Turrets",
		Price = 120000,
		ImageId = "rbxassetid://100612332867121",
		ProductID = 3433096925,
		Unlimited = false,
		Chance = 30,
		StockAmount = {Min = 1, Max = 2},
		Damage = 20,
		Range = 40,
		FireRate = 5, -- shots per second
		Health = 300, -- ## ADDED ##
	},
	
	MortarGuard = {
		DisplayName = "MortarGuard",
		Type = "Turrets",
		Purchasable = false,
		ShopHidden = true,
		Price = nil,
		ProductID = nil,
		ImageId = "rbxassetid://97959863510956",

		Health = 300,
		Range = 80,
		MinRange = 18,
		Reload = 3.4,
		ProjectileSpeed = 90,
		SplashRadius = 15,
		Damage = 75,
		Spread = 1.5,
	},

}


-- Multipliers per tier (M1..M4)
local DAMAGE_MULT = { 1.10, 1.2, 1.3, 1.4 }
local HEALTH_MULT = { 1.10, 1.2, 1.3, 1.4 }

local MUTATION_IMAGES = {
	RevolverGuard = {
		[1] = "rbxassetid://132739787429109",
		[2] = "rbxassetid://128257399819685",
		[3] = "rbxassetid://72956303264604",
		[4] = "rbxassetid://97526334862988",
	},
	DualRevolverGuard = {
		[1] = "rbxassetid://85841518982837",
		[2] = "rbxassetid://119178152048750",
		[3] = "rbxassetid://76605895704232",
		[4] = "rbxassetid://110654873125512",
	},
	SubmachineGunGuard = {
		[1] = "rbxassetid://112682836269230",
		[2] = "rbxassetid://117726000125383",
		[3] = "rbxassetid://91758128710538",
		[4] = "rbxassetid://126017085127710",
	},
	RifleGuard = {
		[1] = "rbxassetid://116993191702178",
		[2] = "rbxassetid://132651447738530",
		[3] = "rbxassetid://111461787411888",
		[4] = "rbxassetid://74644215753266",
	},
	ShotgunGuard = {
		[1] = "rbxassetid://81501793595409",
		[2] = "rbxassetid://84050774573694",
		[3] = "rbxassetid://124834736686053",
		[4] = "rbxassetid://79931546514777",
	},
	GatlingGuard = {
		[1] = "rbxassetid://79150585476282",
		[2] = "rbxassetid://140395535147598",
		[3] = "rbxassetid://133302387592107",
		[4] = "rbxassetid://127328237788388",
	},
}


local function makeMutation(baseId: string, tier: number)
	local base = ItemConfigurations[baseId]
	if not base then
		warn("[ItemConfigurations] Missing base for mutation: ", baseId)
		return nil
	end

	local clone = table.clone(base)
	clone.DisplayName = (base.DisplayName or baseId)..("L%d"):format(tier)
	clone.Damage = math.floor((base.Damage or 0) * (DAMAGE_MULT[tier] or 1))
	clone.Health = math.floor((base.Health or 0) * (HEALTH_MULT[tier] or 1))
	clone.Purchasable = false   
	clone.ShopHidden  = true    
	clone.IsMutation  = true
	clone.BaseId      = baseId
	clone.Tier        = tier
	clone.ProductID   = nil     
	clone.Chance      = nil
	clone.StockAmount = nil
	clone.Unlimited   = nil

	local customImage = MUTATION_IMAGES[baseId] and MUTATION_IMAGES[baseId][tier]
	clone.ImageId = customImage or base.ImageId

	return clone
end


for _, baseId in ipairs({
	"RevolverGuard",
	"DualRevolverGuard",
	"SubmachineGunGuard",
	"RifleGuard",
	"ShotgunGuard",
	"GatlingGuard",
	}) do
	for tier = 1, 4 do
		local mid = ("%s_M%d"):format(baseId, tier)
		ItemConfigurations[mid] = makeMutation(baseId, tier)
	end
end

return ItemConfigurations

---

--- LeaderboardConfig (ModuleScript) :
--!strict
local LeaderboardConfig = {
	DataStores = {
		MostCash       = "LB_MostCash_v1",
		MostWaves      = "LB_MostWaves_v1",
		MostPlaytime   = "LB_MostPlaytime_v1",
		MostRobuxSpent = "LB_MostRobuxSpent_v1", 
	},

	UI = {
		CanvasSize    = Vector2.new(900, 700),
		PixelsPerStud = 45,
		Bg            = Color3.fromRGB(30,170,255),
		Stroke        = Color3.fromRGB(0,0,0),
		TitleColor    = Color3.fromRGB(255,255,255),
		TextColor     = Color3.fromRGB(240,240,240),
		TitleSize     = 42,
		RowSize       = 28,
		RowPad        = 12,
	},


	Limit        = 10,
	PullInterval = 120,


	ModelNames = {
		Cash     = "MostCash",
		Waves    = "MostWaves",
		Playtime = "MostPlaytime",
		Robux    = "MostRobuxSpent",
	},


	BoardPartName = "Board",
}
return LeaderboardConfig

---

--- Maid (ModuleScript) :
--!strict
-- A class for managing the cleanup of events and other objects.

local Maid = {}
Maid.__index = Maid

function Maid.new()
	local self = setmetatable({}, Maid)
	self._tasks = {}
	return self
end

function Maid:GiveTask(task: RBXScriptConnection | Instance | (() -> ()))
	if not task then
		return
	end

	local index = #self._tasks + 1
	self._tasks[index] = task
	return index
end

function Maid:DoCleaning()
	for _, task in ipairs(self._tasks) do
		if typeof(task) == "function" then
			task()
		elseif typeof(task) == "RBXScriptConnection" then
			task:Disconnect()
		elseif typeof(task) == "Instance" then
			task:Destroy()
		end
	end
	table.clear(self._tasks)
end

function Maid:Destroy()
	self:DoCleaning()
	table.clear(self)
end

return Maid
---

--- ModelProgression (ModuleScript) :
--!strict
-- This module defines the progression of items the player protects.

local ModelProgression = {
	-- IMPORTANT: The tables must be in order, starting from 1.

	[1] = {
		ModelName = "1",
		PlotHealth = 10,
		WaveRequirement = 0,
		ImageId = "rbxassetid://110988601683343",
	},
	[2] = {
		ModelName = "2",
		PlotHealth = 20,
		WaveRequirement = 15,
		ImageId = "rbxassetid://71530011018392",
	},
	[3] = {
		ModelName = "3",
		PlotHealth = 30,
		WaveRequirement = 45,
		ImageId = "rbxassetid://70765293183243",
	},
	[4] = {
		ModelName = "4",
		PlotHealth = 40,
		WaveRequirement = 60,
		ImageId = "rbxassetid://127554191147986",
	},
	[5] = {
		ModelName = "5",
		PlotHealth = 50,
		WaveRequirement = 75,
		ImageId = "rbxassetid://101196843053573",
	},
	[6] = {
		ModelName = "6",
		PlotHealth = 50,
		WaveRequirement = 120,
		ImageId = "rbxassetid://109464415588878",
	},
	[7] = {
		ModelName = "7",
		PlotHealth = 50,
		WaveRequirement = 150,
		ImageId = "rbxassetid://122966550318789",
	},
	[8] = {
		ModelName = "8",
		PlotHealth = 50,
		WaveRequirement = 205,
		ImageId = "rbxassetid://111332197178362",
	},
}

return ModelProgression
---

--- NotificationManager (ModuleScript) :
--!strict
-- ReplicatedStorage.Modules.NotificationManager.lua (Client-only module)

local CollectionService = game:GetService("CollectionService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SoundService = game:GetService("SoundService")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting") -- ## ADDED ##

local NotificationManager = {}

local playerGui: PlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
local notificationFrame: Frame = playerGui:WaitForChild("GUI"):WaitForChild("Frames"):WaitForChild("Notifications")
local notificationTemplate: TextLabel = ReplicatedStorage:WaitForChild("Templates"):WaitForChild("NotificationTemplate")

local TWEEN_INFO_FADE: TweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
local NOTIFICATION_LIFETIME: number = 5

-- ## ADDED ## Variables for the time shift effect
local ORIGINAL_CLOCK_TIME = 14.5
local isTimeShifted = false

-- Color definitions
local successStrokeColor = Color3.fromRGB(33, 100, 0)
local successGradient = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 0)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 0))
})

local errorStrokeColor = Color3.fromRGB(145, 0, 0)
local errorGradient = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 85, 127))
})

local normalStrokeColor = Color3.fromRGB(145, 97, 0)
local normalGradient = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 170, 0)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 0))
})

-- ## ADDED ## New styles for Legendary and Mythical
local legendaryStrokeColor = Color3.fromRGB(125, 0, 0)
local legendaryGradient = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 0))
})

local mythicalStrokeColor = Color3.fromRGB(100, 33, 50)
local mythicalGradient = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 127)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 170, 127))
})


-- ## NEW FUNCTION ## Handles the entire day-to-night-to-day animation
local function triggerTimeShift()
	if isTimeShifted then return end
	isTimeShifted = true

	local tweenInfo = TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)

	-- Transition to night
	local toNightTween = TweenService:Create(Lighting, tweenInfo, {ClockTime = 0})
	toNightTween:Play()
	toNightTween.Completed:Wait()

	-- Hold for 5 seconds
	task.wait(5)

	-- Transition back to day
	local toDayTween = TweenService:Create(Lighting, tweenInfo, {ClockTime = ORIGINAL_CLOCK_TIME})
	toDayTween:Play()
	toDayTween.Completed:Wait()

	isTimeShifted = false
end


function NotificationManager.show(message: string, messageType: string?)
	local newNotification: TextLabel = notificationTemplate:Clone()
	newNotification.Text = message

	local stroke: UIStroke? = newNotification:FindFirstChild("Stroke")
	local gradient: UIGradient? = newNotification:FindFirstChild("Gradient")
	local lifetime = NOTIFICATION_LIFETIME

	if not stroke or not gradient then
		if messageType == "Success" then
			newNotification.TextColor3 = successStrokeColor --  FIX APPLIED HERE
		elseif messageType == "Error" then
			newNotification.TextColor3 = errorStrokeColor --  FIX APPLIED HERE
		end
	else
		if messageType == "Success" then
			stroke.Color = successStrokeColor
			gradient.Color = successGradient
		elseif messageType == "Error" then
			stroke.Color = errorStrokeColor
			gradient.Color = errorGradient
		elseif messageType == "Gemstone" then 
			stroke.Color = Color3.fromRGB(73, 17, 13)
			gradient.Color = ColorSequence.new(Color3.fromRGB(253, 13, 13), Color3.fromRGB(253, 86, 99))
			lifetime = 5
		elseif messageType == "Legendary" then
			stroke.Color = legendaryStrokeColor
			gradient.Color = legendaryGradient
			lifetime = 7
			task.spawn(triggerTimeShift) -- ## ADDED ##
		elseif messageType == "Mythical" then
			stroke.Color = mythicalStrokeColor
			gradient.Color = mythicalGradient
			lifetime = 10
			task.spawn(triggerTimeShift) -- ## ADDED ##
		elseif messageType == "Normal" then
			stroke.Color = normalStrokeColor
			gradient.Color = normalGradient
		else
			stroke.Color = normalStrokeColor
			gradient.Color = normalGradient
		end
	end

	newNotification.Parent = notificationFrame

	newNotification.TextTransparency = 1
	if stroke then stroke.Transparency = 1 end

	local textFadeIn: Tween = TweenService:Create(newNotification, TWEEN_INFO_FADE, {TextTransparency = 0})
	local strokeFadeIn: Tween? = stroke and TweenService:Create(stroke, TWEEN_INFO_FADE, {Transparency = 0})

	textFadeIn:Play()
	if strokeFadeIn then strokeFadeIn:Play() end

	if messageType and messageType ~= "NotNormal" then
		local sound: Sound? = Workspace.Sounds:FindFirstChild(messageType)
		if sound then
			SoundService:PlayLocalSound(sound)
		end
	end

	task.wait(lifetime)

	local textFadeOut: Tween = TweenService:Create(newNotification, TWEEN_INFO_FADE, {TextTransparency = 1})
	local strokeFadeOut: Tween? = stroke and TweenService:Create(stroke, TWEEN_INFO_FADE, {Transparency = 1})

	textFadeOut:Play()
	if strokeFadeOut then strokeFadeOut:Play() end

	textFadeOut.Completed:Wait()
	newNotification:Destroy()
end

return NotificationManager
---

--- NumberFormatter (ModuleScript) :
--!strict

local NumberFormatter = {}

local suffixes: {string} = {"", "K", "M", "B", "T", "Q"}

-- ## MODIFIED ## Changed to a more generic function that accepts an optional prefix.
function NumberFormatter.formatNumber(number: number, prefix: string?): string
	-- Use the provided prefix, or an empty string if none is given.
	local formattedString: string = prefix or ""
	local i: number = 1

	while number >= 1000 and i < #suffixes do
		number /= 1000
		i += 1
	end

	local suffix: string = suffixes[i]
	if suffix == "" then
		formattedString ..= tostring(math.floor(number))
	else
		formattedString ..= string.format("%.2f", number) .. suffix
	end

	return formattedString
end

return NumberFormatter
---

--- PlacementHandler (ModuleScript) :
--!strict
-- Client placement handler with screen-anchored mobile HUD ( place,  rotate).
-- Desktop: click to place / R to rotate (unchanged).
-- Mobile: your Templates/MobileUi lives in PlayerGui and follows the ghost; we don't resize it.

--// Services
local UserInputService     = game:GetService("UserInputService")
local RunService           = game:GetService("RunService")
local ReplicatedStorage    = game:GetService("ReplicatedStorage")
local Workspace            = game:GetService("Workspace")
local CollectionService    = game:GetService("CollectionService")
local HttpService          = game:GetService("HttpService")
local ContextActionService = game:GetService("ContextActionService")
local Players              = game:GetService("Players")

local player    = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local mouse     = player:GetMouse()

--// Modules
local ItemConfigurations  = require(script.Parent:WaitForChild("ItemConfigurations"))
local NotificationManager = require(script.Parent:WaitForChild("NotificationManager"))
local FrameManager        = require(script.Parent:WaitForChild("FrameManager"))

--// Net
local EventsFolder     = ReplicatedStorage:WaitForChild("Events")
local FunctionsFolder  = ReplicatedStorage:WaitForChild("Functions")

local PlaceItemEvent        = EventsFolder:WaitForChild("PlaceItemEvent")
local RemoveItemEvent       = EventsFolder:WaitForChild("RemoveItemEvent")
local BlockInventoryUpdated = EventsFolder:WaitForChild("BlockInventoryUpdated")
local ItemPlacedFX          = EventsFolder:WaitForChild("ItemPlacedFX")
local ItemRemovedFX         = EventsFolder:WaitForChild("ItemRemovedFX")
local PlacementDenied       = EventsFolder:WaitForChild("PlacementDenied")
local GetBlockInventory     = FunctionsFolder:WaitForChild("GetBlockInventory")

--// Assets
local SoundsFolder = ReplicatedStorage:WaitForChild("Sounds")
local PlaceSound   = SoundsFolder:WaitForChild("PlaceSound")
local DeleteSound  = SoundsFolder:WaitForChild("DeleteSound")

local BLOCKS_MODELS  = ReplicatedStorage:WaitForChild("Blocks")
local TURRETS_MODELS = ReplicatedStorage:FindFirstChild("Turrets")

-- ====== CONFIG ======
local GRID_SIZE               = 4
local ROTATION_INCREMENT      = 90
local GHOST_ITEM_TRANSPARENCY = 0.7
local DELETE_HIGHLIGHT_TRANSPARENCY = 0.3
local HIDDEN_POSITION         = CFrame.new(0, -1000, 0)
local VALID_COLOR             = Color3.fromRGB(0, 255, 0)
local INVALID_COLOR           = Color3.fromRGB(255, 0, 0)
local GHOST_ITEM_TAG          = "ClientGhostItem"
local EPS                     = 0.05
local MAX_HEIGHT              = 4 -- must match server

-- Screen HUD settings (we DO NOT resize your UI)
local HUD_STUDS_OFFSET_Y = 6
local HUD_TEMPLATE_PATH = { "Templates", "MobileUi" } -- ReplicatedStorage/Templates/MobileUi

local function getTemplate(): Instance?
	local obj: Instance? = ReplicatedStorage
	for _, name in ipairs(HUD_TEMPLATE_PATH) do
		obj = obj and obj:FindFirstChild(name)
	end
	return obj
end
local HUD_TEMPLATE: Instance? = getTemplate() -- Frame with ConfirmButton & RotateButton

-- ====== State ======
local PlacementHandler = {}
local inventoryState = Instance.new("StringValue")
PlacementHandler.InventoryState = inventoryState

PlacementHandler.State = {
	isActive                      = false,
	isDeleteMode                  = false,
	ghostModel                    = nil :: Model?,
	currentItemId                 = nil :: string?,
	currentRotation               = 0,
	canPlace                      = false,
	playerPlot                    = nil :: Model?,
	highlightedItem               = nil :: { Model: Model, OriginalProperties: {[BasePart]: { Color: Color3, Transparency: number }} }?,
	currentInventory              = {} :: {[string]: number},
	originalRangePartTransparency = nil :: number?,
	selectionBox                  = nil :: SelectionBox?,
	highlightColor                = nil :: Color3?,
}

function PlacementHandler:GetInventory()
	return self.State.currentInventory
end

-- ====== Screen-anchored HUD (follows ghost)
local screenHud: ScreenGui?
local hudRoot: Frame?
local hudConns: { RBXScriptConnection } = {}
local followConn: RBXScriptConnection?

-- ====== Helpers ======
local function findMyPlot(): Model?
	for _, plot in ipairs(Workspace:WaitForChild("Plots"):GetChildren()) do
		if plot:IsA("Model") and plot:GetAttribute("OwnerId") == player.UserId then
			return plot
		end
	end
	return nil
end

local function getPlacementBox(model: Model): BasePart?
	local pb = model:FindFirstChild("PlacementBox")
	if pb and pb:IsA("BasePart") then
		return pb
	end
	return nil
end

local function isBlock(itemId: string): boolean
	local cfg = ItemConfigurations[itemId]
	return (cfg and cfg.Type == "Blocks") == true
end

local function isTurret(itemId: string): boolean
	local cfg = ItemConfigurations[itemId]
	return (cfg and cfg.Type == "Turrets") == true
end

local function unbindLegacyReload()
	for _, name in ipairs({ "Reload", "GunReload", "Gun_Reload", "ReloadAction" }) do
		ContextActionService:UnbindAction(name)
	end
end

local function isTypingInTextBox(): boolean
	return UserInputService:GetFocusedTextBox() ~= nil
end

local function applyGhostRotation(ghost: Model, deg: number)
	if not (ghost and ghost.PrimaryPart) then return end
	local pp = ghost.PrimaryPart
	local pos = pp.CFrame.Position
	local yAngle = math.rad(deg)
	local newCF = CFrame.new(pos) * CFrame.Angles(0, yAngle, 0)
	ghost:PivotTo(newCF)
end

local function getFootprintXZ(pb: BasePart, rotationDeg: number): (number, number)
	local rx = pb.Size.X
	local rz = pb.Size.Z
	local rot = ((rotationDeg % 360) + 360) % 360
	if rot == 90 or rot == 270 then
		return rz, rx
	end
	return rx, rz
end

-- ====== Screen HUD build/destroy ======
local function disconnectHud()
	for _, c in ipairs(hudConns) do
		pcall(function() c:Disconnect() end)
	end
	table.clear(hudConns)
	if followConn then
		pcall(function() followConn:Disconnect() end)
		followConn = nil
	end
end

local function destroyHud()
	disconnectHud()
	if screenHud then
		screenHud:Destroy()
		screenHud = nil
		hudRoot = nil
	end
end

local function buildScreenHud(adorneePart: BasePart)
	destroyHud()
	if not UserInputService.TouchEnabled then return end

	screenHud = Instance.new("ScreenGui")
	screenHud.Name = "PlacementScreenHUD"
	screenHud.ResetOnSpawn = false
	screenHud.IgnoreGuiInset = false
	screenHud.Parent = playerGui

	assert(HUD_TEMPLATE and HUD_TEMPLATE:IsA("Frame"), "[PlacementHandler] Templates/MobileUi not found or not a Frame")
	hudRoot = (HUD_TEMPLATE :: Frame):Clone()
	hudRoot.Name = "MobileUi"
	hudRoot.AnchorPoint = Vector2.new(0.5, 0.5) -- center
	hudRoot.Parent = screenHud

	local confirmBtn = hudRoot:FindFirstChild("ConfirmButton", true) :: GuiButton?
	local rotateBtn  = hudRoot:FindFirstChild("RotateButton",  true) :: GuiButton?

	if confirmBtn then
		table.insert(hudConns, confirmBtn.Activated:Connect(function()
			local S = PlacementHandler.State
			if S.isActive and not S.isDeleteMode then
				if S.canPlace and S.ghostModel and S.currentItemId then
					PlaceItemEvent:FireServer(S.currentItemId, S.ghostModel:GetPrimaryPartCFrame(), S.playerPlot)
				else
					NotificationManager.show("Not enough space!", "Error")
				end
			end
		end))
	end

	if rotateBtn then
		table.insert(hudConns, rotateBtn.Activated:Connect(function()
			local S = PlacementHandler.State
			if S.isActive and not S.isDeleteMode then
				S.currentRotation = (S.currentRotation + ROTATION_INCREMENT) % 360
				if S.ghostModel then
					applyGhostRotation(S.ghostModel, S.currentRotation)
					task.defer(function() PlacementHandler:_UpdatePlacementPreview() end)
				end
			end
		end))
	end

	-- Follow the ghost in screen space
	local cam = Workspace.CurrentCamera
	followConn = RunService.RenderStepped:Connect(function()
		if not (cam and hudRoot and adorneePart and adorneePart.Parent) then return end
		local worldPos = adorneePart.Position + Vector3.new(0, HUD_STUDS_OFFSET_Y, 0)
		local v3, onScreen = cam:WorldToViewportPoint(worldPos)
		hudRoot.Visible = onScreen and v3.Z > 0
		if not hudRoot.Visible then return end
		hudRoot.Position = UDim2.fromOffset(v3.X, v3.Y)
	end)
end

-- ====== Core actions ======
local function _PlaceCurrentItem()
	local S = PlacementHandler.State
	if not S.isActive or S.isDeleteMode then return end
	if not S.canPlace then
		NotificationManager.show("Not enough space!", "Error")
		return
	end

	local currentItemId = S.currentItemId
	if currentItemId then
		local ownedCount = S.currentInventory[currentItemId] or 0
		if ownedCount <= 0 then
			NotificationManager.show("Not enough stock!", "Error")
			FrameManager.open("Inventory")
			PlacementHandler:ExitAllModes()
			return
		end
	end

	if S.ghostModel and currentItemId then
		PlaceItemEvent:FireServer(currentItemId, S.ghostModel:GetPrimaryPartCFrame(), S.playerPlot)
	end
end

local function _deleteModel(model: Model?)
	if not model then return end
	RemoveItemEvent:FireServer(model)
end

local function _topPlacedModelUnderPart(part: BasePart?, plot: Model?): Model?
	if not (part and plot) then return nil end
	local a: Instance? = part
	while a and a.Parent ~= plot do
		a = a.Parent
	end
	if a and (a :: Instance):GetAttribute("IsPlacedItem") then
		return a :: Model
	end
	return nil
end

local function _deleteAtScreenPoint(pos: Vector2)
	local S = PlacementHandler.State
	if not S.playerPlot then return end
	local camera = Workspace.CurrentCamera
	if not camera then return end

	for _, gui in ipairs(playerGui:GetGuiObjectsAtPosition(pos.X, pos.Y)) do
		if gui:IsA("GuiButton") then
			return
		end
	end

	local ray = camera:ScreenPointToRay(pos.X, pos.Y)
	local rp = RaycastParams.new()
	rp.FilterType = Enum.RaycastFilterType.Whitelist
	rp.FilterDescendantsInstances = { S.playerPlot }

	local res = Workspace:Raycast(ray.Origin, ray.Direction * 1000, rp)
	if not res then return end

	local model = _topPlacedModelUnderPart(res.Instance, S.playerPlot)
	if model then
		_deleteModel(model)
	end
end

-- ====== Placement Preview (raycast, under-fill & stacking rules) ======
local function countBlocksInColumn(plot: Model, xz: Vector3, footprint: Vector3): (number, Model?, BasePart?, boolean, boolean)
	local blocksCount = 0
	local topModel: Model? = nil
	local topPB: BasePart? = nil
	local topIsBlock = false
	local topIsTurret = false
	local bestTopY = -math.huge

	for _, ch in ipairs(plot:GetChildren()) do
		if not CollectionService:HasTag(ch, "PlacedItem") then
			continue
		end
		local pb = getPlacementBox(ch)
		if not pb then
			continue
		end

		local dx = math.abs(pb.Position.X - xz.X)
		local dz = math.abs(pb.Position.Z - xz.Z)
		local fitsXZ = (dx <= math.max(pb.Size.X, footprint.X)/2 + EPS)
			and (dz <= math.max(pb.Size.Z, footprint.Z)/2 + EPS)

		if fitsXZ then
			local cfg = ItemConfigurations[ch.Name]
			if cfg and cfg.Type == "Blocks" then
				blocksCount += 1
			end
			local topY = pb.Position.Y + pb.Size.Y/2
			if topY > bestTopY then
				bestTopY = topY
				topModel = ch
				topPB = pb
				topIsBlock = (cfg and cfg.Type == "Blocks") == true
				topIsTurret = (cfg and cfg.Type == "Turrets") == true
			end
		end
	end

	return blocksCount, topModel, topPB, topIsBlock, topIsTurret
end

function PlacementHandler:_UpdatePlacementPreview()
	-- ignore when over UI buttons
	local guiObjects = playerGui:GetGuiObjectsAtPosition(mouse.X, mouse.Y)
	for _, object in ipairs(guiObjects) do
		if object:IsA("GuiButton") then
			return
		end
	end

	local S = self.State
	if not (S.ghostModel and S.ghostModel.PrimaryPart) then return end

	-- Ensure plot reference
	if not S.playerPlot then
		S.playerPlot = findMyPlot()
		if not S.playerPlot then return end
	elseif not S.playerPlot.Parent then
		S.playerPlot = nil
		return
	end

	local plotBase = S.playerPlot:FindFirstChild("Base")
	if not plotBase then return end

	local camera = Workspace.CurrentCamera
	if not camera then return end

	-- 1) Raycast to plot
	local rcParams = RaycastParams.new()
	rcParams.FilterType = Enum.RaycastFilterType.Whitelist
	rcParams.FilterDescendantsInstances = { S.playerPlot }

	local ray = camera:ScreenPointToRay(mouse.X, mouse.Y)
	local result = Workspace:Raycast(ray.Origin, ray.Direction * 1000, rcParams)

	local worldHitPos: Vector3
	if result then
		worldHitPos = result.Position
	else
		-- fallback: plane projection onto base
		local planeN = plotBase.CFrame.UpVector
		local denom = ray.Direction:Dot(planeN)
		if math.abs(denom) < 1e-4 then
			S.ghostModel:PivotTo(HIDDEN_POSITION)
			S.canPlace = false
			return
		end
		local t = (plotBase.Position - ray.Origin):Dot(planeN) / denom
		if t < 0 then
			S.ghostModel:PivotTo(HIDDEN_POSITION)
			S.canPlace = false
			return
		end
		worldHitPos = ray.Origin + ray.Direction * t
	end

	-- 2) Snap X/Z to grid (rotation-aware footprint)
	local plotLocal = plotBase.CFrame:ToObjectSpace(CFrame.new(worldHitPos))
	local halfPlotSize = plotBase.Size / 2

	local pb = getPlacementBox(S.ghostModel)
	if not pb then return end
	local boxX, boxZ = getFootprintXZ(pb, S.currentRotation)
	local boxSize = Vector3.new(boxX, pb.Size.Y, boxZ)

	local shiftedX = plotLocal.X + halfPlotSize.X
	local snappedCornerX = math.floor(shiftedX / GRID_SIZE) * GRID_SIZE
	local x = (snappedCornerX + boxSize.X / 2) - halfPlotSize.X

	local shiftedZ = plotLocal.Z + halfPlotSize.Z
	local snappedCornerZ = math.floor(shiftedZ / GRID_SIZE) * GRID_SIZE
	local z = (snappedCornerZ + boxSize.Z / 2) - halfPlotSize.Z

	-- Clamp inside plot
	local halfBoxSize = boxSize / 2
	x = math.clamp(x, -halfPlotSize.X + halfBoxSize.X, halfPlotSize.X - halfBoxSize.X)
	z = math.clamp(z, -halfPlotSize.Z + halfBoxSize.Z, halfPlotSize.Z - halfBoxSize.Z)

	-- 3) Choose support at/under aimed height (under-fill)
	local colCenterWorld = plotBase.CFrame * Vector3.new(x, 0, z)
	local aimY = worldHitPos.Y

	local chosenSupportTopY = plotBase.Position.Y + plotBase.Size.Y/2
	local chosenSupportModel: Model? = nil
	local chosenSupportIsTurret = false
	local bestTopY = -math.huge

	for _, ch in ipairs(S.playerPlot:GetChildren()) do
		if not CollectionService:HasTag(ch, "PlacedItem") then
			continue
		end
		local spb = ch:FindFirstChild("PlacementBox")
		if not (spb and spb:IsA("BasePart")) then
			continue
		end

		local dx = math.abs(spb.Position.X - colCenterWorld.X)
		local dz = math.abs(spb.Position.Z - colCenterWorld.Z)
		local fitsXZ = (dx <= math.max(spb.Size.X, boxSize.X)/2 + EPS)
			and (dz <= math.max(spb.Size.Z, boxSize.Z)/2 + EPS)
		if not fitsXZ then
			continue
		end

		local topY = spb.Position.Y + spb.Size.Y/2
		if topY <= (aimY + EPS) and topY > bestTopY then
			bestTopY = topY
			chosenSupportTopY = topY
			chosenSupportModel = ch
			local cfg = ItemConfigurations[ch.Name]
			chosenSupportIsTurret = (cfg and cfg.Type == "Turrets") == true
		end
	end

	-- 4) Set ghost on top of chosen support (base if none matched)
	local ghost = S.ghostModel
	local ghostHalfY = ghost.PrimaryPart.Size.Y/2
	local finalCF = CFrame.new(colCenterWorld.X, chosenSupportTopY + ghostHalfY, colCenterWorld.Z)
	finalCF *= CFrame.Angles(0, math.rad(S.currentRotation), 0)
	ghost:PivotTo(finalCF)

	-- 5) Client overlap probe (hint only)
	local isOverlapping = false
	local overlapParams = OverlapParams.new()
	overlapParams.FilterDescendantsInstances = { S.ghostModel }

	local parts = Workspace:GetPartsInPart(getPlacementBox(S.ghostModel) :: BasePart, overlapParams)
	for _, part in ipairs(parts) do
		local m = part:FindFirstAncestorOfClass("Model")
		if (m and m:GetAttribute("IsPlacedItem")) or part.Name == "PlotHealth" then
			isOverlapping = true
			break
		end
	end

	-- 6) Count total blocks in column for height cap
	local blocksCount = 0
	for _, ch in ipairs(S.playerPlot:GetChildren()) do
		if not CollectionService:HasTag(ch, "PlacedItem") then
			continue
		end
		local spb = ch:FindFirstChild("PlacementBox")
		if not (spb and spb:IsA("BasePart")) then
			continue
		end
		local dx = math.abs(spb.Position.X - colCenterWorld.X)
		local dz = math.abs(spb.Position.Z - colCenterWorld.Z)
		local fitsXZ = (dx <= math.max(spb.Size.X, boxSize.X)/2 + EPS)
			and (dz <= math.max(spb.Size.Z, boxSize.Z)/2 + EPS)
		if fitsXZ then
			local cfg = ItemConfigurations[ch.Name]
			if cfg and cfg.Type == "Blocks" then
				blocksCount += 1
			end
		end
	end

	-- 7) Rule checks
	local itemId = S.currentItemId or ""
	local placingBlock = isBlock(itemId)
	local placingTurret = isTurret(itemId)

	local ruleOk = true
	if placingTurret then
		ruleOk = (chosenSupportModel == nil) or not chosenSupportIsTurret
	elseif placingBlock then
		if chosenSupportIsTurret then
			ruleOk = false
		else
			ruleOk = (blocksCount + 1) <= MAX_HEIGHT
		end
	end

	S.canPlace = ruleOk and (not isOverlapping)

	-- 8) SelectionBox feedback
	if not S.selectionBox then
		S.selectionBox = Instance.new("SelectionBox")
		S.selectionBox.LineThickness = 0.2
		S.selectionBox.SurfaceColor3 = VALID_COLOR
		S.selectionBox.Color3 = VALID_COLOR
		S.selectionBox.Transparency = 0
		S.selectionBox.Adornee = pb
		S.selectionBox.Parent = pb
		S.highlightColor = VALID_COLOR
	end

	local targetColor = S.canPlace and VALID_COLOR or INVALID_COLOR
	if S.highlightColor ~= targetColor then
		S.selectionBox.Color3 = targetColor
		S.highlightColor = targetColor
	end
end

function PlacementHandler:_UpdateDeleteHighlight()
	-- Desktop hover highlight only; on mobile we delete by tap ray.
	local guiObjects = playerGui:GetGuiObjectsAtPosition(mouse.X, mouse.Y)
	for _, object in ipairs(guiObjects) do
		if object:IsA("GuiButton") then
			return
		end
	end

	local S = self.State
	local targetPart = mouse.Target
	local topLevelModel: Model? = nil

	if targetPart and S.playerPlot then
		topLevelModel = _topPlacedModelUnderPart(targetPart, S.playerPlot)
	end

	if S.highlightedItem and S.highlightedItem.Model ~= topLevelModel then
		for part, originalProperties in pairs(S.highlightedItem.OriginalProperties) do
			if part and part.Parent then
				part.Color = originalProperties.Color
				part.Transparency = originalProperties.Transparency
			end
		end
		if S.selectionBox then
			S.selectionBox:Destroy()
			S.selectionBox = nil
		end
		S.highlightedItem = nil
	end

	if topLevelModel and not S.highlightedItem then
		local originalProperties: {[BasePart]: { Color: Color3, Transparency: number }} = {}
		local placementBox = topLevelModel:FindFirstChild("PlacementBox")
		for _, part in ipairs(topLevelModel:GetDescendants()) do
			if part:IsA("BasePart") then
				originalProperties[part] = { Color = part.Color, Transparency = part.Transparency }
				part.Color = INVALID_COLOR
				if part.Name == "PlacementBox" then
					part.Transparency = 1
				else
					part.Transparency = DELETE_HIGHLIGHT_TRANSPARENCY
				end
			end
		end
		PlacementHandler.State.highlightedItem = { Model = topLevelModel, OriginalProperties = originalProperties }
		if placementBox and not S.selectionBox then
			S.selectionBox = Instance.new("SelectionBox")
			S.selectionBox.LineThickness = 0.2
			S.selectionBox.Color3 = INVALID_COLOR
			S.selectionBox.Transparency = 0
			S.selectionBox.Adornee = placementBox
			S.selectionBox.Parent = placementBox
			S.highlightColor = INVALID_COLOR
		end
	end

	if not topLevelModel and S.selectionBox then
		S.selectionBox:Destroy()
		S.selectionBox = nil
	end
end

function PlacementHandler:_Update()
	local S = self.State
	if not S.isActive then return end

	if S.playerPlot and not S.playerPlot.Parent then
		S.playerPlot = nil
	end
	if not S.playerPlot then
		S.playerPlot = findMyPlot()
		if not S.playerPlot then return end
	end

	if S.isDeleteMode then
		self:_UpdateDeleteHighlight()
	else
		self:_UpdatePlacementPreview()
	end

	-- Optional UX: dim your confirm image when invalid placement
	if hudRoot and S.isActive and not S.isDeleteMode then
		local confirm = hudRoot:FindFirstChild("ConfirmButton", true)
		if confirm and confirm:IsA("GuiButton") then
			(confirm :: GuiButton).AutoButtonColor = S.canPlace
			local confirmImage = (confirm :: GuiButton):FindFirstChild("ConfirmImage", true)
			if confirmImage and (confirmImage:IsA("ImageLabel") or confirmImage:IsA("ImageButton")) then
				(confirmImage :: any).ImageTransparency = S.canPlace and 0 or 0.4
			end
		end
	end
end

-- ====== Input (desktop); mobile uses screen HUD ======
function PlacementHandler:_HandleInput(input: InputObject, gameProcessed: boolean)
	local S = self.State

	-- PC: R to rotate (reliable)
	if not UserInputService.TouchEnabled
		and input.KeyCode == Enum.KeyCode.R
		and input.UserInputState == Enum.UserInputState.Begin
		and not isTypingInTextBox()
		and S.isActive and not S.isDeleteMode
	then
		S.currentRotation = (S.currentRotation + ROTATION_INCREMENT) % 360
		if S.ghostModel then
			applyGhostRotation(S.ghostModel, S.currentRotation)
			task.defer(function() self:_UpdatePlacementPreview() end)
		end
		return
	end

	if gameProcessed then return end

	if S.isDeleteMode then
		if input.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputState == Enum.UserInputState.Begin then
			if not UserInputService.TouchEnabled then
				if S.highlightedItem and S.highlightedItem.Model then
					_deleteModel(S.highlightedItem.Model)
				else
					local model = _topPlacedModelUnderPart(mouse.Target, S.playerPlot)
					_deleteModel(model)
				end
			end
		elseif input.KeyCode == Enum.KeyCode.Q and input.UserInputState == Enum.UserInputState.Begin then
			self:ExitAllModes()
		end
	else
		if input.UserInputType == Enum.UserInputType.MouseButton1 and input.UserInputState == Enum.UserInputState.Begin then
			if not UserInputService.TouchEnabled then
				_PlaceCurrentItem()
			end
		elseif input.KeyCode == Enum.KeyCode.Q and input.UserInputState == Enum.UserInputState.Begin then
			self:ExitAllModes()
		end
	end
end

-- ====== Touch handling (MOBILE)  rely on screen HUD; keep tap-to-delete only ======
local touchTapConn: RBXScriptConnection?

local function refreshTouchTapConn()
	if touchTapConn then
		touchTapConn:Disconnect()
		touchTapConn = nil
	end
	if not UserInputService.TouchEnabled then return end
	local S = PlacementHandler.State
	touchTapConn = UserInputService.TouchTap:Connect(function(positions)
		if not S.isActive then return end
		local pt = positions[1]
		if not pt then return end

		-- Let GUI consume taps
		for _, o in ipairs(playerGui:GetGuiObjectsAtPosition(pt.X, pt.Y)) do
			if o:IsA("GuiButton") then return end
		end

		if S.isDeleteMode then
			_deleteAtScreenPoint(pt)
		else
			-- With screen HUD, do NOT place on world tap; use 
		end
	end)
end

-- ====== Mode switches ======
function PlacementHandler:ExitAllModes()
	local S = self.State
	S.isActive = false
	S.isDeleteMode = false

	if S.ghostModel then
		local rangePart = S.ghostModel:FindFirstChild("RangePart")
		if rangePart and rangePart:IsA("BasePart") then
			rangePart.Transparency = S.originalRangePartTransparency or 1
		end
		S.ghostModel:Destroy()
		S.ghostModel = nil
	end

	if S.selectionBox then
		S.selectionBox:Destroy()
		S.selectionBox = nil
	end

	if S.highlightedItem then
		for part, originalProperties in pairs(S.highlightedItem.OriginalProperties) do
			if part and part.Parent then
				part.Color = originalProperties.Color
				part.Transparency = originalProperties.Transparency
			end
		end
		S.highlightedItem = nil
	end

	S.currentItemId = nil
	S.currentRotation = 0
	S.originalRangePartTransparency = nil
	S.highlightColor = nil

	-- Clean mobile HUD
	destroyHud()
	refreshTouchTapConn()
end

function PlacementHandler:EnterPlacementMode(itemId: string)
	self:ExitAllModes()

	local template = BLOCKS_MODELS:FindFirstChild(itemId) or (TURRETS_MODELS and TURRETS_MODELS:FindFirstChild(itemId))
	if not (template and template.PrimaryPart) then return end

	local ghost = template:Clone()
	CollectionService:AddTag(ghost, GHOST_ITEM_TAG)

	-- Anchor ALL parts, disable collisions, make visible (except PlacementBox).
	for _, part in ipairs(ghost:GetDescendants()) do
		if part:IsA("BasePart") then
			part.Anchored = true
			part.CanCollide = false
			if part.Name ~= "PlacementBox" then
				part.Transparency = GHOST_ITEM_TRANSPARENCY
			else
				part.Transparency = 1
			end
		end
	end

	local itemConfig = ItemConfigurations[itemId]
	if itemConfig and itemConfig.Type == "Turrets" then
		local rangePart = ghost:FindFirstChild("RangePart")
		if rangePart and rangePart:IsA("BasePart") and itemConfig.Range then
			local radius = itemConfig.Range
			local diameter = radius * 2
			self.State.originalRangePartTransparency = rangePart.Transparency
			rangePart.Size = Vector3.new(0.25, diameter, diameter)
			rangePart.Transparency = GHOST_ITEM_TRANSPARENCY
			rangePart.CanCollide = false
			rangePart.Anchored = true
		end
	end

	self.State.ghostModel = ghost
	self.State.currentItemId = itemId
	self.State.isActive = true
	self.State.isDeleteMode = false
	ghost.Parent = Workspace

	applyGhostRotation(ghost, self.State.currentRotation)

	-- Mobile: screen HUD follows the ghost
	if UserInputService.TouchEnabled then
		local adornee = ghost.PrimaryPart or ghost:FindFirstChildWhichIsA("BasePart")
		if adornee then
			buildScreenHud(adornee)
		end
	end

	refreshTouchTapConn()
end

function PlacementHandler:EnterDeleteMode()
	self:ExitAllModes()
	self.State.isActive = true
	self.State.isDeleteMode = true
	-- No HUD in delete mode
	refreshTouchTapConn()
end

-- ====== Loop / Signals ======
function PlacementHandler:Init()
	unbindLegacyReload()

	RunService.Heartbeat:Connect(function()
		self:_Update()
	end)

	UserInputService.InputBegan:Connect(function(i: InputObject, gp: boolean)
		self:_HandleInput(i, gp)
	end)

	ItemPlacedFX.OnClientEvent:Connect(function()
		PlaceSound:Play()
	end)
	ItemRemovedFX.OnClientEvent:Connect(function()
		DeleteSound:Play()
	end)

	PlacementDenied.OnClientEvent:Connect(function(msg: string)
		NotificationManager.show(msg, "Error")
	end)

	BlockInventoryUpdated.OnClientEvent:Connect(function(newInventory: {[string]: number})
		self.State.currentInventory = newInventory
		inventoryState.Value = HttpService:JSONEncode(newInventory)
		if self.State.isActive and (not self.State.isDeleteMode) and self.State.currentItemId then
			if (self.State.currentInventory[self.State.currentItemId] or 0) <= 0 then
				self:ExitAllModes()
				FrameManager.open("Inventory")
			end
		end
	end)

	local ok, initialInventory = pcall(function()
		return GetBlockInventory:InvokeServer()
	end)
	if ok and initialInventory then
		self.State.currentInventory = initialInventory
		inventoryState.Value = HttpService:JSONEncode(initialInventory)
	else
		warn("[PlacementHandler] Failed to get initial inventory:", tostring(initialInventory))
	end

	refreshTouchTapConn()
end

return PlacementHandler

---

--- TopUpModule (ModuleScript) :
--!strict
-- TopUpModule: pick nearest cash devproduct and prompt player if short on money.
-- Non-blocking API with a callback invoked as soon as the prompt closes.

local ReplicatedStorage    = game:GetService("ReplicatedStorage")
local Players              = game:GetService("Players")
local MarketplaceService   = game:GetService("MarketplaceService")

local ModulesFolder        = ReplicatedStorage:WaitForChild("Modules")
local WeaponConfigurations = require(ModulesFolder:WaitForChild("WeaponConfigurations"))

local TopUp = {}

type CashProduct = { ProductID: number, CashAmount: number }
type ResultCb = (purchased: boolean) -> ()

local function allCashProducts(): { CashProduct }
	local arr: { CashProduct } = {}
	for _, entry in pairs(WeaponConfigurations.CashProducts) do
		if typeof(entry.ProductID) == "number" and typeof(entry.CashAmount) == "number" then
			table.insert(arr, { ProductID = entry.ProductID, CashAmount = entry.CashAmount })
		end
	end
	return arr
end

function TopUp.getNearestProductId(missingAmount: number): number?
	if typeof(missingAmount) ~= "number" or missingAmount <= 0 then return nil end
	local bestId: number? = nil
	local bestDiff = math.huge
	local bestAmt  = -math.huge
	for _, p in ipairs(allCashProducts()) do
		local diff = math.abs(p.CashAmount - missingAmount)
		if diff < bestDiff or (diff == bestDiff and p.CashAmount > bestAmt) then
			bestDiff = diff
			bestAmt  = p.CashAmount
			bestId   = p.ProductID
		end
	end
	return bestId
end

-- Opens the prompt and returns immediately.
-- Returns: promptOpened:boolean
-- onResult(purchased:boolean) is called as soon as the dialog closes.
function TopUp.PromptIfShort(costOrMissing: number, balance: number?, onResult: ResultCb?): boolean
	local missing = (typeof(balance) == "number") and (costOrMissing - balance) or costOrMissing
	if typeof(missing) ~= "number" or missing <= 0 then
		return false
	end

	local productId = TopUp.getNearestProductId(missing)
	if typeof(productId) ~= "number" then
		if onResult then onResult(false) end
		return false
	end

	local lp = Players.LocalPlayer
	if not lp then
		if onResult then onResult(false) end
		return false
	end

	local conn: RBXScriptConnection? = nil
	conn = MarketplaceService.PromptProductPurchaseFinished:Connect(function(player, purchasedProductId, wasPurchased)
		if player == lp and purchasedProductId == productId then
			if conn then conn:Disconnect() end
			if onResult then
				onResult(wasPurchased == true)
			end
		end
	end)

	local ok, err = pcall(function()
		MarketplaceService:PromptProductPurchase(lp, productId)
	end)
	if not ok then
		if conn then conn:Disconnect() end
		if onResult then onResult(false) end
		return false
	end

	return true
end

return TopUp

---

--- TravellingConfigurations (ModuleScript) :
--!strict
local TravellingConfigurations = {
	-- Window stays 5 minutes (300 s)
	WINDOW_SECONDS = 300,

	-- NEW: auto-open every N minutes (use 20 for :00, :20, :40)
	AUTO_MINUTE_INTERVAL = 20,

	ADMIN_USER_IDS = {
		[936563031] = true, -- you
		[102527104] = true,
	},

	LUCK_DURATION_SECONDS = 15 * 60,
	LUCK_DROP_MULTIPLIER  = 1.50,
	LUCK_BADGE_ICON       = "rbxassetid://74485910606028",

	OFFERS = {
		{
			Id = "LuckPotion15m",
			Title = "Luck Potion (15m)",
			Kind  = "Luck",
			Duration = 15 * 60,
			Price = 12000,
			StockTotal = 2,
			Icon = "rbxassetid://74485910606028",
		},
		{
			Id = "MortarGuard",
			Title = "Mortar Cowboy",
			Kind  = "Unit",
			Price = 65000,
			StockTotal = 2,
			Icon = "rbxassetid://97959863510956",
		},
		{
			Id = "Diamond",
			Title = "Diamond Block",
			Kind  = "Block",
			Price = 25000,
			StockTotal = 2,
			Icon = "rbxassetid://90412412707609",
		},
		{
			Id = "ToxicSpike",
			Title = "Toxic Spike",
			Kind  = "Block",
			Price = 30000,
			StockTotal = 2,
			Icon = "rbxassetid://115198885487974",
		},
	},

	ALLOW_PUBLIC_RESTOCK  = false,
	RESTOCK_DEVPRODUCT_ID = 0,
	RESTOCK_INCREMENT     = 1,
}

return TravellingConfigurations

---

--- UpgradePlotConfig (ModuleScript) :
--!strict
local UpgradePlotConfig = {}

UpgradePlotConfig.MaxTier = 10

UpgradePlotConfig.TurretLimitByTier  = {10, 15, 20, 25, 30, 35, 40, 45, 50, 55}
UpgradePlotConfig.BlockLimitByTier   = {15, 30, 50, 70, 90, 100, 110, 120, 130, 140}

-- Multipliers (still applied if players already have tiers)
UpgradePlotConfig.TurretHpMultByTier = {1.00, 1.10, 1.20, 1.30, 1.40, 1.55, 1.70, 1.85, 2.05, 2.25}
UpgradePlotConfig.BlockHpMultByTier  = {1.00, 1.08, 1.16, 1.24, 1.32, 1.42, 1.52, 1.64, 1.78, 1.95}

-- Cash costs current -> next
UpgradePlotConfig.Costs_TurretLimit  = {5000, 15000, 30000, 45000, 90000, 125000, 160000, 200000}
UpgradePlotConfig.Costs_BlockLimit   = {2500, 7500, 15000, 30000, 45000, 60000, 75000, 90000, 105000, 120000}

--  Retired: disallow further HP purchases by providing no next-costs
UpgradePlotConfig.Costs_TurretHp     = {}
UpgradePlotConfig.Costs_BlockHp      = {}

function UpgradePlotConfig.GetTrackValue(track:string, tier:number): number
	local t = if track=="TurretLimitTier" then UpgradePlotConfig.TurretLimitByTier
		elseif track=="BlockLimitTier"   then UpgradePlotConfig.BlockLimitByTier
		elseif track=="TurretHpTier"     then UpgradePlotConfig.TurretHpMultByTier
		elseif track=="BlockHpTier"      then UpgradePlotConfig.BlockHpMultByTier
		else error("Unknown track "..track)
	return t[math.clamp(tier, 1, #t)]
end

function UpgradePlotConfig.GetNextCost(track:string, tier:number): number?
	if tier >= UpgradePlotConfig.MaxTier then return nil end
	local t = if track=="TurretLimitTier" then UpgradePlotConfig.Costs_TurretLimit
		elseif track=="BlockLimitTier"   then UpgradePlotConfig.Costs_BlockLimit
		elseif track=="TurretHpTier"     then UpgradePlotConfig.Costs_TurretHp
		elseif track=="BlockHpTier"      then UpgradePlotConfig.Costs_BlockHp
		else error("Unknown track "..track)
	return t[tier] -- will be nil for HP tracks -> cannot buy
end

return UpgradePlotConfig

---

--- WaveConfigurations (ModuleScript) :
--!strict
export type Group = { Enemy: string, Count: number, DelayBetweenSpawns: number }
export type WaveConfig = {
	CashReward: number?,
	Enemies: { Group },
	IsBossWave: boolean,
	BossImageId: string?,
	HealthMultiplier: number?,
	KillCashMultiplier: number?,
	DamageMultiplier: number?,
	SpawnDelayMultiplier: number?,
}

-- ========= BASICS =========
local MAX_WAVES = 1000
local STEP = 15
local GUARANTEED_BOSS_EVERY = 15
local EXTRA_BOSS_CHANCE = 0.08

local EXTENSION = {
	baseCountMultPerSegment = 1.06,
	perWaveCountMultPerSegment = 1.01,
	perWaveHealthMultPerSegment = 1.01,
	perWaveSpawnRateMultPerSegment = 1.01,
	baseDelayMultPerSegment = 0.98,
}

-- ========= BOSSES =========
type BossDef = {
	Name: string,
	DefaultOdds: number,
	ImageId: string?,
	HealthMultiplier: number?,
	KillCashMultiplier: number?,
	DamageMultiplier: number?,
	EnemiesOverride: { Group }?,
}
local Bosses: { BossDef } = {
	{
		Name = "Drooling Zombie",
		DefaultOdds = 0.50,
		ImageId = "rbxassetid://111610396402545",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},
	
	{
		Name = "Ghost Rider",
		DefaultOdds = 0.60,
		ImageId = "rbxassetid://122442057337109",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Noob Boss",
		DefaultOdds = 0.70,
		ImageId = "rbxassetid://130140534739954",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Jandel Boss",
		DefaultOdds = 0.55,
		ImageId = "rbxassetid://135733218169449",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Shedletsky Boss",
		DefaultOdds = 0.70,
		ImageId = "rbxassetid://126735198756079",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Zombie Boss",
		DefaultOdds = 0.70,
		ImageId = "rbxassetid://116373301567241",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Void Boss",
		DefaultOdds = 0.30,
		ImageId = "rbxassetid://115344938798030",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Bacon Boss",
		DefaultOdds = 0.67,
		ImageId = "rbxassetid://94458678326774",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Pumpkin Alien",
		DefaultOdds = 0.67,
		ImageId = "rbxassetid://94458678326774",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Pumpkin Alien",
		DefaultOdds = 0.67,
		ImageId = "rbxassetid://100993286322952",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},

	{
		Name = "Pumpkin Reaper",
		DefaultOdds = 0.67,
		ImageId = "rbxassetid://97691854894317",
		HealthMultiplier = 3.2,
		KillCashMultiplier = 2.0,
		DamageMultiplier = 1.3,
	},
}

-- ========= SEGMENTS (after 15) =========
type Segment = {
	enemyWeights: { [string]: number },
	bossWeights: { [string]: number }?,
	baseCount: number?,
	perWaveCountMult: number?,
	perWaveHealthMult: number?,
	perWaveSpawnRateMult: number?,
	baseDelay: number?,
}
local Segments: { Segment } = {
	-- 1630
	{
		enemyWeights = {
			["Normal Zombie"] = 0.35,
			["Ghost Zombie"]  = 0.30,
			["Ice Zombie"]    = 0.25,
			["Fire Zombie"]   = 0.10,
			["Skeleton"]   = 0.30,
			["Angry Miner"]   = 0.24,
			["Half Skeletal"]   = 0.10,
			["Explosive Boy"]   = 0.10,
			["RogueCowboy"]   = 0.15,
			["SkullHead"]   = 0.10,
		},
		baseCount = 24,
		perWaveCountMult = 1.03,
		perWaveHealthMult = 1.02,
		perWaveSpawnRateMult = 1.02,
		baseDelay = 1.2,
	},
	-- 3145
	{
		enemyWeights = {
			["Normal Zombie"] = 0.30,
			["Ghost Zombie"]  = 0.20,
			["Ice Zombie"]    = 0.20,
			["Fire Zombie"]   = 0.30,
			["Skeleton"]   = 0.30,
			["Angry Miner"]   = 0.30,
			["Half Skeletal"]   = 0.20,
			["Explosive Boy"]   = 0.15,
			["RogueCowboy"]   = 0.20,
			["SkullHead"]   = 0.20,
			["Looter Caravan"] = 0.15,
			["Alien Bandit"] = 0.10,
			["Rider Villain"] = 0.15,
			["Ghost Cowboy"] = 0.15,
		},
		baseCount = 26,
		perWaveCountMult = 1.035,
		perWaveHealthMult = 1.022,
		perWaveSpawnRateMult = 1.022,
		baseDelay = 1.15,
	},
	-- 4660+ (odds repeat; knobs ramp every extra segment)
	{
		enemyWeights = {
			["Normal Zombie"] = 0.30,
			["Ghost Zombie"]  = 0.25,
			["Ice Zombie"]    = 0.25,
			["Fire Zombie"]   = 0.20,
			["Skeleton"]   = 0.30,
			["Angry Miner"]   = 0.30,
			["Half Skeletal"]   = 0.25,
			["Explosive Boy"]   = 0.25,
			["RogueCowboy"]   = 0.30,
			["SkullHead"]   = 0.30,
			["Looter Caravan"] = 0.25,
			["Alien Bandit"] = 0.20,
			["Rider Villain"] = 0.20,
			["Ghost Cowboy"] = 0.20,
		},
		baseCount = 28,
		perWaveCountMult = 1.04,
		perWaveHealthMult = 1.025,
		perWaveSpawnRateMult = 1.022,
		baseDelay = 1.10,
	},
}

-- ========= HARDCODED 115 =========
local WaveConfigurations: { [number]: WaveConfig } = {
	[1]  = { CashReward=25,  IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=3, DelayBetweenSpawns=1.4}} },
	[2]  = { CashReward=40,  IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=5, DelayBetweenSpawns=1.4}} },
	[3]  = { CashReward=55,  IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=6, DelayBetweenSpawns=1.3},{Enemy="Ghost Zombie", Count=2, DelayBetweenSpawns=1.3}} },
	[4]  = { CashReward=70,  IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=8, DelayBetweenSpawns=1.3},{Enemy="Ghost Zombie", Count=2, DelayBetweenSpawns=1.3}} },
	[5]  = { CashReward=90,  IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=8, DelayBetweenSpawns=1.2},{Enemy="Ghost Zombie", Count=3, DelayBetweenSpawns=1.2},{Enemy="Ice Zombie", Count=1, DelayBetweenSpawns=1.2}} },
	[6]  = { CashReward=110, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=10,DelayBetweenSpawns=1.2},{Enemy="Ghost Zombie", Count=3, DelayBetweenSpawns=1.2},{Enemy="Ice Zombie", Count=2, DelayBetweenSpawns=1.2}} },
	[7]  = { CashReward=130, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=12,DelayBetweenSpawns=1.2},{Enemy="Ghost Zombie", Count=4, DelayBetweenSpawns=1.2},{Enemy="Ice Zombie", Count=2, DelayBetweenSpawns=1.2}} },
	[8]  = { CashReward=150, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=14,DelayBetweenSpawns=1.2},{Enemy="Ghost Zombie", Count=5, DelayBetweenSpawns=1.2},{Enemy="Ice Zombie", Count=3, DelayBetweenSpawns=1.2}} },
	[9]  = { CashReward=170, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=16,DelayBetweenSpawns=1.1},{Enemy="Ghost Zombie", Count=6, DelayBetweenSpawns=1.1},{Enemy="Ice Zombie", Count=3, DelayBetweenSpawns=1.1}} },
	[10] = { CashReward=190, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=18,DelayBetweenSpawns=1.1},{Enemy="Ghost Zombie", Count=7, DelayBetweenSpawns=1.1},{Enemy="Ice Zombie", Count=3, DelayBetweenSpawns=1.1}} },
	[11] = { CashReward=210, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=20,DelayBetweenSpawns=1.0},{Enemy="Ghost Zombie", Count=7, DelayBetweenSpawns=1.0},{Enemy="Ice Zombie", Count=4, DelayBetweenSpawns=1.0}} },
	[12] = { CashReward=230, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=20,DelayBetweenSpawns=1.0},{Enemy="Ghost Zombie", Count=8, DelayBetweenSpawns=1.0},{Enemy="Ice Zombie", Count=5, DelayBetweenSpawns=1.0}} },
	[13] = { CashReward=260, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=22,DelayBetweenSpawns=1.0},{Enemy="Ghost Zombie", Count=9, DelayBetweenSpawns=1.0},{Enemy="Ice Zombie", Count=5, DelayBetweenSpawns=1.0},{Enemy="Fire Zombie", Count=1, DelayBetweenSpawns=1.0}} },
	[14] = { CashReward=280, IsBossWave=false, Enemies={{Enemy="Normal Zombie", Count=24,DelayBetweenSpawns=1.0},{Enemy="Ghost Zombie", Count=10,DelayBetweenSpawns=1.0},{Enemy="Ice Zombie", Count=6, DelayBetweenSpawns=1.0},{Enemy="Fire Zombie", Count=2, DelayBetweenSpawns=1.0}} },
	[15] = { CashReward=300, IsBossWave=true,  BossImageId="rbxassetid://121107085551812", Enemies={{Enemy="Drooling Zombie", Count=1, DelayBetweenSpawns=0}} },
}

-- ========= HELPERS =========
local function cashForWave(w: number): number
	local v = 180 + 10*w + 0.65*(w*w)
	return math.floor(v/5 + 0.5) * 5
end

local function weightsToCounts(weights: { [string]: number }, total: number): { [string]: number }
	local out, used = {}, 0
	local keys = {}
	for k in pairs(weights) do table.insert(keys, k) end
	table.sort(keys)
	for i, name in ipairs(keys) do
		if i < #keys then
			local c = math.floor(total * (weights[name] or 0))
			out[name] = c
			used += c
		else
			out[name] = math.max(0, total - used)
		end
	end
	return out
end

local function pickBoss(bossWeights: { [string]: number }?): BossDef
	local pool = {}
	if bossWeights then
		for name, weight in pairs(bossWeights) do pool[name] = weight end
	else
		for _, b in ipairs(Bosses) do pool[b.Name] = b.DefaultOdds end
	end
	local total, acc = 0, 0
	for _, v in pairs(pool) do total += v end
	local roll = math.random() * math.max(total, 1e-6)
	for name, v in pairs(pool) do
		acc += v
		if roll <= acc then
			for _, b in ipairs(Bosses) do if b.Name == name then return b end end
		end
	end
	return Bosses[1]
end

-- ========= SEGMENT LOGIC =========
local function segmentIndex(w: number): number
	return math.floor((w - 16) / STEP) + 1
end

local function getSegmentForWave(w: number): Segment
	local idx = segmentIndex(w)
	local last = #Segments
	if idx <= last then
		return Segments[idx]
	else
		local seg = Segments[last]
		local extra = idx - last
		return {
			enemyWeights = seg.enemyWeights,
			bossWeights  = seg.bossWeights,
			baseCount = math.floor((seg.baseCount or 24) * (EXTENSION.baseCountMultPerSegment ^ extra)),
			perWaveCountMult = (seg.perWaveCountMult or 1.03) * (EXTENSION.perWaveCountMultPerSegment ^ extra),
			perWaveHealthMult = (seg.perWaveHealthMult or 1.02) * (EXTENSION.perWaveHealthMultPerSegment ^ extra),
			perWaveSpawnRateMult = (seg.perWaveSpawnRateMult or 1.02) * (EXTENSION.perWaveSpawnRateMultPerSegment ^ extra),
			baseDelay = math.max(0.05, (seg.baseDelay or 1.2) * (EXTENSION.baseDelayMultPerSegment ^ extra)),
		}
	end
end

local function makeBossWave(w: number, seg: Segment): WaveConfig
	local b = pickBoss(seg.bossWeights)
	return {
		CashReward = cashForWave(w) + 250,
		IsBossWave = true,
		BossImageId = b.ImageId,
		HealthMultiplier = b.HealthMultiplier or 3.0,
		KillCashMultiplier = b.KillCashMultiplier or 2.0,
		DamageMultiplier = b.DamageMultiplier or 1.25,
		Enemies = b.EnemiesOverride or { { Enemy = b.Name, Count = 1, DelayBetweenSpawns = 0 } },
	}
end

local function makeNormalWave(w: number, seg: Segment): WaveConfig
	local idx = segmentIndex(w)
	local segStart = 16 + (idx - 1) * STEP
	local step = math.max(0, w - segStart)

	local baseCount = seg.baseCount or 24
	local cMult = seg.perWaveCountMult or 1.03
	local hpMult = seg.perWaveHealthMult or 1.02
	local rateMult = seg.perWaveSpawnRateMult or 1.02
	local delay = seg.baseDelay or 1.2

	local total = math.max(1, math.floor(baseCount * (cMult ^ step)))
	local counts = weightsToCounts(seg.enemyWeights, total)
	local enemies = {}
	for name, c in pairs(counts) do
		if c > 0 then
			table.insert(enemies, { Enemy = name, Count = c, DelayBetweenSpawns = delay })
		end
	end
	table.sort(enemies, function(a,b) return a.Enemy < b.Enemy end)

	return {
		CashReward = cashForWave(w),
		IsBossWave = false,
		Enemies = enemies,
		HealthMultiplier = hpMult ^ step,
		SpawnDelayMultiplier = 1 / math.max(0.25, rateMult ^ step),
	}
end

-- ========= BUILD ALL WAVES (NUMERIC KEYS ONLY) =========
for w = 16, MAX_WAVES do
	local seg = getSegmentForWave(w)
	if (w % GUARANTEED_BOSS_EVERY) == 0 then
		WaveConfigurations[w] = makeBossWave(w, seg)
	elseif math.random() < EXTRA_BOSS_CHANCE then
		WaveConfigurations[w] = makeBossWave(w, seg)
	else
		WaveConfigurations[w] = makeNormalWave(w, seg)
	end
end

-- expose ResolveWave without polluting pairs()
local function ResolveWave(w: number): WaveConfig
	return WaveConfigurations[w]
end

setmetatable(WaveConfigurations, {
	__index = function(_, k)
		if k == "ResolveWave" then
			return ResolveWave
		end
		return nil
	end
})

return WaveConfigurations


---

--- WeaponConfigurations (ModuleScript) :
--!strict
-- This module contains data for all crates and weapons.

local WeaponConfigurations = {
	--RESTOCKS
	ShopProducts = {
		RestockBlocksShop = { ProductID = 3435398560}, -- Use your new DevProduct ID here
		RestockWeaponsShop = { ProductID = 3435398961}, -- Use your new DevProduct ID here
	},
	--CASH
	CashProducts = {
		Product1 = { ProductID = 3433108028, CashAmount = 5000 },
		Product2 = { ProductID = 3433108213, CashAmount = 25000 },
		Product3 = { ProductID = 3433108417, CashAmount = 100000 },
		Product4 = { ProductID = 3433108573, CashAmount = 300000 },
	},
	--CRATES
	Crates = {
		--ROBUX
		GoldCrate = {
			DisplayName = "Gold Crate",
			ImageId = "rbxassetid://103369512470336",
			ProductID = 3433548997,
			Loot = {
				{Item = "Electra", Weight = 25},
				{Item = "Heliocore", Weight = 15},
				{Item = "PlasmaGun", Weight = 15},
				{Item = "Riftshot", Weight = 20},
				{Item = "Toxion", Weight = 25},
			}
		},
		--SHOP
		WoodCrate = {
			DisplayName = "Wood Crate",
			Price = 600,
			ImageId = "rbxassetid://71941897708431",
			ProductID = 3433106911,
			SkipTimerProductID = 3433550556,
			Unlimited = false,
			Chance = 100,
			StockAmount = {Min = 1, Max = 5},
			UnlockTime = 60,
			Loot = {
				{Item = "KimberK65", Weight = 40},
				--{Item = "DesertEagle", Weight = 25},
				{Item = "Uzi", Weight = 5},
			}
		},
		MetalCrate = {
			DisplayName = "Metal Crate",
			Price = 4500,
			ImageId = "rbxassetid://83369732207805",
			ProductID = 3433107064,
			SkipTimerProductID = 3433550660,
			Unlimited = false,
			Chance = 60,
			StockAmount = {Min = 1, Max = 4},
			UnlockTime = 180,
			Loot = {
				{Item = "Uzi", Weight = 30},
				{Item = "Mp5", Weight = 20},
				{Item = "K3", Weight = 10},
				{Item = "Ak47", Weight = 4.5},
			}
		},
		LavaCrate = {
			DisplayName = "Mystic Crate",
			Price = 10500,
			ImageId = "rbxassetid://123400851920868",
			ProductID = 3451490544,
			SkipTimerProductID = 3451799259,
			Unlimited = false,
			Chance = 30,
			StockAmount = {Min = 1, Max = 3},
			UnlockTime = 480,
			Loot = {
				{Item = "Uzi", Weight = 40},
				{Item = "Mp5", Weight = 30},
				{Item = "Ak47", Weight = 15},
				{Item = "K3", Weight = 30},
				{Item = "Electra", Weight = 0.5},
				{Item = "Heliocore", Weight = 0.5},
				{Item = "PlasmaGun", Weight = 0.5},
				{Item = "Riftshot", Weight = 0.5},
				{Item = "Toxion", Weight = 0.5},
			}
		},
	},

	Weapons = {
		----Starter
		Heizer = { DisplayName = "Starter Pistol", ImageId = "rbxassetid://126357192361583" },
		--Wood
		KimberK65 = { DisplayName = "Revolver", ImageId = "rbxassetid://126357192361583" },
		DesertEagle = { DisplayName = "Desert Eagle", ImageId = "rbxassetid://126321981198719" },
		--Metal 
		Uzi = { DisplayName = "Uzi", ImageId = "rbxassetid://105402058861520" },
		Mp5 = { DisplayName = "MP5", ImageId = "rbxassetid://86471167567925" },
		sp5 = { DisplayName = "SP5", ImageId = "rbxassetid://126321981198719" },
		--Lava
		K3 = { DisplayName = "K3", ImageId = "rbxassetid://101148291850721" },
		M14 = { DisplayName = "M14", ImageId = "rbxassetid://126321981198719" },
		--Gold 
		Ak47 = { DisplayName = "Ak-47", ImageId = "rbxassetid://76263708523559" },
		Scout = { DisplayName = "Scout Sniper", ImageId = "rbxassetid://126321981198719" },
		Minigun = { DisplayName = "OP Minigun", ImageId = "rbxassetid://105369473183603" },
		
		Heliocore = { DisplayName = "Heliocore", ImageId = "rbxassetid://110449100260279" },
		Electra = { DisplayName = "Electra", ImageId = "rbxassetid://97942841375097" },
		Toxion = { DisplayName = "Toxion", ImageId = "rbxassetid://122765809455182" },
		Riftshot = { DisplayName = "Riftshot", ImageId = "rbxassetid://129412800119898" },
		PlasmaGun = { DisplayName = "PlasmaGun", ImageId = "rbxassetid://112273276197884" },

		
		
		
		--WoodSword = { DisplayName = "Wood Sword", ImageId = "rbxassetid://126321981198719" },
		----Wood
		--StoneSword = { DisplayName = "Stone Sword", ImageId = "rbxassetid://98850338938642" },
		--ClassicSword = { DisplayName = "Classic Sword", ImageId = "rbxassetid://137083985660048" },
		--WhiteSword = { DisplayName = "WhiteSword", ImageId = "rbxassetid://107209992307667" },
		----Metal
		--BlueSword = { DisplayName = "Blue Sword", ImageId = "rbxassetid://106268955187746" },
		--IceSword = { DisplayName = "Ice Sword", ImageId = "rbxassetid://86285408542421" },
		--AzureSword = { DisplayName = "Azure Sword", ImageId = "rbxassetid://139447042654835" },
		--PinkSword = { DisplayName = "Pink Sword", ImageId = "rbxassetid://123160254672400" },
		----Lava
		--OrangeSword = { DisplayName = "Orange Sword", ImageId = "rbxassetid://127527435191865" },
		--RedSword = { DisplayName = "Red Sword", ImageId = "rbxassetid://101443099194443" },
		--DragonSword = { DisplayName = "Dragon Sword", ImageId = "rbxassetid://101415025341980" },
		----Gold
		--GoldSword = { DisplayName = "Gold Sword", ImageId = "rbxassetid://122412629570696" },
		--GoldClassic = { DisplayName = "Gold Classic", ImageId = "rbxassetid://94902355900831" },
		--GoldIce = { DisplayName = "Gold Ice", ImageId = "rbxassetid://87139784295616" },
		--GoldAzure = { DisplayName = "Gold Azure", ImageId = "rbxassetid://74018974426561" },
	}
}

return WeaponConfigurations
---